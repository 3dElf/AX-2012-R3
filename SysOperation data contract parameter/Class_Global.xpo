Exportfile for AOT version 1.0 or later
Formatversion: 1

***Element: CLS

; Microsoft Dynamics AX Class: Global unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #Global
    PROPERTIES
      Name                #Global
      Origin              #{2D06F006-0000-1000-476C-6F62616C0000}
      LegacyId            #61446
    ENDPROPERTIES
    
    METHODS
      SOURCE #classDeclaration
        #// This is a framework class. Customizing this class may cause problems with future upgrades to the software.
        #public class Global
        #{
        #    #define.ATTR_TYPE("type")
        #    #define.ATTR_KEY_TYPE("keytype")
        #    #define.ATTR_VALUE_TYPE("valuetype")
        #    // <GJP>
        #    #DateFormat_JP
        #    // </GJP>
        #    #define.CURRENT_WORKER_ID("currentWorkerId")
        #    #define.CURRENT_PARTY("currentParty")
        #    #define.VIRTUALCOMPANYLIST("virtualcompanylist")
        #    #define.ISVIRTUALCOMPANY("isvirtualcompany")
        #}
      ENDSOURCE
      SOURCE #acceleratedDepreciation
        #/// <summary>
        #/// Calculates the accelerated depreciation of an asset.
        #/// </summary>
        #/// <param name="price">
        #/// The purchase price of the asset.
        #/// </param>
        #/// <param name="scrap">
        #/// The residual value of the asset that has been written off.
        #/// </param>
        #/// <param name="life">
        #/// The expected lifetime of the asset.
        #/// </param>
        #/// <param name="period">
        #/// The period over which to calculate depreciation.
        #/// </param>
        #/// <returns>
        #/// The depreciation of the asset.
        #/// </returns>
        #/// <remarks>
        #/// This method is a rename of the <c>ddb</c> method.
        #/// </remarks>
        #static real acceleratedDepreciation(real price, real scrap, real life, int period)
        #{
        #    return ddb(price, scrap, life, period);
        #}
      ENDSOURCE
      SOURCE #accessRight2NeededPermission
        #/// <summary>
        #/// Converts a <c>AccessRight</c> enumeration type into a <c>NeededPermission</c> enumeration type.
        #/// </summary>
        #/// <param name="_accessRight">
        #/// The <c>AccessRight</c> enumeration type to convert.
        #/// </param>
        #/// <returns>
        #/// The converted <c>NeededPermission</c> enumeration type.
        #/// </returns>
        #public static NeededPermission accessRight2NeededPermission(AccessRight _accessRight)
        #{
        #    NeededPermission neededPermission = NeededPermission::None;
        #
        #    switch (_accessRight)
        #    {
        #        case AccessRight::View:
        #            neededPermission = NeededPermission::Read;
        #            break;
        #
        #        case AccessRight::Edit:
        #            neededPermission = NeededPermission::Update;
        #            break;
        #
        #        case AccessRight::Add:
        #            neededPermission = NeededPermission::Create;
        #            break;
        #
        #        case AccessRight::Correction:
        #            neededPermission = NeededPermission::Correct;
        #            break;
        #
        #        case AccessRight::Delete:
        #            neededPermission = NeededPermission::Delete;
        #            break;
        #
        #        default:
        #            neededPermission = NeededPermission::None;
        #            break;
        #    }
        #
        #    return neededPermission;
        #}
      ENDSOURCE
      SOURCE #allowEditFieldsOnFormDS_W
        #client static public void allowEditFieldsOnFormDS_W(FormDataSource _dataSource, boolean _allowEdit)
        #{
        #    DictTable       dictTable = new DictTable(_dataSource.table());
        #    DictField       dictField;
        #    FormDataObject  dataObject;
        #    int         cx, idx;
        #
        #    for(cx = 1; cx <= dictTable.fieldCnt(); cx ++)
        #    {
        #        dictField = dictTable.fieldObject(dictTable.fieldCnt2Id(cx));
        #
        #        if(! dictField.isSystem())
        #        {
        #            for(idx = 1; idx <= dictField.arraySize(); idx++)
        #            {
        #                dataObject = _dataSource.object(fieldId2Ext(dictField.id(), idx));
        #                if (dataObject)
        #                {
        #                    dataObject.allowEdit(_allowEdit);
        #                }
        #            }
        #        }
        #    }
        #}
      ENDSOURCE
      SOURCE #aosClientMode
        #static client server AOSClientMode aosClientMode()
        #{
        #    return classfactory.aosClientMode();
        #}
      ENDSOURCE
      SOURCE #arabic2Roman
        #/// <summary>
        #/// Converts number to roman numeral.
        #/// </summary>
        #/// <param name="_arabic">
        #/// Number to convert.
        #/// </param>
        #/// <returns>
        #/// Roman number if convertable.
        #/// </returns>
        #/// <remarks>
        #/// There is no definite rule for converting to roman numerals about 2000 and above.
        #/// Numbers starting from 4000 require vinculum letters, so are not supported.
        #/// </remarks>
        #static public str arabic2Roman(int _arabic)
        #{
        #    container   arabicCon = [ 1,   5,   10,  50,  100, 500, 1000 ];
        #    container   romanCon  = [ 'I', 'V', 'X', 'L', 'C', 'D', 'M'  ];
        #
        #    str         roman;
        #    int         i, j;
        #    int         remainder;
        #
        #    if (_arabic <= 0 || _arabic > 3999)
        #        return '';
        #
        #    while (_arabic >= conPeek(arabicCon, i+1) &&
        #           i+1 <= conLen(arabicCon))
        #    {
        #        i++;
        #    }
        #
        #    remainder = _arabic mod conPeek(arabicCon, i);
        #
        #    if (i > 1 ? remainder div conPeek(arabicCon, i-1) > 3 : false)
        #    {
        #        roman = conPeek(romanCon, i-1) + conPeek(romanCon, i+1);
        #
        #        if (strLen(int2str(_arabic)) >= 1)
        #        {
        #            roman += arabic2Roman(_arabic - conPeek(arabicCon, i+1) + conPeek(arabicCon, i-1));
        #        }
        #    }
        #
        #    else
        #    {
        #        if (_arabic div conPeek(arabicCon, i) > 3)
        #        {
        #            roman = conPeek(romanCon, i) + conPeek(romanCon, i+1);
        #        }
        #        else
        #        {
        #            for (j = 1; j <= _arabic div conPeek(arabicCon, i); j++)
        #            {
        #                roman += conPeek(romanCon, i);
        #            }
        #        }
        #        if (strLen(int2str(_arabic)) >= 1)
        #        {
        #            roman += arabic2Roman(remainder);
        #        }
        #    }
        #
        #    return roman;
        #}
      ENDSOURCE
      SOURCE #binary2cryptoblob
        #static CryptoBlob binary2cryptoblob(Binary _binary, int _binaryLength)
        #{
        #    int i;
        #    CryptoBlob cryptoBlob;
        #
        #    if (_binary && _binaryLength > 0)
        #    {
        #        for (i = 0; i < _binaryLength; i++)
        #            cryptoBlob += [_binary.byte(i)];
        #
        #        return cryptoBlob;
        #    }
        #    else
        #    {
        #        return conNull();
        #    }
        #
        #}
      ENDSOURCE
      SOURCE #bitReset
        #static int bitReset(int _flags, int _reset)
        #{
        #    return _flags & ~_reset;
        #}
      ENDSOURCE
      SOURCE #bitSet
        #static int bitSet(int _flags, int _set)
        #{
        #    return _flags | _set;
        #}
      ENDSOURCE
      SOURCE #bitTest
        #static boolean bitTest(int _flags, int _test)
        #{
        #    return (_flags & _test) != 0;
        #}
      ENDSOURCE
      SOURCE #buf2Buf
        #static void buf2Buf(
        #    Common  _from,
        #    Common  _to,
        #    TableScope _scope = TableScope::CurrentTableOnly
        #    )
        #{
        #    DictTable   dictTable = new DictTable(_from.TableId);
        #    FieldId     fieldId   = dictTable.fieldNext(0, _scope);
        #
        #    while (fieldId && ! isSysId(fieldId))
        #    {
        #        _to.(fieldId)   = _from.(fieldId);
        #        fieldId         = dictTable.fieldNext(fieldId, _scope);
        #    }
        #}
      ENDSOURCE
      SOURCE #buf2Con
        #/// <summary>
        #/// Converts a record into a container.
        #/// </summary>
        #/// <param name="_common">Record to be converted.</param>
        #/// <param name="_packOrigBuffer">true if the original table buffer must be included as part of the container, false otherwise.</param>
        #/// <returns>A container with the table buffers of a record.</returns>
        #static container buf2Con(Common _common, boolean _packOrigBuffer =  false)
        #{
        #    return _common.buf2con(_packOrigBuffer);
        #}
      ENDSOURCE
      SOURCE #bufCmp
        #static boolean bufCmp(Common b1,Common b2)
        #{
        #    return b1.equal(b2);
        #}
      ENDSOURCE
      SOURCE #charMax
        #static client server char charMax()
        #{
        #    char charMax = classfactory.globalCache().get(funcName(),0,'');
        #
        #    if (!charMax)
        #    {
        #        charMax = appl.charMax();
        #        classfactory.globalCache().set(funcName(),0,charMax, false);
        #    }
        #
        #    return charMax;
        #}
      ENDSOURCE
      SOURCE #checkFailed
        #client server static boolean checkFailed(SysInfoLogStr txt, URL helpURL = '', SysInfoAction _sysInfoAction = null)
        #{
        #    infolog.add(Exception::Warning, getPrefix()+txt, helpURL, _sysInfoAction, false);
        #    return false;
        #}
      ENDSOURCE
      SOURCE #checkPercentage
        #/// <summary>
        #///    Checks that the specified percentage value is between zero and 100.
        #/// </summary>
        #/// <param name="_value">
        #///    The percentage value to check.
        #/// </param>
        #/// <returns>
        #///    true if the value is between zero and 100; otherwise, false.
        #/// </returns>
        #static boolean checkPercentage(real _value)
        #{
        #    if(_value < 0 ||
        #       _value > 100)
        #    {
        #        return checkFailed("@SYS113615");
        #    }
        #
        #    return true;
        #}
      ENDSOURCE
      SOURCE #checkPower
        #private static container checkPower(int64  _test, int64 _power, GenderMaleFemale _gender, boolean _isMexican)
        #{
        #    int64   numOfPower, auxnumOfPower;
        #    int64   temp;
        #    real    test = any2real(_test);
        #    str     strText, returntxt, cPstr;
        #    int     intStrText;
        #    int64   cPint;
        #    real    temptest;   // to support ES-MX billions
        #    real    tempauxtest;
        #    real    auxtest = 0;
        #    real    numOfTenths ;
        #
        #    str 20  ones[19], twenties[9], tenths[9],  muchhundreds, hundreds, thousands, muchmillions, millions, billions, muchhunmillions, trillions, muchtrillions;
        #
        #    #Define.text_1_male('Un')
        #    #Define.text_1_female('Una')
        #    #Define.text_2('Dos')
        #    #Define.text_3('Tres')
        #    #Define.text_4('Cuatro')
        #    #Define.text_5('Cinco')
        #    #Define.text_6('Seis')
        #    #Define.text_7('Siete')
        #    #Define.text_8('Ocho')
        #    #Define.text_9('Nueve')
        #    #Define.text_10('Diez')
        #    #Define.text_11('Once')
        #    #Define.text_12('Doce')
        #    #Define.text_13('Trece')
        #    #Define.text_14('Catorce')
        #    #Define.text_15('Quince')
        #    #Define.text_16('Dieciseis')
        #    #Define.text_17('Diecisiete')
        #    #Define.text_18('Dieciocho')
        #    #Define.text_19('Diecinueve')
        #
        #    #Define.text_20('Veinte')
        #
        #    #Define.text_21_female('Veintiuna')
        #    #Define.text_21_male('Veintiun')
        #    #Define.text_22('Veintidos')
        #    #Define.text_23('Veintitres')
        #    #Define.text_24('Veinticuatro')
        #    #Define.text_25('Veinticinco')
        #    #Define.text_26('Veintiseis')
        #    #Define.text_27('Veintisiete')
        #    #Define.text_28('Veintiocho')
        #    #Define.text_29('Veintinueve')
        #
        #    #Define.text_30('Treinta')
        #    #Define.text_40('Cuarenta')
        #    #Define.text_50('Cincuenta')
        #    #Define.text_60('Sesenta')
        #    #Define.text_70('Setenta')
        #    #Define.text_80('Ochenta')
        #    #Define.text_90('Noventa')
        #
        #    #Define.text_100('Cien')
        #    #Define.text_100_female('cientas')
        #    #Define.text_100_male('cientos')
        #    #Define.text_100_much('Cientos')
        #    #Define.text_100_begin('Ciento')
        #
        #    #Define.text_500_female('Quinientas')
        #    #Define.text_500_male('Quinientos')
        #
        #    #Define.text_7_begin('Sete')
        #    #Define.text_9_begin('Nove')
        #
        #    #Define.text_1000('Mil')
        #
        #    #Define.text_1000000('Millon')
        #    #Define.text_1000000_much('Millones')
        #    #Define.text_1000000000('Mil millones')
        #    #Define.text_1000000000000('Trillón')
        #    #Define.text_1000000000000_much('Trillónes')
        #
        #    #Define.text_and('y')
        #
        #    ones[1] = #text_1_male;
        #    ones[2] = #text_2;
        #    ones[3] = #text_3;
        #    ones[4] = #text_4;
        #    ones[5] = #text_5;
        #    ones[6] = #text_6;
        #    ones[7] = #text_7;
        #    ones[8] = #text_8;
        #    ones[9] = #text_9;
        #    ones[10] = #text_10;
        #    ones[11] = #text_11;
        #    ones[12] = #text_12;
        #    ones[13] = #text_13;
        #    ones[14] = #text_14;
        #    ones[15] = #text_15;
        #    ones[16] = #text_16;
        #    ones[17] = #text_17;
        #    ones[18] = #text_18;
        #    ones[19] = #text_19;
        #
        #    twenties[1] = _gender == GenderMaleFemale::Female ? #text_21_female: #text_21_male;
        #    twenties[2] = #text_22;
        #    twenties[3] = #text_23;
        #    twenties[4] = #text_24;
        #    twenties[5] = #text_25;
        #    twenties[6] = #text_26;
        #    twenties[7] = #text_27;
        #    twenties[8] = #text_28;
        #    twenties[9] = #text_29;
        #
        #    tenths[1] = ''; // Not used
        #    tenths[2] = #text_20;
        #    tenths[3] = #text_30;
        #    tenths[4] = #text_40;
        #    tenths[5] = #text_50;
        #    tenths[6] = #text_60;
        #    tenths[7] = #text_70;
        #    tenths[8] = #text_80;
        #    tenths[9] = #text_90;
        #
        #    hundreds    = #text_100;
        #
        #    muchhundreds = _gender == GenderMaleFemale::Female ? #text_100_female: #text_100_male;
        #
        #    muchhunmillions = #text_100_much;
        #
        #    thousands   = #text_1000;
        #    millions    = #text_1000000;
        #    muchmillions = #text_1000000_much;
        #
        #    billions    = #text_1000000000;
        #    trillions   = #text_1000000000000;
        #    muchtrillions = #text_1000000000000_much;
        #
        #
        #    if (_test >= _power)
        #    {
        #        numOfPower = _test div _power;
        #        if (numOfPower >= 100)
        #        {
        #            temp = numOfPower div 100;
        #            if (temp == 1 )
        #            {
        #                if  (((_power == 1000) && (numOfPower > 100)) || ((_power == 1000000) && (numOfPower > 100)))
        #                {
        #                    returntxt = returntxt + ' ' +  #text_100_begin;
        #                }
        #                else
        #                {
        #                    returntxt = returntxt + ' ' +  hundreds;
        #                }
        #            }
        #            else
        #            {
        #                switch(temp)
        #                {
        #                    case 5:
        #                        if (_power == 1000)
        #                        {
        #                            returntxt = returntxt + ' ' + (_gender == GenderMaleFemale::Female ? #text_500_female : #text_500_male);
        #                        }
        #                        else
        #                        {
        #                            returntxt = returntxt + ' ' + #text_500_male;
        #                        }
        #                        break;
        #
        #                    case 7:
        #                        if ( _power == 1000)
        #                        {
        #                            returntxt = returntxt + ' ' +  #text_7_begin + muchhundreds;
        #                        }
        #                        else
        #                        {
        #                            returntxt = returntxt + ' ' +  #text_7_begin + muchhunmillions;
        #                        }
        #                        break;
        #
        #                    case 9:
        #                        if ( _power == 1000)
        #                        {
        #                            returntxt = returntxt + ' ' +  #text_9_begin + muchhundreds;
        #                        }
        #                        else
        #                        {
        #                            returntxt = returntxt + ' ' +  #text_9_begin + muchhunmillions;
        #                        }
        #                        break;
        #
        #                    default:
        #                        if ( _power == 1000 )
        #                        {
        #                            returntxt = returntxt + ' ' + ones[temp] + muchhundreds;
        #                        }
        #                        else
        #                        {
        #                            returntxt = returntxt + ' ' + ones[temp] + muchhunmillions;
        #                        }
        #
        #                }
        #            }
        #            numOfPower = numOfPower mod 100;
        #        }
        #
        #        if (numOfPower >= 20)
        #        {
        #            temp = numOfPower div 10;
        #            if (numOfPower > 20 && numOfPower < 30)
        #            {
        #                if ( ( numOfPower == 21 ) & ( _power == 1000000 ) )
        #                {
        #                    returntxt = returntxt + ' ' + #text_21_male;
        #                }
        #                else
        #                {
        #                    returntxt = returntxt + ' ' + twenties[numOfPower-20];
        #                }
        #            }
        #            else
        #            {
        #                returntxt = returntxt + ' ' + tenths[temp];
        #            }
        #
        #            auxnumOfPower = numOfPower;
        #            numOfPower = numOfPower mod 10;
        #        }
        #
        #        if ((numOfPower >= 1 ) && !(auxnumOfPower > 20 && auxnumOfPower < 30))
        #        {
        #            if (!(( (numOfPower == 5) || (numOfPower == 1) || (numOfPower == 7) || (numOfPower == 9) ) && (_power == 100)))
        #            {
        #                if  ((( _power == 1000 ) && ( test > 10000 )) || (( _power == 1000000 ) && ( test > 10000000 )))
        #                {
        #                    strText = subStr(strLTrim(num2str(test,15,0,1,0)),2,2);
        #                    intStrText = str2int(strText);
        #
        #                    if   (((_power == 1000) & ( intStrText >= 1 ) & (intStrText  < 20) & (intStrText  != 10) &
        #                            (intStrText  != 11)) || ((_power == 1000000) & (intStrText >= 1 ) & (intStrText < 20)))
        #                    {
        #                        if (( numOfPower < 20 ) & ( auxnumOfPower < 30 ))
        #                        {
        #                            returntxt = returntxt + ' ' + ones[numOfPower];
        #                        }
        #                        else
        #                        {
        #                            returntxt = returntxt + ' ' + #text_and + ' ' + ones[numOfPower];
        #                        }
        #                    }
        #                    else
        #                    {
        #                        if (( numOfPower < 20 ) & ( auxnumOfPower < 30 ))
        #                        {
        #                            returntxt = returntxt + ' ' + ones[numOfPower];
        #                        }
        #                        else
        #                        {
        #                            returntxt = returntxt + ' ' + #text_and + ' ' + ones[numOfPower];
        #                        }
        #                    }
        #                }
        #                else
        #                {
        #                    if (!((numOfPower == 1) && (_power == 1000)))
        #                    {
        #                        returntxt = returntxt + ' ' + ones[numOfPower];
        #                    }
        #                    else if ((numOfPower == 1) && (_power == 1000) && _isMexican)
        #                    {
        #                        returntxt = returntxt + ' ' + ones[numOfPower];
        #                    }
        #                }
        #            }
        #            numOfPower = numOfPower mod 10;
        #
        #        }
        #
        #        auxnumOfPower = 0;
        #        switch(_power)
        #        {
        #            case 1000000000000:
        #                if (( _test >= 1000000000000) && ( _test < 2000000000000))
        #                {
        #                    returntxt = returntxt + ' ' + trillions;
        #                }
        #                else
        #                {
        #                    returntxt = returntxt + ' ' + muchtrillions;
        #                }
        #                _test = _test mod 1000000000000;
        #                break;
        #
        #            case 1000000000:
        #                if (_isMexican)
        #                {
        #                    // Save test variables
        #                    temptest = test;
        #                    tempauxtest = auxtest;
        #
        #                    // Reset returntxt as it is corrected below
        #                    returntxt = '';
        #
        #                    // Get billions + millions portion
        #                    test = str2num(int642str(_test div 1000000));
        #
        #                    [cPint, cPstr] = Global::checkPower(any2int64(test), 1000, _gender, _isMexican);
        #                    test = str2num(int642str(cPint));
        #                    if(cPstr)
        #                    {
        #                        returntxt = returntxt + ' ' + cPstr;
        #                    }
        #
        #                    [cPint, cPstr] = Global::checkPower(any2int64(test), 100, _gender, _isMexican);
        #                    test = str2num(int642str(cPint));
        #                    if(cPstr)
        #                    {
        #                        returntxt = returntxt + ' ' + cPstr;
        #                    }
        #
        #                    if (test >= 20)
        #                    {
        #                        numOfTenths = real2int(test) div 10;
        #                        if (test > 20 && test < 30)
        #                        {
        #                            returntxt = returntxt + ' ' + twenties[test - 20];
        #                        }
        #                        else
        #                        {
        #                            returntxt = returntxt + ' ' + tenths[numofTenths];
        #                        }
        #                        numOfTenths = real2int(numOfTenths) mod 10;
        #                        auxtest = test;
        #                        test = real2int(test) mod 10;
        #                    }
        #
        #                    if ((test >= 1) && !(auxtest > 20 && auxtest < 30))
        #                    {
        #                        numOfTenths = test;
        #                        if (numOfTenths == 1)
        #                        {
        #                            if (auxtest == 0)
        #                            {
        #                                returntxt = returntxt + ' ' + (_gender == GenderMaleFemale::Female ? #text_1_female : #text_1_male);
        #                            }
        #                            else
        #                            {
        #                                returntxt = returntxt + ' ' + #text_and + ' ' + (_gender == GenderMaleFemale::Female ? #text_1_female : #text_1_male);
        #                            }
        #                        }
        #                        else
        #                        {
        #                            if (( auxtest > 20 ))
        #                            {
        #                                returntxt = returntxt + ' ' + #text_and + ' ' + ones[numOfTenths];
        #                            }
        #                            else
        #                            {
        #                                returntxt = returntxt + ' ' + ones[numOfTenths];
        #                            }
        #                        }
        #                    }
        #
        #                    // Reset test variables
        #                    test = temptest;
        #                    auxtest = tempauxtest;
        #
        #                    if (_test >= 1000000 && _test < 2000000)
        #                    {
        #                        returntxt = returntxt + ' ' + millions;
        #                    }
        #                    else
        #                    {
        #                        returntxt = returntxt + ' ' + muchmillions;
        #                    }
        #                    _test = _test mod 1000000;
        #                }
        #                else
        #                {
        #                    returntxt = returntxt + ' ' + billions;
        #                    _test = _test mod 1000000000;
        #                }
        #                break;
        #
        #            case 1000000:
        #                if (( _test >= 1000000) && ( _test < 2000000))
        #                {
        #                    returntxt = returntxt + ' ' + millions;
        #                }
        #                else
        #                {
        #                    returntxt = returntxt + ' ' + muchmillions;
        #                }
        #                _test = _test mod 1000000;
        #                break;
        #
        #            case 1000:
        #                returntxt = returntxt + ' ' + thousands;
        #                _test = _test mod 1000;
        #                break;
        #
        #            case 100:
        #                if ((_test >= 100) && (_test < 200))
        #                {
        #                    if (_test == 100)
        #                    {
        #                        returntxt = returntxt + ' ' + hundreds;
        #                    }
        #                    else
        #                    {
        #                        returntxt = returntxt + ' ' + #text_100_begin;
        #                    }
        #                }
        #                else
        #                {
        #                    if (_test >= 500 && _test < 600)
        #                    {
        #                        returntxt = returntxt + ' ' + (_gender == GenderMaleFemale::Female ? #text_500_female : #text_500_male);
        #                    }
        #                    else if (_test >= 700 && _test < 800)
        #                    {
        #                        returntxt = returntxt + ' ' + #text_7_begin + muchhundreds;
        #                    }
        #                        else if (_test >= 900 && _test < 1000)
        #                        {
        #                                returntxt = returntxt + ' ' + #text_9_begin + muchhundreds;
        #                        }
        #                            else
        #                            {
        #                                returntxt = returntxt  + muchhundreds;
        #                            }
        #                }
        #
        #                _test = _test mod 100;
        #                break;
        #        }
        #    }
        #    return [_test, strLTrim(returntxt)];
        #}
      ENDSOURCE
      SOURCE #checkSign
        #static boolean checkSign(str s)
        #{
        #    int len = strLen(s);
        #
        #    boolean check(char sign)
        #    {
        #        int pos     = strScan(s,sign,1,len);
        #        int posE    = strScan(s,'e',1,len);
        #
        #        if (! pos)
        #            return true;
        #
        #        // If sign not the first and not the last or if a exp. char then not after this
        #        if (pos != 1 &&
        #           ((! pose && pos != len) ||
        #            (pose && pos < pose)
        #           ))
        #            return false;
        #
        #        // Test for multiple -
        #        s = strRem(s,sign);
        #        if (strLen(s) != len && strLen(s)+1 != len)
        #            return false;
        #
        #        return true;
        #    }
        #
        #    if (! check('-'))
        #        return false;
        #
        #    if (! check('+'))
        #        return false;
        #
        #    return true;
        #}
      ENDSOURCE
      SOURCE #checkTime
        #static boolean checkTime(Seconds timeSec)
        #{
        #    if (timeSec < 0 || timeSec > 24*60*60)
        #        return checkFailed("@SYS25363");
        #
        #    return true;
        #}
      ENDSOURCE
      SOURCE #classId2Name
        #static ClassName classId2Name(ClassId _classId)
        #{
        #    DictClass dictClass = new DictClass(_classId);
        #    if (dictClass)
        #        return dictClass.name();
        #    return '';
        #}
      ENDSOURCE
      SOURCE #className2Id
        #static int className2Id(IdentifierName _className)
        #{
        #    return new Dictionary().className2Id(_className);
        #}
      ENDSOURCE
      SOURCE #clientKind
        #static client server ClientType clientKind()
        #{
        #    SysGlobalCache  cache = classfactory.globalCache();
        #    ClientType      clientType;
        #    xSession         session;
        #
        #    if (cache.isSet(classStr(Global), funcName()))
        #    {
        #        clientType = cache.get(classStr(Global), funcName(), ClientType::Client);
        #    }
        #    else
        #    {
        #        session    = new xSession();
        #        clientType = session.clientKind();
        #        cache.set(classStr(Global), funcName(), clientType, false);
        #    }
        #    return clientType;
        #}
      ENDSOURCE
      SOURCE #clientmode
        #client static AOSClientMode clientmode()
        #{
        #    AOSSessionInfo      aosSession;
        #    Session             session;
        #
        #    session = new Session();
        #    aosSession = new AOSSessionInfo(session.sessionId());
        #    if (aosSession)
        #        return aosSession.clientMode();
        #
        #    return AOSClientMode::NotAOS;
        #}
      ENDSOURCE
      SOURCE #cloneMap
        #/// <summary>
        #/// Creates the non-deep copy of the Map.
        #/// </summary>
        #/// <param name="_mapToClone">
        #/// The map instance to clone.
        #/// </param>
        #/// <returns>
        #/// The non-deep copy of the map passed in the <paramref name="_mapToClone" /> parameter.
        #/// </returns>
        #/// <remarks>
        #/// This method creates a new instance of the map that contains the same element instances as the
        #/// source map.
        #/// </remarks>
        #public static Map cloneMap(Map _mapToClone)
        #{
        #    Map newMap;
        #    MapEnumerator mapEnumerator;
        #
        #    if(!_mapToClone)
        #    {
        #        return null;
        #    }
        #
        #    newMap = new Map(_mapToClone.keyType(), _mapToClone.valueType());
        #    mapEnumerator = new MapEnumerator(_mapToClone);
        #
        #    while(mapEnumerator.moveNext())
        #    {
        #        newMap.insert(mapEnumerator.currentKey(), mapEnumerator.currentValue());
        #    }
        #
        #    return newMap;
        #}
      ENDSOURCE
      SOURCE #clr2XppStr
        #public static str clr2XppStr(System.String s1)
        #{
        #    str s2;
        #    s2 = s1;
        #    return s2;
        #}
      ENDSOURCE
      SOURCE #clrSystemDateTime2UtcDateTime
        #/// <summary>
        #/// Converts a .NET <c>System.DateTime</c> object to an X++ <c>utcdatetime</c> value.
        #/// </summary>
        #/// <param name="_systemDateTime">
        #/// The .NET <c>System.DateTime</c> object to convert.
        #/// </param>
        #/// <returns>
        #/// An X++ <c>utcdatetime</c> value.
        #/// </returns>
        #static utcdatetime clrSystemDateTime2UtcDateTime(System.DateTime _systemDateTime)
        #{
        #    // BP Deviation documented
        #    return CLRInterop::getAnyTypeForObject(_systemDateTime);
        #}
      ENDSOURCE
      SOURCE #con2Buf
        #/// <summary>
        #/// Converts a container into a record.
        #/// </summary>
        #/// <param name="_container">
        #/// Container to be converted
        #/// </param>
        #/// <param name="_rec">
        #/// Optional record to which the container is converted, if specified,
        #/// the conversion is only carried out if the record is the same concrete
        #/// type of that in the container.
        #/// </param>
        #/// <returns>
        #/// The record to which the container is converted. A new record will be
        #/// created and returned if the optional record parameter is not specified or
        #/// of a different concrete type from that in the container.
        #/// </returns>
        #static Common con2Buf(container _container,
        #                      Common    _rec = null)
        #{
        #    Common    thisRec = null;
        #    TableId   tableId;
        #    DictTable dictTable;
        #    FieldId   fieldId;
        #    int       i;
        #    boolean   convert = false;
        #
        #    if ( prmisDefault(_rec) )
        #    {
        #        tableId   = conPeek(_container,1);
        #        dictTable = new DictTable(tableId);
        #
        #        if (dictTable)
        #        {
        #            thisRec = dictTable.makeRecord();
        #            convert = true;
        #        }
        #    }
        #    else
        #    {
        #        thisRec = _rec;
        #    }
        #
        #    if(Types::Container == typeOf(conPeek(_container, conLen(_container))))
        #    {
        #        // delegate to kernel API
        #        thisRec.con2buf(_container);
        #    }
        #    else
        #    {
        #        // backward compatibility: unpack container packed with previous versions of AX
        #        tableId = conPeek(_container,1);
        #        dictTable = new DictTable(tableId);
        #
        #        if(dictTable)
        #        {
        #            if (convert || tableName2id(_rec.getInstanceRelationType()) == tableId || _rec.TableId == tableId)
        #            {
        #                fieldId = dictTable.fieldNext(0, TableScope::IncludeBaseTables);
        #                i = 2;
        #                while (fieldId)
        #                {
        #                    thisRec.(fieldId) = conPeek(_container,i);
        #                    i++;
        #                    fieldId = dictTable.fieldNext(fieldId, TableScope::IncludeBaseTables);
        #                }
        #            }
        #        }
        #    }
        #
        #    return thisRec;
        #}
        #
      ENDSOURCE
      SOURCE #con2List
        #public static List con2List(container _con)
        #{
        #    List list = null;
        #    int i;
        #    Types types;
        #    boolean typesIsOk = true;
        #
        #    if (conLen(_con))
        #        types = typeOf(conPeek(_con,1)); //Type of first element
        #
        #    for (i=2;i<=conLen(_con);i++)
        #    {
        #        if (typeOf(conPeek(_con,i)) != types)
        #            typesIsOk = false;
        #    }
        #
        #    if (typesIsOk)
        #    {
        #        list = new List(types);
        #
        #        for (i=1;i<=conLen(_con);i++)
        #        {
        #            list.addEnd(conPeek(_con,i));
        #        }
        #    }
        #    return list;
        #}
        #
      ENDSOURCE
      SOURCE #con2Str
        #static str con2Str(container c, str sep = ',')
        #{
        #    int         idx = 0;
        #    int         len = conLen(c);
        #    str         tmp;
        #    str         retStr;
        #
        #    while (idx < len)
        #    {
        #        idx += 1;
        #        if (retStr)
        #            retStr += sep;
        #
        #        tmp = conPeek(c,idx);
        #        retStr += tmp;
        #    }
        #    return retStr;
        #}
      ENDSOURCE
      SOURCE #con2StrUnlimited
        #static str con2StrUnlimited(container c, str 10 sep = ',')
        #{
        #    int         idx = 0;
        #    int         len = conLen(c);
        #    str  100    tmp;
        #    str         retStr;
        #
        #    while (idx < len)
        #    {
        #        idx += 1;
        #        if (retStr)
        #            retStr += sep;
        #
        #        tmp = conPeek(c,idx);
        #        retStr += tmp;
        #    }
        #    return retStr;
        #}
      ENDSOURCE
      SOURCE #configurationkeyId2Name
        #static ConfigurationKeyName configurationkeyId2Name(ConfigurationKeyId _configurationKeyId)
        #{
        #    DictConfigurationKey dictConfigurationKey = new DictConfigurationKey(_configurationKeyId);
        #    if (dictConfigurationKey)
        #        return dictConfigurationKey.name();
        #    return '';
        #}
      ENDSOURCE
      SOURCE #configurationkeyId2pName
        #static str configurationkeyId2pName(ConfigurationKeyId _configurationKeyId)
        #{
        #    DictConfigurationKey dictConfigurationKey = new DictConfigurationKey(_configurationKeyId);
        #    if (dictConfigurationKey)
        #        return dictConfigurationKey.label();
        #    return '';
        #}
      ENDSOURCE
      SOURCE #configurationKeyName2Id
        #static ConfigurationKeyId configurationKeyName2Id(IdentifierName _name)
        #{
        #    Dictionary dict = new Dictionary();
        #    return dict.configurationKeyName2Id(_name);
        #}
      ENDSOURCE
      SOURCE #conReverse
        #/// <summary>
        #///    Reverses the root elements of a container and then adds them into a new container.
        #/// </summary>
        #/// <param name="_originalContainer">
        #///    A container with root elements.
        #/// </param>
        #/// <returns>
        #///    A new container with the root elements in a reversed order.
        #/// </returns>
        #public static client server container conReverse(container _originalContainer)
        #{
        #    container   reversedContainer = conNull();
        #    int         i;
        #
        #    for(i=conLen(_originalContainer); i>0; i--)
        #    {
        #        reversedContainer += [conPeek(_originalContainer, i)];
        #    }
        #
        #    return reversedContainer;
        #}
      ENDSOURCE
      SOURCE #containerFromXMLNode
        #// The node is <container> ... </container>
        #static container containerFromXMLNode(XmlNode n)
        #{
        #    container retval, containerToInsert;
        #    Common recordToInsert;
        #    XmlNamedNodeMap attrs;
        #    XmlNode typeAttr, element, recordNode, containerNode;
        #    int elemNo = 1;
        #
        #    //validate arguments before using them
        #    if (n == null)
        #        return retval;
        #
        #    // Collect all the elements ...
        #    element = n.firstChild();
        #    while (element)
        #    {
        #        attrs = element.attributes();
        #        typeAttr = attrs.getNamedItem('type');
        #
        #        switch (typeAttr.nodeValue())
        #        {
        #            case 'enum'     :  // Fall through.
        #            case 'int'      :
        #                retval = conIns(retval, elemNo, str2int(getXmlNodeValue(element)));
        #                break;
        #
        #            case 'str'      :
        #                retval = conIns(retval, elemNo, getXmlNodeValue(element));
        #                break;
        #
        #            case 'real'     :
        #                retval = conIns(retval, elemNo, str2num(getXmlNodeValue(element)));
        #                break;
        #
        #            case 'date'     :
        #                retval = conIns(retval, elemNo, str2Date(getXmlNodeValue(element), 321));
        #                break;
        #
        #            case 'record'   :
        #                recordNode = element.firstChild();
        #                recordToInsert = Global::recordFromXMLNode(recordNode);
        #                retval = conIns(retval, elemNo, recordToInsert);
        #                break;
        #
        #            case 'container':
        #                containerNode = element.firstChild();
        #                containerToInsert = Global::containerFromXMLNode(containerNode);
        #                retval = conIns(retval, elemNo, containerToInsert);
        #                break;
        #
        #            case 'blob':
        #                containerToInsert = BinData::stringToData(getXmlNodeValue(element));
        #                retval = conIns(retval, elemNo, containerToInsert);
        #                break;
        #        }
        #
        #        element = element.nextSibling();
        #        elemNo += 1;
        #    }
        #
        #    return retval;
        #}
        #
      ENDSOURCE
      SOURCE #contributionRatio
        #/// <summary>
        #/// Calculates the contribution ratio, which is based on the sales price and the purchase price.
        #/// </summary>
        #/// <param name="sale">The sale price. The sale price must be greater than 0.</param>
        #/// <param name="purchase">The purchase price.</param>
        #/// <returns>The contribution ratio.</returns>
        #static real contributionRatio(real sale, real purchase)
        #{
        #    return  dg(sale,purchase);
        #}
      ENDSOURCE
      SOURCE #conUnion
        #/// <summary>
        #///    Creates a container with the union of the elements of two containers.
        #/// </summary>
        #/// <param name="_container1">
        #///    An input container.
        #/// </param>
        #/// <param name="_container2">
        #///    An input container.
        #/// </param>
        #/// <returns>
        #///    A new container with the union of the elements of the input containers.
        #/// </returns>
        #/// <remarks>
        #///    Input containers are assumed to have no repeated elements within themselves.
        #///    If the first container has repeated elements they will be kept repeated in the union.
        #/// </remarks>
        #public static client server container conUnion(container _container1, container _container2)
        #{
        #    container   union = conNull();
        #    int         i;
        #    int         container2length;
        #
        #    union = _container1;
        #
        #    container2length = conLen(_container2);
        #    for(i=1; i<=container2length; i++)
        #    {
        #        if (!conFind(_container1, conPeek(_container2, i)))
        #        {
        #            union += [conPeek(_container2, i)];
        #        }
        #    }
        #
        #    return union;
        #}
      ENDSOURCE
      SOURCE #conView
        #static FormRun conView(container _containerToShow,     // container that will be shown in a tree
        #                       str       _caption = '',        // optional caption on the form with the tree
        #                       boolean   _lookup  = false)
        #{
        #    Object      formRun = classfactory.formRunClass(new Args(formStr(SysConView)));
        #    FormDesign  design;
        #
        #    if (_lookup)
        #        formRun.setLookup(true);
        #
        #    formRun.init();
        #
        #    if (!prmisDefault(_caption))
        #    {
        #        design = formRun.design();
        #        design.caption(_caption);
        #    }
        #
        #    formRun.setContainer(_containerToShow);
        #
        #    if (_lookup)
        #        return formRun;
        #
        #    formRun.run();
        #    formRun.detach();
        #    return null;
        #}
      ENDSOURCE
      SOURCE #createArrayFromXML
        #static Array createArrayFromXML(XmlNode node)
        #{
        #    XmlElement el;
        #    Types type;
        #    Array retval;
        #
        #    if (node && node.nodeType() == XmlNodeType::Element)
        #    {
        #        el = node;
        #        type = xmlGetTypeFromSpelling(el.getAttribute(#ATTR_TYPE));
        #        if (type != Types::void)
        #        {
        #            retval = new Array(type);
        #            loadArrayFromXML(node, retval);
        #        }
        #    }
        #
        #    return retval;
        #}
      ENDSOURCE
      SOURCE #createListFromXML
        #static List createListFromXML(XmlNode node)
        #{
        #    XmlElement el;
        #    Types type;
        #    List retval;
        #
        #    if (node && node.nodeType() == XmlNodeType::Element)
        #    {
        #        el = node;
        #        type = xmlGetTypeFromSpelling(el.getAttribute(#ATTR_TYPE));
        #        if (type != Types::void)
        #        {
        #            retval = new List(type);
        #            loadListFromXML(node, retval);
        #        }
        #    }
        #
        #    return retval;
        #}
      ENDSOURCE
      SOURCE #createMapFromXML
        #static Map createMapFromXML(XmlNode node)
        #{
        #    XmlElement el;
        #    Types keytype;
        #    Types valuetype;
        #    Map retval;
        #
        #    if (node && node.nodeType() == XmlNodeType::Element)
        #    {
        #        el = node;
        #
        #        keytype = xmlGetTypeFromSpelling(el.getAttribute(#ATTR_KEY_TYPE));
        #        valuetype = xmlGetTypeFromSpelling(el.getAttribute(#ATTR_VALUE_TYPE));
        #
        #        if (
        #            (keytype != Types::void) &&
        #            (valuetype != Types::void))
        #        {
        #            retval = new Map(keytype, valuetype);
        #            loadMapFromXML(node, retval);
        #        }
        #    }
        #
        #    return retval;
        #}
      ENDSOURCE
      SOURCE #createSetFromXML
        #static Set createSetFromXML(XmlNode node)
        #{
        #    XmlElement el;
        #    Types type;
        #    Set retval;
        #
        #    if (node && node.nodeType() == XmlNodeType::Element)
        #    {
        #        el = node;
        #        type = xmlGetTypeFromSpelling(el.getAttribute(#ATTR_TYPE));
        #        if (type != Types::void)
        #        {
        #            retval = new Set(type);
        #            loadSetFromXML(node, retval);
        #        }
        #    }
        #
        #    return retval;
        #}
      ENDSOURCE
      SOURCE #createStructFromXML
        #static Struct createStructFromXML(XmlNode node)
        #{
        #    XmlElement el;
        #    Struct retval;
        #
        #    if (node && node.nodeType() == XmlNodeType::Element)
        #    {
        #        el = node;
        #        retval = new Struct(el.getAttribute(#ATTR_TYPE));
        #        loadStructFromXML(node, retval);
        #    }
        #
        #    return retval;
        #}
      ENDSOURCE
      SOURCE #cryptoblob2binary
        #static Binary cryptoblob2binary(CryptoBlob _cryptoBlob)
        #{
        #    Binary b = new Binary(conLen(_cryptoBlob));
        #    int i;
        #
        #    if (_cryptoBlob != conNull())
        #    {
        #        for (i = 0; i < conLen(_cryptoBlob); i++)
        #            b.byte(i,conPeek(_cryptoBlob,i + 1));
        #
        #        return b;
        #    }
        #    else
        #    {
        #        return null;
        #    }
        #}
      ENDSOURCE
      SOURCE #cryptoblob2str
        #static str cryptoblob2str(CryptoBlob _cryptoBlob)
        #{
        #    Binary b;
        #
        #    if (_cryptoBlob != conNull())
        #    {
        #        b = cryptoblob2binary(_cryptoBlob);
        #        return b.wString(0);
        #    }
        #    else
        #        return '';
        #}
      ENDSOURCE
      SOURCE #curExt2dataareaid
        #static DataAreaId curExt2dataareaid(TableId _tableId)
        #{
        #    DictTable   dictTable = new DictTable(_tableId);
        #    Common      common;
        #
        #    if (!dictTable)
        #        return '';
        #
        #    common = dictTable.makeRecord();
        #    return common.DataAreaId;
        #}
      ENDSOURCE
      SOURCE #currentAOLayer
        #//To be used instead of infolog.currentAOLayer() to avoid c/s calls.
        #client server static UtilEntryLevel currentAOLayer()
        #{
        #    SysGlobalCache  cache   = classfactory.globalCache();
        #    UtilEntryLevel  value;
        #
        #    if (cache.isSet(classStr(Global), funcName()))
        #    {
        #        value = cache.get(classStr(Global), funcName());
        #        return value;
        #    }
        #    value = infolog.currentAOLayer();
        #    cache.set(classStr(Global), funcName(), value, false);
        #    return value;
        #}
      ENDSOURCE
      SOURCE #currentParty
        #/// <summary>
        #/// Returns the party associated to the current user.
        #/// </summary>
        #/// <returns>
        #/// The unique ID of the party associated to the current user.
        #/// </returns>
        #public static DirPartyRecId currentParty()
        #{
        #    SysGlobalObjectCache sgoc;
        #    DirPersonUser personUser;
        #    DirPartyRecId currentParty;
        #    UserId currentUserId = curUserId();
        #    container result;
        #
        #    if (classfactory)
        #    {
        #        sgoc = classfactory.globalObjectCache();
        #    }
        #    else
        #    {
        #        // Workaround for SysQueryRangeUtil usage under IL
        #        // the class factory is not initialized in the interpreter
        #        // when called from IL.This is OK as the global cache is a kernel
        #        // singleton
        #        sgoc =  new SysGlobalObjectCache();
        #    }
        #
        #    result = sgoc.find(#CURRENT_PARTY, [currentUserId]);
        #
        #    if(result != conNull())
        #    {
        #        currentParty = conPeek(result, 1);
        #    }
        #    else
        #    {
        #        select firstonly PersonParty from personUser
        #            where personUser.User == currentUserId;
        #
        #        currentParty = personUser.PersonParty;
        #
        #        sgoc.insert(#CURRENT_PARTY, [currentUserId], [currentParty]);
        #    }
        #
        #    return currentParty;
        #}
      ENDSOURCE
      SOURCE #currentSessionLanguageRTL
        #static boolean currentSessionLanguageRTL()
        #{
        #    return isLanguageRTL(infolog.language());
        #}
      ENDSOURCE
      SOURCE #currentUserLanguage
        #static LanguageId currentUserLanguage()
        #{
        #    UserInfo userInfo;
        #
        #    select Language from userInfo
        #        where userInfo.Id == curUserId();
        #
        #    return userInfo.Language;
        #}
      ENDSOURCE
      SOURCE #currentUserLanguageRTL
        #static boolean currentUserLanguageRTL()
        #{
        #    UserInfo userInfo;
        #
        #    select Language from userInfo
        #        where userInfo.Id == curUserId();
        #
        #    return isLanguageRTL(userInfo.Language);
        #}
      ENDSOURCE
      SOURCE #currentWorker
        #public static HcmWorkerRecId currentWorker()
        #{
        #    SysGlobalObjectCache    sgoc;
        #    container               result;
        #    UserId                  currentUserId = curUserId();
        #    utcdatetime             validFrom, validTo;
        #    utcdatetime             now = DateTimeUtil::utcNow();
        #    RecId                   workerId;
        #    HcmWorker               hcmWorker;
        #    DirPersonUser           dirPersonUser;
        #
        #    #DEFINE.Values(workerId, validFrom, validTo)
        #
        #    //Try put pull from cache first
        #    if (classfactory)
        #    {
        #        sgoc = classfactory.globalObjectCache();
        #    }
        #    else
        #    {
        #        // Workaround for SysQueryRangeUtil usage under IL
        #        // the class factory is not initialized in the interpreter
        #        // when called from IL.This is OK as the global cache is a kernel
        #        // singleton
        #        sgoc =  new SysGlobalObjectCache();
        #    }
        #    result = sgoc.find(#CURRENT_WORKER_ID, [currentUserId]);
        #    if(result != conNull())
        #    {
        #        [#Values] = result;
        #        if(validFrom <= now && validTo >= now)
        #        {
        #            return workerId;
        #        }
        #    }
        #
        #    //Calculate current worker value
        #    select firstonly PersonParty, ValidFrom, ValidTo from dirPersonUser
        #        where dirPersonUser.User == currentUserId;
        #
        #    select firstonly RecId from hcmWorker
        #        where hcmWorker.Person == dirPersonUser.PersonParty;
        #
        #    //Cache current worker value
        #    validFrom = dirPersonUser.ValidFrom;
        #    validTo = dirPersonUser.ValidTo;
        #    workerId = hcmWorker.RecId;
        #
        #    sgoc.insert(#CURRENT_WORKER_ID, [currentUserId], [#Values]);
        #
        #    return workerId;
        #}
      ENDSOURCE
      SOURCE #date2JapaneseEra_JP
        #/// <summary>
        #/// convert date to Japanese Era date
        #/// </summary>
        #/// <param name="_date">
        #/// The Gregorian date value
        #/// </param>
        #/// <param name="_strfmt">
        #/// The Japanese Era date format value; optional.
        #/// </param>
        #/// <returns>
        #/// Japanese Era date
        #/// </returns>
        #// <GJP>
        #public static str date2JapaneseEra_JP(date _date, str _strfmt = #DateFormat_ggYMD)
        #{
        #    #define.CultureName('ja-JP')
        #    System.Globalization.CultureInfo        cultureInfo;
        #    System.Globalization.DateTimeFormatInfo myDateTimeInfo;
        #    System.Globalization.JapaneseCalendar   japaneseCal;
        #    System.DateTime                         myDateTimeObj;
        #    str                                     myresult;
        #    InteropPermission                       clrPermission;
        #
        #    try
        #    {
        #        clrPermission = new InteropPermission(InteropKind::ClrInterop);
        #        clrPermission.assert();
        #
        #        // BP deviation documented
        #        cultureInfo = new System.Globalization.CultureInfo(#CultureName, false);
        #
        #        // BP deviation documented
        #        japaneseCal    = new System.Globalization.JapaneseCalendar();
        #        myDateTimeInfo = cultureInfo.get_DateTimeFormat();
        #        myDateTimeInfo.set_Calendar(japaneseCal);
        #
        #        // BP deviation documented
        #        myDateTimeObj = new System.DateTime(year(_date), mthOfYr(_date), dayOfMth(_date));
        #        myresult      = myDateTimeObj.ToString(_strfmt, cultureInfo);
        #
        #        return myresult;
        #    }
        #    catch (Exception::CLRError)
        #    {
        #        return '';
        #    }
        #}
        #// </GJP>
      ENDSOURCE
      SOURCE #date2Julian
        #//  Converts any valid date to a string value that represents it's Julian date.
        #static str date2Julian(date _enteredDate)
        #{
        #    #define.defaultJulian('0000000')
        #
        #    int             numberOfDays;
        #    str 7           julianDate = #defaultJulian;
        #
        #    if (_enteredDate >= dateNull() && _enteredDate <= dateMax())
        #    {
        #        numberOfDays = (date2num(_enteredDate) - date2num(mkDate(1,1,year(_enteredDate))) + 1);
        #        julianDate = strFmt(int2str(year(_enteredDate)) + num2Str0(numberOfDays, 3));
        #    }
        #
        #    return julianDate;
        #}
      ENDSOURCE
      SOURCE #date2Qtr
        #static int  date2Qtr(date transDate)
        #{
        #    return ((mthOfYr(transDate)-1) div 3 + 1);
        #}
      ENDSOURCE
      SOURCE #date2Str_CN
        #/// <summary>
        #///     Convert date type to some formats that Chinese user may use.
        #/// </summary>
        #/// <param name="_date">
        #///     The date to be converted.
        #/// </param>
        #/// <param name="_dateFormat">
        #///     Specify which date format should be converted to.
        #/// </param>
        #/// <returns>
        #///     The converted string.
        #/// </returns>
        #/// <remarks>
        #///     This method is uptaken from older version, and make some changes to fix bugs.
        #/// </remarks>
        #// <GCN>
        #static str date2Str_CN(date _date, DateFormatType_CN _dateFormat)
        #{
        #    #WinAPI
        #    #Num2Char_CN
        #    #define.KernelDLL('KERNEL32')
        #    #define.FunctionCode_ShortDate(0x01)
        #    #define.FunctionCode_LongDate(0x02)
        #    #define.FunctionCode_Country(0x05)
        #    #define.ChinaCountryCode(86)
        #    #define.MaxLen(260)
        #
        #    int getLocaleCountryCode()
        #    {
        #        DLL                 dll;
        #        DLLFunction         dllFunction;
        #        Binary              countryCode;
        #
        #        //BP Deviation Documented
        #        dll = new DLL(#KernelDLL);
        #        dllFunction = new DLLFunction(dll, 'GetLocaleInfoW');
        #        countryCode = new Binary(#MaxLen);
        #        dllFunction.arg(ExtTypes::DWord,ExtTypes::DWord,ExtTypes::Pointer, ExtTypes::DWord);
        #        dllFunction.returns(ExtTypes::DWord);
        #        //BP Deviation Documented
        #        dllFunction.call(#LOCALE_USER_DEFAULT, #FunctionCode_Country, countryCode, #MaxLen);
        #        return str2int(countryCode.wString(0));
        #    }
        #
        #    str getDateFormat(date _d, int _dateFormatFunc)
        #    {
        #        DLL     dll;
        #        DLLFunction dllFunction;
        #        Binary strDate;
        #        Binary systemTimeD;
        #        #WinAPI
        #
        #        //BP Deviation Documented
        #        dll = new DLL(#KernelDLL);
        #        dllFunction = new DLLFunction(dll, 'GetDateFormatW');
        #        strDate = new Binary(#maxLen*2);
        #        systemTimeD = WinAPI::dateTime2SystemTime(_d, 0);
        #        dllFunction.arg(ExtTypes::DWord, ExtTypes::DWord, ExtTypes::Pointer, ExtTypes::Pointer, ExtTypes::Pointer, ExtTypes::DWord);
        #        dllFunction.returns(ExtTypes::DWord);
        #        //BP Deviation Documented
        #        dllFunction.call(#LOCALE_USER_DEFAULT, _dateFormatFunc, systemTimeD, null, strDate, #maxLen*2);
        #        return strDate.wString(0);
        #    }
        #
        #    str baseNum2Chinese(int _num)
        #    {
        #        if (_num<0 || _num>10)
        #        {
        #            return int2str(_num);
        #        }
        #
        #        if (_num==10)
        #        {
        #            return #Lten;
        #        }
        #        else
        #        {
        #            return numeralsToTxt_CN(_num, NoYes::Yes, NoYes::No, 1);
        #        }
        #    }
        #
        #    str year2ChineseStr(int _year)
        #    {
        #        int num = _year;
        #        str ret;
        #
        #        while(num>0)
        #        {
        #            ret = baseNum2Chinese(num mod 10) + ret;
        #            num = num / 10;
        #        }
        #        return ret;
        #    }
        #
        #    str month2ChineseStr(int _month)
        #    {
        #        if (_month>10)
        #        {
        #            return #Lten + baseNum2Chinese(_month mod 10);
        #        }
        #        else
        #        {
        #            return baseNum2Chinese(_month);
        #        }
        #    }
        #
        #    str day2ChineseStr(int _day)
        #    {
        #        str ret;
        #        int multiple = _day / 10;
        #        int remainder = _day mod 10;
        #
        #        if (multiple > 0)
        #        {
        #            if (multiple > 1)
        #            {
        #                ret = baseNum2Chinese(multiple);
        #            }
        #            ret = ret + #Lten;
        #        }
        #        if (remainder!=0)
        #        {
        #            ret = ret + baseNum2Chinese(remainder);
        #        }
        #        return ret;
        #    }
        #
        #    str date2ChineseFormal(date _d)
        #    {
        #        return strFmt("@GLS54924",
        #            year2ChineseStr(year(_d)),
        #            month2ChineseStr(mthOfYr(_d)),
        #            day2ChineseStr(dayOfMth(_d)));
        #    }
        #
        #    switch (_dateFormat)
        #    {
        #        case DateFormatType_CN::ShortDateFormat:
        #            return getDateFormat(_date, #FunctionCode_ShortDate);
        #        case DateFormatType_CN::LongDateFormat:
        #            return getDateFormat(_date, #FunctionCode_LongDate);
        #        case DateFormatType_CN::ChineseDateFormat:
        #            return date2ChineseFormal(_date);
        #        default:
        #            return '';
        #    }
        #    return '';
        #}
        #// </GCN>
      ENDSOURCE
      SOURCE #date2StrUsr
        #public static TempStr date2StrUsr(date transDate , int flags = DateFlags::None)
        #{
        #    return date2str(transDate,-1,-1,-1,-1,-1,-1, flags);
        #}
      ENDSOURCE
      SOURCE #date2StrXpp
        #/*
        #    Returns a date as a string in the x++ code format, also used in formulas in queries:
        #    dd\mm\yyyy
        #*/
        #static str 10 date2StrXpp(date _date)
        #{
        #//    return strReplace(date2str(_date,123,2,4,2,4,4),'/','\\');
        #    return num2Str0(dayOfMth(_date),2)+
        #           '\\'+
        #           num2Str0(mthOfYr(_date),2)+
        #          '\\'+
        #           num2Str0(year(_date),4);
        #}
        #
      ENDSOURCE
      SOURCE #dateEndMth
        #static date dateEndMth(date transDate)
        #{
        #    if (transDate >= dateMax())
        #        return transDate;
        #    return dateStartMth(dateMthFwd(transDate, 1)) - 1;
        #}
      ENDSOURCE
      SOURCE #dateEndQtr
        #static date  dateEndQtr(date transDate)
        #{
        #    if (mthOfYr(transDate) mod 3 == 1)
        #    {
        #        transDate= nextMth(transDate);
        #    }
        #
        #    if (mthOfYr(transDate) mod 3 == 2)
        #    {
        #        transDate= nextMth(transDate);
        #    }
        #
        #    return endmth(transDate);
        #}
      ENDSOURCE
      SOURCE #dateEndWk
        #/// <summary>
        #///    Returns the date of the end of the week. The first day of the week is determined by the
        #///    <c>firstDayOfWeek</c> function, which is locale-aware.
        #/// </summary>
        #/// <param name="transDate">
        #///    The date for which the end of the week date information is desired.
        #/// </param>
        #/// <returns>
        #///    Date of the end of the week.
        #/// </returns>
        #/// <remarks>
        #///    If the week starts on Sunday, the end of the week will be next Saturday. Similarly, if the week
        #///    starts on Monday the end of the week will be next Sunday The logic below can be implied into a
        #///    single if else block, but might be difficult to follow.
        #/// </remarks>
        #static date  dateEndWk(date transDate)
        #{
        #
        #    date dateEndOfWeek;
        #    int firstDay;
        #    int dayOfWeek;
        #    int daysToAdd;
        #
        #    // firsDayOfWeek returns a number 0 to 6, Monday = 0 and Sunday = 6
        #    firstDay = firstDayOfWeek();
        #    // dayofwk returns a number 1 to 7, Monday = 1 and Sunday = 7
        #    dayOfWeek = dayOfWk(transdate);
        #    if (firstDay > 0)
        #    {
        #        if (firstDay > (dayOfWeek - 1))
        #        {
        #            daysToAdd = firstday - dayOfWeek;
        #        }
        #        else
        #        {
        #            daysToAdd = 7 - (dayOfWeek - firstDay) ;
        #        }
        #    }
        #    else
        #    {
        #        daysToAdd = 7 - dayOfWeek;
        #    }
        #
        #    dateEndOfWeek = transDate + daysToAdd;
        #
        #    return dateEndOfWeek;
        #
        #}
      ENDSOURCE
      SOURCE #dateEndYr
        #static date dateEndYr(date transDate)
        #{
        #    if (year (transDate) == year (maxDate()))
        #        return maxDate();
        #    return dateStartYr(nextYr(transDate)) - 1;
        #}
      ENDSOURCE
      SOURCE #dateIntervalDisplay
        #/// <summary>
        #///    Creates a string representation of an interval of dates, formatted for display purposes.
        #/// </summary>
        #/// <param name="_dateFrom">
        #///    The starting date of the interval.
        #/// </param>
        #/// <param name="_dateTo">
        #///    The ending date of the interval.
        #/// </param>
        #/// <returns>
        #///    A string that contains the formatted date interval.
        #/// </returns>
        #/// <remarks>
        #///    The dates are formatted according to the regional settings of the client.
        #/// </remarks>
        #[SysObsoleteAttribute('Use method strFmt() directly which takes care of dateIntervalDisplay for both LTR and RTL languages', true)]
        #public static DateInterval dateIntervalDisplay(date _dateFrom, date _dateTo)
        #{
        #    throw error(Error::wrongUseOfFunction(funcname()));
        #}
      ENDSOURCE
      SOURCE #dateMax
        #static date dateMax()
        #{
        #    return maxDate();
        #}
      ENDSOURCE
      SOURCE #dateMthFwd
        #static date  dateMthFwd(date transDate,
        #                        int  qty)
        #{
        #    int     day     = dayOfMth(transDate);
        #    int     month   = mthOfYr( transDate);
        #    int     yr      = year(    transDate);
        #
        #    month = month + qty;
        #
        #    while (month > 12)
        #    {
        #        yr++;
        #        month = month - 12;
        #    }
        #
        #    while (month <= 0)
        #    {
        #        yr--;
        #        month = month + 12;
        #    }
        #
        #    return mkDate(day,month,yr);
        #}
      ENDSOURCE
      SOURCE #dateNull
        #static date dateNull()
        #{
        #    return 01\01\1900;
        #}
      ENDSOURCE
      SOURCE #dateStartMth
        #static date  dateStartMth(date transDate)
        #{
        #    int daysToSubTract = dayOfMth(transDate) -1;
        #    return transDate - daysToSubTract;
        #}
      ENDSOURCE
      SOURCE #dateStartQtr
        #static date  dateStartQtr(date transDate)
        #{
        #    if (mthOfYr(transDate) mod 3 == 0)
        #    {
        #        transDate= prevMth(transDate);
        #    }
        #
        #    if (mthOfYr(transDate) mod 3 == 2)
        #    {
        #        transDate= prevMth(transDate);
        #    }
        #
        #    return dateStartMth(transDate);
        #}
      ENDSOURCE
      SOURCE #dateStartWk
        #static date  dateStartWk(date transDate)
        #{
        #    int daysToSubtract = dayOfWk(transDate) -1;
        #
        #    return transDate - daysToSubtract;
        #
        #}
      ENDSOURCE
      SOURCE #dateStartYr
        #static date dateStartYr(date transDate)
        #{
        #    int daysToSubtract = dayOfYr(transDate) -1;
        #    return transDate - daysToSubtract;
        #}
      ENDSOURCE
      SOURCE #datetobeginUtcDateTime
        #static utcdatetime datetobeginUtcDateTime(date currDate, Timezone tz)
        #{
        #    return DateTimeUtil::newDateTime(currDate, 0, tz);
        #}
      ENDSOURCE
      SOURCE #datetoendUtcDateTime
        #static utcdatetime datetoendUtcDateTime(date currDate, Timezone tz)
        #{
        #    #timeConstants;
        #    return DateTimeUtil::newDateTime(currDate, #secondsPerDay-1, tz);
        #}
      ENDSOURCE
      SOURCE #deleteTable
        #server static void deleteTable(TableName tableName, boolean concreteTypeOnly = false, boolean skipAosValidation = false)
        #{
        #    Dictionary  dictionary          = new Dictionary();
        #    Connection  con                 = new Connection();
        #    int         tableHandle         = dictionary.tableName2Id(tableName);
        #    Common      anyRecord;
        #    DictTable   dictTable;
        #    Common      common;
        #
        #    if (! dictionary.tableSql(tableHandle))
        #        return;
        #
        #    dictTable = new DictTable(tableHandle);
        #
        #    if (dictTable.isMap() || dictTable.isTmp())
        #        return;
        #
        #    dictTable   = new DictTable(tableHandle);
        #    anyRecord   = dictTable.makeRecord();
        #
        #    common = dictTable.makeRecord();
        #
        #    if(skipAosValidation)
        #    {
        #        //BP Deviation documented
        #        common.skipAosValidation(true);
        #    }
        #
        #    ttsbegin;
        #
        #    common.skipDeleteMethod(true);
        #    common.skipDeleteActions(true);
        #
        #    if (concreteTypeOnly && dictTable.supportInheritance())
        #    {
        #        delete_from common
        #            where common.RelationType == 0;
        #    }
        #    else
        #    {
        #        delete_from common;
        #    }
        #
        #    ttscommit;
        #
        #    if (dictTable.cacheLookup() == RecordCacheLevel::EntireTable)
        #        Dictionary::dataFlush(dictTable.id());
        #}
        #
      ENDSOURCE
      SOURCE #depreciation
        #/// <summary>
        #/// Calculates the depreciation of an asset over a specified period.
        #/// </summary>
        #/// <param name="price">
        #/// The purchase price of the asset.
        #/// </param>
        #/// <param name="scrap">
        #/// The scrap value of the asset.
        #/// </param>
        #/// <param name="life">
        #/// The expected life of the asset (the number of periods).
        #/// </param>
        #/// <param name="period">
        #/// The period for which to calculate depreciation.
        #/// </param>
        #/// <returns>
        #/// The amount of depreciation over the specified period.
        #/// </returns>
        #/// <remarks>
        #/// Unlike the <c>Global.straightLineDepreciation</c> method, this method can use accelerated
        #/// depreciation of the asset. As with the <c>Global.acceleratedDepreciation</c> method, an accelerated
        #/// depreciation enables more depreciation during the early periods in the life of an asset.This method
        #/// is a rename of the <c>syd</c> method.
        #/// </remarks>
        #static real depreciation(real price, real scrap, real life, int period)
        #{
        #    return syd(price, scrap, life, period);
        #}
      ENDSOURCE
      SOURCE #dictionaryFlush
        #static void dictionaryFlush()
        #{
        #    Dictionary dictionary = new Dictionary();
        #
        #    dictionary.enumFlush();
        #    dictionary.typeFlush();
        #    dictionary.tableFlush();
        #    dictionary.classFlush();
        #}
      ENDSOURCE
      SOURCE #dynaKey2Record
        #static Common dynaKey2Record(str keystr,int tableid = 0, boolean selectforUpdate = false, boolean allowCrossCompany = false)
        #{
        #    QueryRun qrun;
        #    QueryBuildDataSource    qB;
        #    Query q;
        #    str 300 fstr;
        #    int i;
        #    int fieldid;
        #    Common record;
        #
        #    // The keystr is encoded in the URL as this:
        #    // [fieldid:strvalue][fieldid2:strvalue]
        #
        #    if (! keystr)
        #        return null;
        #
        #    q = new Query();
        #    if(allowCrossCompany)
        #    {
        #        q.allowCrossCompany(true);
        #    }
        #    qB = q.addDataSource(tableid);
        #    qB.update(selectforUpdate);
        #
        #    while (keystr)
        #    {
        #        i = strFind(keystr,']',1,999);
        #        if (i)
        #        {
        #            fstr = subStr(keystr,2,i-2);
        #            keystr = subStr(keystr,i+1,999);
        #        }
        #
        #        if (! fstr)
        #            return null;
        #
        #        i = strFind(fstr,':',1,999);
        #        fieldid = real2int(str2num(subStr(fstr,1,i-1)));
        #
        #        qB.addRange(fieldid).value(queryValue(subStr(fstr,i+1,999)));
        #    }
        #    qrun = new QueryRun(q);
        #
        #    qrun.next();
        #
        #    record = qrun.get(tableid);
        #
        #    return record;
        #
        #}
      ENDSOURCE
      SOURCE #emptyGuid
        #/// <summary>
        #///    Creates a guid with this value: {0000000-0000-0000-0000-000000000000}.
        #/// </summary>
        #/// <returns>
        #///    A guid with this value: {0000000-0000-0000-0000-000000000000}.
        #/// </returns>
        #static guid emptyGuid()
        #{
        #    return nullValueFromType(Types::Guid);
        #}
      ENDSOURCE
      SOURCE #enableDatasourceFieldObject
        #/// <summary>
        #/// Enable or disable the specified field in the data source.
        #/// </summary>
        #/// <param name="_dataField">
        #/// The form datasource field to enable.
        #/// </param>
        #/// <param name="_enable">
        #/// A Boolean value indicating whether the field should be enabled.
        #/// </param>
        #public static void enableDatasourceFieldObject(FormDataObject _dataField, boolean _enable)
        #{
        #    if (_dataField != null)
        #    {
        #        _dataField.allowEdit(_enable);
        #        _dataField.skip(!_enable);
        #    }
        #}
      ENDSOURCE
      SOURCE #enableDSField
        #/// <summary>
        #/// Enable or disable the specified field in the data source.
        #/// </summary>
        #/// <param name="_datasource">
        #/// The form datasource to enable the fields for.
        #/// </param>
        #/// <param name="_fieldId">
        #/// The ID of the field to enable or disable.
        #/// </param>
        #/// <param name="_enable">
        #/// A Boolean value indicating whether the field should be enabled.
        #/// </param>
        #/// <remarks>
        #/// This is a convenience method to enable or disable and assign the skip property for a field in the
        #/// associated data source. The field id must be valid for the table in referenced
        #/// by this data source.
        #/// When the field is disabled for input then the skip attribute will be enabled.
        #/// </remarks>
        #public static void enableDSField(FormDataSource _datasource, FieldId _fieldId, boolean _enable)
        #{
        #    if (_datasource && _fieldId)
        #    {
        #        enableDatasourceFieldObject(_datasource.object(_fieldId), _enable);
        #    }
        #}
      ENDSOURCE
      SOURCE #endLengthyOperation
        ##obsolete static void endLengthyOperation(boolean endALL = false)
        #{
        #    /*
        #    EndLengthyOperation is called from Infolog.onEventGoingIdle.
        #    This saves the potential client/server calls below.
        #    */
        #    if(!isRunningOnServer())
        #    {
        #        if (! infolog)
        #            return;
        #
        #        if (prmisDefault(endALL))
        #            infolog.endLengthyOperation();
        #        else
        #            infolog.endLengthyOperation(endALL);
        #    }
        #}
      ENDSOURCE
      SOURCE #enum2int
        #static int enum2int(anytype e)
        #{
        #    return e;
        #}
      ENDSOURCE
      SOURCE #enum2Symbol
        #static str enum2Symbol(EnumId _id, int _val)
        #{
        #    DictEnum de = new DictEnum(_id);
        #
        #    return de.value2Symbol(_val);
        #}
      ENDSOURCE
      SOURCE #enum2Value
        #static str enum2Value(anytype E)
        #{
        #    str     test;
        #    Types   t = typeOf(E);
        #    int     len;
        #
        #    if (t != Types::Enum)
        #        throw error(strFmt("@SYS23815",funcName()));
        #
        #    test    = strFmt('%1',E);
        #    len     = strLen(test);
        #    if (strFind(test,',!',1,len) || strScan(test,'..',1,len) || len == 0)
        #        return int2str(E);
        #    return test;
        #}
      ENDSOURCE
      SOURCE #enumId2Name
        #static IdentifierName enumId2Name(int id)
        #{
        #    DictEnum dictEnum = new DictEnum(id);
        #    if (dictEnum)
        #        return dictEnum.name();
        #    return '';
        #}
      ENDSOURCE
      SOURCE #enumId2pname
        #/// <summary>
        #/// Returns the label of the enumeration.
        #/// </summary>
        #/// <param name="_id">
        #/// Enumeration Id
        #/// </param>
        #/// <returns>
        #/// The label of the enumeration
        #/// </returns>
        #static IdentifierName enumId2pname(int _id)
        #{
        #    DictEnum dictEnum = new DictEnum(_id);
        #
        #    if (dictEnum)
        #    {
        #        return dictEnum.label();
        #    }
        #
        #    return '';
        #}
      ENDSOURCE
      SOURCE #enumInit
        #/*
        #    Returns the first enum entry which is enabled. If non is enabled 0 is returned.
        #*/
        #static anytype enumInit(EnumId id)
        #{
        #    DictEnum dictEnum = new DictEnum(id);
        #    int      i;
        #
        #    if (dictEnum)
        #    {
        #        for (i=0; i<dictEnum.values(); i++)
        #        {
        #            if (isConfigurationkeyEnabled(dictEnum.value2ConfigurationKey(i)))
        #            {
        #                return i;
        #            }
        #        }
        #    }
        #    return 0;
        #}
      ENDSOURCE
      SOURCE #enumName2Id
        #static int enumName2Id(IdentifierName enumname)
        #{
        #    Dictionary dict = new Dictionary();
        #    return dict.enumName2Id(enumname);
        #}
        #
      ENDSOURCE
      SOURCE #error
        #client server static Exception error(SysInfoLogStr txt, URL helpUrl = '', SysInfoAction _sysInfoAction = null)
        #{
        #    return infolog.add(Exception::Error, getPrefix()+txt, helpUrl, _sysInfoAction, false);
        #}
      ENDSOURCE
      SOURCE #exceptionTextFallThrough
        #/*
        #    Call this method to acknowledge the text in the exception should fallthrough
        #    and eventually be caught by the infolog.
        #
        #    Example:
        #
        #    try
        #    {
        #
        #    }
        #    catch
        #    {
        #        ExceptionTextFallThrough();
        #    }
        #
        #*/
        #public client server static void exceptionTextFallThrough()
        #{
        #;
        #}
      ENDSOURCE
      SOURCE #existLayer
        #static client server boolean existLayer(UtilEntryLevel _layer, boolean _old = false)
        #{
        #    UtilFile utilFile = new UtilFile(_old ? 'old' : 'aod');
        #    str      layers   = utilFile.layers();
        #
        #    return strScan(layers, enum2str(_layer), 1, strLen(layers)) != 0;
        #}
      ENDSOURCE
      SOURCE #extendedTypeId2DisplayName
        #/*
        #    Returns the display type name of a given type
        #*/
        #static str extendedTypeId2DisplayName(Types _type, int _typeId)
        #{
        #    switch (_type)
        #    {
        #        case Types::String:
        #        case Types::RString:
        #        case Types::VarString:
        #            return 'str';
        #        case Types::Container:
        #            return 'container';
        #        case Types::Class:
        #            return classId2Name(_typeId) ? classId2Name(_typeId) : classStr(Object);
        #        case Types::UserType:
        #            return extendedTypeId2name(_typeId);
        #        case Types::Record:
        #            return tableId2name(_typeId);
        #        case Types::Real:
        #            return 'real';
        #        case Types::Date:
        #            return 'date';
        #        case Types::Time:
        #            return 'time';
        #        case Types::UtcDateTime:
        #            return 'utcdatetime';
        #        case Types::AnyType:
        #            return 'anytype';
        #        case Types::void:
        #            return 'void';
        #        case Types::Integer:
        #            return 'int';
        #        case Types::Int64:
        #            return 'int64';
        #        case Types::Enum:
        #            return enumId2Name(_typeId);
        #        case Types::Guid:
        #            return 'guid';
        #    }
        #    return '';
        #}
      ENDSOURCE
      SOURCE #extendedTypeId2name
        #/*
        #    Returns the name of an extended type
        #*/
        #static IdentifierName extendedTypeId2name(ExtendedTypeId id)
        #{
        #    DictType dictType = new DictType(id);
        #
        #    if (dictType)
        #        return dictType.name();
        #
        #    return '';
        #}
      ENDSOURCE
      SOURCE #extendedTypeId2pname
        #/*
        #    Returns the label of an extended type
        #*/
        #static IdentifierName extendedTypeId2pname(ExtendedTypeId id)
        #{
        #    DictType dictType = new DictType(id);
        #
        #    if (dictType)
        #        return dictType.label();
        #
        #    return '';
        #}
      ENDSOURCE
      SOURCE #extendedTypeId2Type
        #static Types extendedTypeId2Type(ExtendedTypeId _id)
        #{
        #    DictType d = new DictType(_id);
        #
        #    //validate arguments before using them
        #    if (d == null)
        #        return Types::AnyType;
        #
        #    return d.baseType();
        #}
      ENDSOURCE
      SOURCE #extendedTypeName2Id
        #/// <summary>
        #///    Converts an extended data type name to its ID.
        #/// </summary>
        #/// <param name="_typename">
        #///    The name of the extended data type.
        #/// </param>
        #/// <returns>
        #///    The ID of the extended data type.
        #/// </returns>
        #static public ExtendedTypeId extendedTypeName2Id(ExtendedDataTypeName  _typename)
        #{
        #    Dictionary dict = new Dictionary();
        #    return dict.typeName2Id(_typename);
        #}
        #
      ENDSOURCE
      SOURCE #factorial
        #static int factorial(int _n)
        #{
        #    if (_n > 1)
        #        return _n * factorial(_n - 1);
        #    else
        #        return 1;
        #}
      ENDSOURCE
      SOURCE #fieldExt2Id
        #/*
        #    Returns the fieldId part of an extended FieldId
        #    (an extended FieldId is a fieldId including the array index)
        #*/
        #static FieldId fieldExt2Id(FieldId fieldExtId)
        #{
        #    return (fieldExtId & 0xffff);
        #}
      ENDSOURCE
      SOURCE #fieldExt2Idx
        #/*
        #    Returns the Array index part of an extended FieldId
        #    (an extended FieldId is a fieldId including the array index)
        #*/
        #static int fieldExt2Idx(FieldId fieldExtId)
        #{
        #    return (fieldExtId >> 16);
        #}
      ENDSOURCE
      SOURCE #fieldId2Ext
        #/*
        #    Returns an extended FieldId, based on the fieldId and the Array index
        #    (an extended FieldId is a fieldId including the array index)
        #*/
        #static FieldId fieldId2Ext(FieldId  fieldId,
        #                           ArrayIdx arrayIndex
        #                           )
        #{
        #    return ((arrayIndex << 16) | fieldId);
        #}
      ENDSOURCE
      SOURCE #fieldId2Help
        #/// <summary>
        #/// Returns a help text for the field, specified by table Id and field Id.
        #/// </summary>
        #/// <param name="_tableId">
        #/// Table Id.
        #/// </param>
        #/// <param name="_fieldId">
        #/// Field Id.
        #/// </param>
        #/// <param name="_arrayEntry">
        #/// Field array index.
        #/// </param>
        #/// <returns>
        #/// Help text for the field.
        #/// </returns>
        #static public str fieldId2Help(
        #    TableId _tableId,
        #    FieldId _fieldId,
        #    int     _arrayEntry = 1)
        #{
        #    DictField dictField = new DictField(_tableId, _fieldId);
        #
        #    if (dictField)
        #        return dictField.help(_arrayEntry);
        #
        #    return '';
        #}
      ENDSOURCE
      SOURCE #fieldLabelValue
        #static str fieldLabelValue(TableId t_TableId, FieldId f_FieldId, anytype _value)
        #{
        #    DictField dictField = new DictField(t_TableId, f_FieldId);
        #
        #    //validate arguments before using them
        #    if (dictField == null)
        #        return "";
        #    else
        #        return strFmt('%1: %2',dictField.label(), _value);
        #}
      ENDSOURCE
      SOURCE #fileNameNext
        #static client server Filename fileNameNext(Filename _filename)
        #{
        #    #File
        #    int             i;
        #    Filename        filename;
        #    FilenameType    filenameType;
        #    FilePath        filePath;
        #    boolean         fileExists;
        #    boolean         runningOnServer = isRunningOnServer() || xSession::isCLRSession();
        #
        #    // helper method to check if code is running on server/client and makes the appropriate WinAPI call.
        #    boolean fileExists()
        #    {
        #        if(runningOnServer)
        #        {
        #            new FileIOPermission(_filename, #io_read).assert();
        #            fileExists = WinAPIServer::fileExists(_filename);
        #            CodeAccessPermission::revertAssert();
        #            return fileExists;
        #        }
        #        else
        #        {
        #            return WinAPI::fileExists(_filename);
        #        }
        #    }
        #
        #    [filePath, filename, filenameType] = fileNameSplit(_filename);
        #
        #    while (fileExists())
        #    {
        #        i++;
        #        _filename =  filePath + filename + ' (' + int2str(i) + ')' + filenameType;
        #    }
        #
        #    return _filename;
        #}
        #
      ENDSOURCE
      SOURCE #fileNameSplit
        #static client server container fileNameSplit(Filename _filename)
        #{
        #    #define.foreslash('/')
        #    #define.colon(':')
        #    #define.dot('.')
        #    #file
        #
        #    int         foundPath;
        #    int         foundType;
        #    Filename    filepath;
        #    Filename    fileExt;
        #
        #    if (_filename)
        #    {
        #        foundPath  = strFind(_filename, #FilePathDelimiter, strLen(_filename), -strLen(_filename));
        #        if (!foundPath)
        #        {
        #            foundPath  = strFind(_filename, #foreslash, strLen(_filename), -strLen(_filename));
        #
        #            if (!foundPath)
        #            {
        #                foundPath  = strFind(_filename, #colon, strLen(_filename), -strLen(_filename));
        #            }
        #        }
        #        if (foundPath)
        #        {
        #            filepath  = subStr(_filename, foundPath, -foundPath);
        #            _filename = strDel(_filename, foundPath, -foundPath);
        #        }
        #
        #        foundType = strFind(_filename, #dot, strLen(_filename), -strLen(_filename));
        #        if (foundType)
        #        {
        #            fileExt   = subStr(_filename, foundType, strLen(_filename)-foundType+1);
        #            _filename = strDel(_filename, foundType, strLen(_filename)-foundType+1);
        #        }
        #    }
        #    return [filepath, _filename, fileExt];
        #}
      ENDSOURCE
      SOURCE #fileNameTrim
        #static client server Filename fileNameTrim(Filename _filename)
        #{
        #    Filename    path;
        #    Filename    name;
        #    Filename    extention;
        #
        #    [path, name, extention] = fileNameSplit(_filename);
        #
        #    if (!name)
        #    {
        #        return '';
        #    }
        #
        #    return path + name + extention;
        #}
      ENDSOURCE
      SOURCE #findOrCreateRange_W
        #static public QueryBuildRange findOrCreateRange_W(QueryBuildDataSource _dataSource, FieldId _fieldId, Range _value = '')
        #{
        #    QueryBuildRange ret = SysQuery::findOrCreateRange(_dataSource, _fieldId);
        #
        #    if (! prmisDefault(_value))
        #    {
        #        ret.value(_value);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #findProperty
        #/* MAN
        #    returns the value of the property in the supplied property set.
        #    If the property does not exist an empty string is returned.
        #*/
        #static str findProperty(str _properties, str _property)
        #{
        #    int propertyPos = findPropertyPos(_properties,_property);
        #    int j;
        #    int k;
        #    str propertyValue;
        #
        #    if (propertyPos)
        #    {
        #        j = strScan(_properties, '#', propertyPos, strLen(_properties)-propertyPos)+1;
        #        k = strScan(_properties, '\n', j, strLen(_properties)-j);
        #        propertyValue = subStr(_properties,j,k-j);
        #    }
        #    return propertyValue;
        #}
      ENDSOURCE
      SOURCE #findPropertyPos
        #/* MAN
        #    returns the position (in characters) of the property identifier in the supplied property set.
        #    If the property does not exist, zero is returned.
        #
        #    example of a property sheet:
        #
        #    PROPERTIES
        #      Name                #CustPaymManTrans
        #      Title               #
        #      Form                #SysQueryForm
        #      UserUpdate          #Yes
        #      Version             #41
        #      Interactive         #Yes
        #      AllowCheck          #No
        #    ENDPROPERTIES
        #
        #      DataSource          #
        #      DataField           #
        #      ExtendedDataType
        #        ARRAY
        #          #MarkUpAllocateAfterType
        #          #
        #        ENDARRAY
        #      ArrayIndex          #0
        #      DataMethod          #
        #      Border              #Auto
        #
        #*/
        #static int findPropertyPos(str _properties, str _property)
        #{
        #    str propertyPattern = ' '+_property+' ';
        #    int propertyPos = strScan(_properties, propertyPattern, 1, strLen(_properties));
        #
        #    // validate that it is a position of a property identifier
        #    if (propertyPos &&
        #        (match(propertyPattern+' *\\#',subStr(_properties,propertyPos,strLen(_properties))) ||
        #         match(propertyPattern+': *ARRAY: +\\#',subStr(_properties,propertyPos,strLen(_properties)))) ) // find the first entry in an arry property
        #    {
        #        propertyPos++;  // to compensate for the leading space in propertyPattern
        #        return propertyPos;
        #    }
        #
        #    return 0;
        #}
      ENDSOURCE
      SOURCE #firstDayOfWeek
        #static int firstDayOfWeek()
        #{
        #    System.Globalization.DateTimeFormatInfo fi;
        #    int dow;
        #
        #    SysGlobalCache  cache   = classfactory.globalCache();
        #    int             clientFirstDayOfWeek;
        #
        #    if (cache.isSet(classStr(Global), funcName()))
        #    {
        #        clientFirstDayOfWeek = cache.get(classStr(Global), funcName());
        #    }
        #    else
        #    {
        #        fi = new System.Globalization.DateTimeFormatInfo();
        #        dow = fi.get_FirstDayOfWeek();
        #
        #        // The .NET API returns 0 for sunday, but we expect sunday to
        #        // be represented as 6, (monday is 0).
        #        clientFirstDayOfWeek = (dow + 6) mod 7;
        #
        #        cache.set(classStr(Global), funcName(),clientFirstDayOfWeek);
        #    }
        #
        #    return clientFirstDayOfWeek;
        #}
      ENDSOURCE
      SOURCE #firstLine
        #static FirstLine firstLine(str txt)
        #{
        #    int i = strFind(txt,'\n',1,strLen(txt));
        #
        #    return i ? subStr(txt,1,i-1) : txt;
        #}
      ENDSOURCE
      SOURCE #firstWeekOfYear
        #static int firstWeekOfYear()
        #{
        #    #WinAPI
        #    SysGlobalCache  cache   = classfactory.globalCache();
        #    int             clientFirstWeekOfYear;
        #    anytype         calendarWeekRuleValue;
        #    str             language;
        #    System.Globalization.CultureInfo        userCulture;
        #    System.Globalization.CalendarWeekRule   calendarWeekRule;
        #    System.Globalization.DateTimeFormatInfo userDateTimeFormat;
        #
        #    if (cache.isSet(classStr(Global), funcName()))
        #    {
        #        clientFirstWeekOfYear = cache.get(classStr(Global), funcName());
        #    }
        #    else
        #    {
        #        language = currentUserLanguage();
        #        userCulture = new System.Globalization.CultureInfo(language);
        #        userDateTimeFormat = userCulture.get_DateTimeFormat();
        #        calendarWeekRule    = userDateTimeFormat.get_CalendarWeekRule();
        #        calendarWeekRuleValue = CLRInterop::getAnyTypeForObject(calendarWeekRule);
        #
        #        switch(calendarWeekRuleValue)
        #        {
        #            case CLRInterop::getAnyTypeForObject(System.Globalization.CalendarWeekRule::FirstDay) :
        #                clientFirstWeekOfYear = 0;
        #                break;
        #            case CLRInterop::getAnyTypeForObject(System.Globalization.CalendarWeekRule::FirstFullWeek) :
        #                clientFirstWeekOfYear = 1;
        #                break;
        #            case CLRInterop::getAnyTypeForObject(System.Globalization.CalendarWeekRule::FirstFourDayWeek) :
        #                clientFirstWeekOfYear = 2;
        #                break;
        #        }
        #
        #        cache.set(classStr(Global), funcName(),clientFirstWeekOfYear);
        #    }
        #
        #    return clientFirstWeekOfYear;
        #}
      ENDSOURCE
      SOURCE #flushCurrentParty
        #/// <summary>
        #/// Flushes the current associated user party from the global cache.
        #/// </summary>
        #public static void flushCurrentParty()
        #{
        #    classfactory.globalObjectCache().clear(#CURRENT_PARTY);
        #}
      ENDSOURCE
      SOURCE #flushCurrentWorker
        #public static void flushCurrentWorker()
        #{
        #    classfactory.globalObjectCache().clear(#CURRENT_WORKER_ID);
        #}
      ENDSOURCE
      SOURCE #flushVirtualCompanyCache
        #/// <summary>
        #/// Flushes the virtual company values from the global cache.
        #/// </summary>
        #static server void flushVirtualCompanyCache()
        #{
        #    classfactory.globalObjectCache().clear(#VIRTUALCOMPANYLIST);
        #    classfactory.globalObjectCache().clear(#ISVIRTUALCOMPANY);
        #}
      ENDSOURCE
      SOURCE #formCaption
        #client static str formCaption(FormName formName)
        #{
        #    Form form = new Form(formName);
        #    if (form && form.design())
        #    {
        #        return form.design().caption();
        #    }
        #    return '';
        #}
      ENDSOURCE
      SOURCE #formControlValue
        #static anytype formControlValue(
        #    Object      ctrl,
        #    Types       baseType
        #    )
        #{
        #    //validate arguments before using them
        #    if (ctrl == null)
        #        return null;
        #    switch (baseType)
        #    {
        #        case Types::String:
        #            if (classIdGet(ctrl) == classNum(FormStringControl))
        #                return ctrl.valueStr();
        #            else
        #                return ctrl.text();
        #        case Types::VarString:
        #            return ctrl.text();
        #        case Types::Integer:
        #            return ctrl.value();
        #        case Types::Int64:
        #            return ctrl.value();
        #        case Types::Real:
        #            return ctrl.realValue();
        #        case Types::Date:
        #            return ctrl.dateValue();
        #        case Types::UtcDateTime:
        #            return ctrl.dateTimeValue();
        #        case Types::Time:
        #            return ctrl.value();
        #        case Types::Enum:
        #            if (classIdGet(ctrl) == classNum(FormCheckBoxControl)       ||
        #                classIdGet(ctrl) == classNum(FormBuildCheckBoxControl)
        #               )
        #                return ctrl.value();
        #            return ctrl.selection();
        #        case Types::Guid:
        #            return ctrl.value();
        #    }
        #    return null;
        #}
        #
      ENDSOURCE
      SOURCE #formDataSourceArrayFieldExtObjects
        #static Map formDataSourceArrayFieldExtObjects(FormDataSource    _formDataSource,
        #                                              FieldId           _fieldId)
        #{
        #    Map         mapFieldObjects;
        #    DictField   dictField;
        #    FieldId     extFieldId;
        #    Counter     x;
        #
        #    //validate arguments before using them
        #    if (_formDataSource == null)
        #        return null;
        #    mapFieldObjects = new Map (Types::Integer, Types::Class);
        #
        #    dictField = new DictField(_formDataSource.table(), _fieldId);
        #
        #    for (x = 1; x <= dictField.arraySize(); x++)
        #    {
        #        extFieldId = fieldId2Ext(_fieldId, x);
        #
        #        mapFieldObjects.insert(extFieldId, _formDataSource.object(extFieldId));
        #    }
        #
        #    return mapFieldObjects;
        #}
      ENDSOURCE
      SOURCE #formDataSourceHasMethod
        #client static boolean formDataSourceHasMethod(FormDataSource  _formDataSource,
        #                                              IdentifierName  _methodName)
        #{
        #    //validate arguments before using them
        #    if (_formDataSource == null)
        #        return false;
        #    return Form::formObjectSetHasMethod(_formDataSource, _methodName);
        #}
      ENDSOURCE
      SOURCE #formDataSourceRefresh
        #client static void formDataSourceRefresh(Common _common)
        #{
        #    FormObjectSet formObjectSet;
        #    if (_common.dataSource())
        #    {
        #        formObjectSet = _common.dataSource();
        #        formObjectSet.refresh();
        #    }
        #}
      ENDSOURCE
      SOURCE #formGetFromControl
        #/// <summary>
        #/// Get the FormRun object that owns a specific control.
        #/// </summary>
        #/// <param name="_control" type="FormControl">
        #/// The form control to get the owner of
        #/// </param>
        #/// <returns type="FormRun">
        #/// FormRun object instance that owns the given control, otherwise null.
        #/// </returns>
        #public static FormRun formGetFromControl(FormControl _control)
        #{
        #    Object      c;
        #    FormRun     fr;
        #
        #    c = _control;
        #    while (c != null && c.owner() != c)
        #    {
        #        c = c.owner();
        #    }
        #
        #    fr = c;
        #    return fr;
        #}
      ENDSOURCE
      SOURCE #formGetParentDatasource
        #/// <summary>
        #///    Retrieves an instance of the <c>FormDataSource</c> object which is a parent data source to the
        #///    specified <c>formDataSource</c> object.
        #/// </summary>
        #/// <param name="_formDataSource">
        #///    An instance of the <c>FormDataSource</c> object for which a parent is retrieved.
        #/// </param>
        #/// <param name="_includeSearchInQueries">
        #///    A Boolean value that indicates whether the search for a parent is performed also in the underlying
        #///    query of the specified instance of the <c>formDataSource</c> object.
        #/// </param>
        #/// <returns>
        #///    A <c>FormDataSource</c> object that is a parent data source if one can be found; otherwise, null.
        #/// </returns>
        #/// <remarks>
        #///    The default value for the <paramref name="_includeSearchInQueries" /> parameter is false. If the
        #///    specified <c>formDataSource</c> object is from a list page, it will typically be set to true.
        #/// </remarks>
        #client static FormDataSource formGetParentDatasource(
        #    FormDataSource  _formDataSource,
        #    boolean         _includeSearchInQueries = false)
        #{
        #    Counter                 i;
        #    QueryBuildDataSource    qbdsChild;
        #    QueryBuildDataSource    qbdsParent;
        #    Query                   query;
        #    FormRun                 formRun;
        #    FormDataSource          formDataSourceParent;
        #    int                     formRunNrOfDataSources;
        #
        #    boolean isParentLinkedToChild(FormDataSource _formDataSourceParent, QueryBuildDataSource _qbdsChild)
        #    {
        #        Query                   queryParent;
        #        QueryBuildDataSource    qbsdParentLocal;
        #        int                     childCounter;
        #
        #        //we got a datasource that could be the parent, but we examine that the parent also has the correct child
        #        queryParent = _formDataSourceParent.query();
        #
        #        if (!queryParent)
        #        {
        #            return false;
        #        }
        #
        #        if (!queryParent.childDataSourceCount())
        #        {
        #            return false;
        #        }
        #
        #        qbsdParentLocal = queryParent.childDataSourceNo(1);//for modeled queries the parent is first child
        #
        #        if (!qbsdParentLocal)
        #        {
        #            return false;
        #        }
        #
        #        for (childCounter = 1; childCounter <= qbsdParentLocal.childDataSourceCount();childCounter++)
        #        {
        #            if (qbsdParentLocal.childDataSourceNo(childCounter).id() == _qbdsChild.id())
        #            {
        #                return true;
        #            }
        #        }
        #
        #        return false;
        #    }
        #
        #
        #    if (!_formDataSource)
        #    {
        #        return null;
        #    }
        #
        #    if (!_includeSearchInQueries && !_formDataSource.joinSource())
        #    {
        #        return null;
        #    }
        #
        #    formRun                 = _formDataSource.formRun();
        #    formRunNrOfDataSources  = formRun.dataSourceCount();
        #
        #    for (i=1; i<= formRunNrOfDataSources; i++)
        #    {
        #        if (formRun.dataSource(i).id() == _formDataSource.joinSource())
        #        {
        #            return formRun.dataSource(i);
        #        }
        #    }
        #
        #    if (!_includeSearchInQueries || _formDataSource.joinSource())
        #    {
        #        return null;
        #    }
        #
        #    //For modeled queries used in list pages the method joinSource() returns 0 so we need to examine the underlying queries to find a parent formdatasource
        #    query = _formDataSource.query();
        #
        #    if (!query)
        #    {
        #        return null;
        #    }
        #
        #    qbdsChild = query.dataSourceTable(_formDataSource.table());
        #
        #    if (!qbdsChild || !qbdsChild.linkCount())
        #    {
        #        return null;
        #    }
        #
        #    qbdsParent = qbdsChild.parentDataSource();//queryBuildDataSource must be linked in order to call parentDataSource()
        #
        #    if (!qbdsParent)
        #    {
        #        return null;
        #    }
        #
        #    //try and find a matching parent
        #    for (i=1; i<=formRunNrOfDataSources; i++)
        #    {
        #        formDataSourceParent = formRun.dataSource(i);
        #        //examine the datasource to see if it is really linked to the child
        #        if (formDataSourceParent.table() == qbdsParent.table() && isParentLinkedToChild(formDataSourceParent,qbdsChild))
        #        {
        #            return formDataSourceParent;
        #        }
        #    }
        #
        #    return null;
        #}
      ENDSOURCE
      SOURCE #formHasMethod
        #client static boolean formHasMethod(
        #    FormRun        fr,
        #    IdentifierName methodName
        #    )
        #{
        #    //validate arguments before using them
        #    if (fr == null)
        #        return false;
        #    return SysFormRun::hasMethod(fr,methodName);
        #}
      ENDSOURCE
      SOURCE #formJoinedRecord
        #/// <summary>
        #/// Finds the table buffer of the specified type that is (maybe indirectly) joined to the specified table buffer.
        #/// </summary>
        #/// <param name="_record">
        #/// The base table buffer.
        #/// </param>
        #/// <param name="_joinedFormDataSource">
        #/// The <c>FormDataSource</c> class to find.
        #/// </param>
        #/// <returns>
        #/// The found record or Common if nothing was found.
        #/// </returns>
        #/// <exception cref="Exception::Error">
        #/// An exception is thrown if the <paramref name="_record"/> parameter is not referencing a <c>FormDataSource</c> object.
        #/// An exception is thrown if the <paramref name="_joinedFormDataSource"/> is null.
        #/// </exception>
        #public static Common formJoinedRecord(Common _record, FormDataSource _joinedFormDataSource)
        #{
        #    Common          current = _record;
        #    FormDataSource  currentFormDataSource = current.dataSource();
        #
        #    if (!currentFormDataSource
        #        || !_joinedFormDataSource)
        #    {
        #        throw error(strFmt("@SYS22828",funcName()));
        #    }
        #
        #    while (current.TableId != tableNum(Common)
        #        && currentFormDataSource.name() != _joinedFormDataSource.name())
        #    {
        #        current = current.joinChild();
        #        currentFormDataSource = current.dataSource();
        #    }
        #
        #    if (current.TableId == tableNum(Common)
        #        || currentFormDataSource.name() != _joinedFormDataSource.name())
        #    {
        #        current = _record;
        #        currentFormDataSource = current.dataSource();
        #
        #        while (current.TableId != tableNum(Common)
        #            && currentFormDataSource.name() != _joinedFormDataSource.name())
        #        {
        #            current = current.joinParent();
        #            currentFormDataSource = current.dataSource();
        #        }
        #    }
        #
        #    return current;
        #}
      ENDSOURCE
      SOURCE #formName2Pname
        #client server static str formName2Pname(FormName formName)
        #{
        #    MenuFunction mf;
        #    try
        #    {
        #        mf = new MenuFunction(formName, MenuItemType::Display);
        #    }
        #    catch(Exception::Internal)
        #    {
        #        mf = null;
        #    }
        #
        #    if (mf)
        #    {
        #        if (mf.label())
        #            return mf.label();
        #    }
        #
        #    return formCaption(formName);
        #}
      ENDSOURCE
      SOURCE #futureValue
        #/// <summary>
        #/// Calculates the future value of an investment
        #/// </summary>
        #/// <param name="amount">
        #/// The amount paid in during each period.
        #/// </param>
        #/// <param name="interest">
        #/// The interest rate.
        #/// </param>
        #/// <param name="life">
        #/// The number of investment periods.
        #/// </param>
        #/// <returns>
        #/// The future value of the investment.
        #/// </returns>
        #/// <remarks>
        #/// This method is a rename of the <c>fV</c> method.
        #/// </remarks>
        #static real futureValue(real amount, real interest, real life)
        #{
        #    return fv(amount, interest, life);
        #}
      ENDSOURCE
      SOURCE #getCompany
        #/// <summary>
        #/// Returns the company.
        #/// </summary>
        #/// <param name="tableID">
        #/// A ID for a table.
        #/// </param>
        #/// <param name="_company">
        #/// An ID of the company.
        #/// </param>
        #/// <returns>
        #/// A Company.
        #/// </returns>
        #/// <remarks>
        #/// This method has exposes the <c>xCompany::DataArea</c> method on the client tier for improved
        #/// performance.
        #/// </remarks>
        #public static SelectableDataArea getCompany(int tableID, SelectableDataArea _company = "")
        #{
        #    if (_company != "")
        #    {
        #        return xGlobal::company(tableId, _company);
        #    }
        #    return xGlobal::company(tableId);
        #}
      ENDSOURCE
      SOURCE #getFirstSelection
        #static Common getFirstSelection(FormDataSource _formDataSource)
        #{
        #    Common common = _formDataSource.getFirst(true);
        #    if (!common)
        #        common = _formDataSource.cursor();
        #    return common;
        #}
      ENDSOURCE
      SOURCE #getJoinChildFormDataSource
        #/// <summary>
        #///    Retrieves the joined child form data source for the specified form data source.
        #/// </summary>
        #/// <param name="_dataSource">
        #///    A form data source.
        #/// </param>
        #/// <param name="_childTableId">
        #///    An ID of the table of the joined form data source.
        #/// </param>
        #/// <param name="_occurence">
        #///    An occurrence of the table form data source.
        #/// </param>
        #/// <returns>
        #///    The joined child form data source.
        #/// </returns>
        #public static FormDataSource getJoinChildFormDataSource(FormDataSource _dataSource, TableId _childTableId, int _occurence = 1)
        #{
        #    int             currentOccurence = 0;
        #    FormDataSource  formDataSource;
        #    FormRun         formRun;
        #    int             dataSourceCount;
        #    int             i;
        #
        #    formRun             = _dataSource.formRun();
        #    dataSourceCount     = formRun.dataSourceCount();
        #
        #    for (i = 1; i <= dataSourceCount; i++)
        #    {
        #        formDataSource  = formRun.dataSource(i);
        #
        #        if     (formDataSource.joinSource() == _dataSource.id()
        #            &&  formDataSource.table()      == _childTableId)
        #        {
        #            currentOccurence++;
        #            if (currentOccurence == _occurence)
        #            {
        #                return formDataSource;
        #            }
        #        }
        #    }
        #
        #    if (currentOccurence == 0)
        #    {   // for list page forms the data sources aren't marked as inner joins in meta data, so there is no joinSource
        #        for (i = 1; i <= dataSourceCount; i++)
        #        {
        #            formDataSource  = formRun.dataSource(i);
        #
        #            if (formDataSource.table()      == _childTableId
        #             && formDataSource.joinSource() == 0)
        #            {
        #                currentOccurence++;
        #                if (currentOccurence == _occurence)
        #                {
        #                    return formDataSource;
        #                }
        #            }
        #        }
        #    }
        #
        #    return null;
        #}
      ENDSOURCE
      SOURCE #getPrimaryKey
        #static str getPrimaryKey(Common common)
        #{
        #    DictTable dictTable = new DictTable(common.TableId);
        #    DictIndex dictIndex = new DictIndex(dictTable.id(), dictTable.indexUnique());
        #    FieldId fieldId;
        #    SysDictField sysDictField;
        #    str key,s;
        #    int i;
        #
        #    for (i=1;i <= dictIndex.numberOfFields(); i++)
        #    {
        #        fieldId = dictIndex.field(i);
        #        sysDictField = new SysDictField(dictTable.id(), fieldId);
        #        switch (sysDictField.baseType())
        #        {
        #            case Types::Date:
        #                s = date2str(common.(fieldId),-1,-1,-1,-1,-1,-1, DateFlags::None);
        #                break;
        #            case Types::String:
        #            case Types::RString:
        #            case Types::VarString:
        #                s =common.(fieldId);
        #                break;
        #            case Types::UserType:
        #                if (isTypeTime(sysDictField.typeName()))
        #                {
        #                    s = time2str(common.(fieldId),-1,-1);
        #                }
        #            default :
        #                s = common.(fieldId);
        #        }
        #        key += (i==1?'':',')+s;
        #    }
        #    return key;
        #}
      ENDSOURCE
      SOURCE #getSubString_W
        #// gets substring from line separated with placeholders %<number>
        #// Example:
        #//   getSubString_W("abc %1 def %2 ghi", 2) returns " def "
        ##define.PlaceholderSign("%")
        #public static str getSubString_W(str _string, int _idx)
        #{
        #    int startPos, endPos;
        #    str ret;
        #
        #    if (_idx == 1)
        #    {
        #        startPos  = 1;
        #    }
        #    else
        #    {
        #        startPos  = strScan(_string, #PlaceholderSign + int2str(_idx - 1), 1, strLen(_string));
        #        startPos += startPos ? 2 : 0;
        #    }
        #
        #    if (startPos)
        #    {
        #        endPos = strScan(_string, #PlaceholderSign + int2str(_idx), startPos, strLen(_string));
        #
        #        if (! endPos)
        #        {
        #            endPos = strLen(_string) + 1;
        #        }
        #
        #        ret = strRTrim(strLTrim(subStr(_string, startPos, endPos - startPos)));
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #getVirtualCompanyList
        #/// <summary>
        #///    Gets a list of all company record IDs that are part of the virtual company based on the return
        #///    value of the <c>curext</c> method.
        #/// </summary>
        #/// <returns>
        #///    A list of all company record IDs that are part of the virtual company based on the return value of
        #///    the <c>curext</c> method.
        #/// </returns>
        #static server container getVirtualCompanyList()
        #{
        #    container               result;
        #    VirtualDataAreaList     vc1, vc2;
        #    SysGlobalObjectCache    globalCache;
        #    CompanyInfo             c1;
        #
        #    //Try put pull from cache first
        #    globalCache = classfactory.globalObjectCache();
        #    result = globalCache.find(#VIRTUALCOMPANYLIST, [curext()]);
        #
        #    if(result != conNull())
        #    {
        #        return result;
        #    }
        #
        #    while select RecId from c1
        #        exists join vc1
        #        exists join vc2
        #            where vc1.Id == curext() &&
        #                vc2.VirtualDataArea == vc1.VirtualDataArea &&
        #                c1.DataArea == vc2.Id
        #    {
        #        result += c1.RecId;
        #    }
        #    globalCache.insert(#VIRTUALCOMPANYLIST, [curext()], result);
        #
        #    return result;
        #}
      ENDSOURCE
      SOURCE #getXmlNodeValue
        #static str getXmlNodeValue(XmlNode _node)
        #{
        #    System.Text.RegularExpressions.Regex re =
        #        // BP deviation documented
        #        new System.Text.RegularExpressions.Regex('^[ \r\n\t]*((.|\n)*?)[ \r\n\t]*$');
        #    System.Text.RegularExpressions.Match m = re.Match(_node.text());
        #    str result;
        #
        #    result = m.Result('$1');
        #    return result;
        #}
      ENDSOURCE
      SOURCE #greatestCommonDivisor
        #/// <summary>
        #///    Calculates the greatest common divisor of two specified integers.
        #/// </summary>
        #/// <param name="_firstInteger">
        #///    The first integer.
        #/// </param>
        #/// <param name="_secondInteger">
        #///    The second integer.
        #/// </param>
        #/// <returns>
        #///    The greatest common divisor of two integers.
        #/// </returns>
        #public static int greatestCommonDivisor(int _firstInteger, int _secondInteger)
        #{
        #    return (_secondInteger == 0) ? ((_firstInteger >= 0) ?  _firstInteger : -_firstInteger) : greatestCommonDivisor(_secondInteger, _firstInteger mod _secondInteger);
        #}
        #
      ENDSOURCE
      SOURCE #guidFromString
        #//BP Deviation Documented
        #static guid guidFromString(str _value)
        #{
        #    return str2guid(_value);
        #}
      ENDSOURCE
      SOURCE #hasFieldAccess
        #public static client server boolean hasFieldAccess(TableId _tableId, FieldId _fieldId, AccessType _neededAccessLevel = AccessType::View)
        #{
        #    DictField dictField = new DictField(_tableId, _fieldId);
        #
        #    if (dictField)
        #    {
        #        return dictField.rights() >= _neededAccessLevel;
        #    }
        #    return false;
        #}
      ENDSOURCE
      SOURCE #hasGUI
        #static boolean hasGUI()
        #{
        #    SysGlobalCache  cache   = classfactory.globalCache();
        #    boolean         hasGUI  = cache.get(staticMethodStr(Global, hasGUI), 0, false);
        #
        #    if (cache.isSet(staticMethodStr(Global, hasGUI), 0))
        #        return hasGUI;
        #
        #    hasGUI = false;
        #
        #    if (new xSession().clientKind() == ClientType::Client)
        #        hasGUI = true;
        #
        #    cache.set(staticMethodStr(Global, hasGUI), 0, hasGUI, false);
        #    return hasGUI;
        #}
      ENDSOURCE
      SOURCE #hasMenuItemAccess
        #static public boolean hasMenuItemAccess(MenuName name, MenuItemType type)
        #{
        #    boolean     ret = false;
        #    SysDictMenu sysDictMenu = SysDictMenu::newMenuItem(name, type);
        #
        #    if (sysDictMenu)
        #    {
        #        ret = sysDictMenu.isVisible();
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #hasMenuItemSecurityAccess
        #static boolean hasMenuItemSecurityAccess(MenuFunction _menu)
        #{
        #    SysDictMenu sysDictMenu;
        #
        #    if (_menu)
        #    {
        #        if (_menu.configurationKey())
        #        {
        #            if (!isConfigurationkeyEnabled(_menu.configurationKey()))
        #                return false;
        #            if (!isConfigurationkeyEnabled(_menu.countryConfigurationkey()))
        #                return false;
        #            if (!isConfigurationkeyEnabled(_menu.webConfigurationkey()))
        #                return false;
        #        }
        #
        #        sysDictMenu = SysDictMenu::newTreeNodePath(_menu.treeNodePath());
        #        if (sysDictMenu)
        #        {
        #            return sysDictMenu.rights() >= _menu.neededAccessLevel();
        #        }
        #        return false;
        #    }
        #    return true;
        #
        #}
      ENDSOURCE
      SOURCE #hasProperty
        #/* MAN
        #    returns true if the supplied property identifier exist in the supplied property set.
        #*/
        #static boolean hasProperty(str _properties, str _property)
        #{
        #    if (findPropertyPos(_properties,_property))
        #    {
        #        return true;
        #    }
        #    return false;
        #}
      ENDSOURCE
      SOURCE #hasSecureWebNodeAccess
        #static public boolean hasSecureWebNodeAccess(SecureNode node)
        #{
        #    if (node)
        #        return node.checkAccessRights();
        #
        #    return false;
        #}
      ENDSOURCE
      SOURCE #hasTableAccess
        #public static client server boolean hasTableAccess(TableId _tableId, AccessType _neededAccessLevel = AccessType::View)
        #{
        #    DictTable dictTable = new DictTable(_tableId);
        #
        #    if (dictTable)
        #    {
        #        return dictTable.rights() >= _neededAccessLevel;
        #    }
        #    return false;
        #}
      ENDSOURCE
      SOURCE #hex2Int
        #static int hex2Int(str 12 hex)
        #{
        #    int res = 0;
        #    int d = strLen(hex);
        #    int i = 1;
        #    int char;
        #
        #    int largeA = char2num('A',1);
        #    int largeF = char2num('F',1);
        #    int zero = char2num('0',1);
        #    int nine = char2num('9',1);
        #
        #    hex = strUpr(hex);
        #
        #    while (i <= d)
        #    {
        #        char = char2num(hex,i);
        #
        #        res = res * 16;
        #        if ((char >= zero) && (char <= nine))
        #            res += (char - zero);
        #        else if ((char >= largeA) && (char <= largeF))
        #            res += (char - largeA + 10);
        #        else
        #            return 0;
        #        i++;
        #    }
        #
        #    return res;
        #}
      ENDSOURCE
      SOURCE #hex2RGB
        #/// <summary>
        #/// Converts the hexadecimal value to RGB container
        #/// </summary>
        #/// <param name="_hexValue">
        #/// The hexadecimal value to convert.
        #/// </param>
        #/// <returns>
        #/// Container of the RGB representation of the color.
        #/// </returns>
        #public static container hex2RGB(SysColorHex _hexValue)
        #{
        #    container rgbCon = conNull();
        #
        #    rgbCon += hex2Int(subStr(_hexValue, 1, 2));
        #    rgbCon += hex2Int(subStr(_hexValue, 3, 2));
        #    rgbCon += hex2Int(subStr(_hexValue, 5, 2));
        #
        #    return rgbCon;
        #}
      ENDSOURCE
      SOURCE #info
        #client server static Exception info(SysInfoLogStr txt, URL helpUrl = '', SysInfoAction _sysInfoAction = null)
        #{
        #    return infolog.add(Exception::Info, getPrefix()+txt, helpUrl, _sysInfoAction, false);
        #}
      ENDSOURCE
      SOURCE #infologLine
        #/// <summary>
        #/// Gets the number of lines in the Infolog buffer.
        #/// </summary>
        #/// <returns>
        #/// The number of lines in the Infolog buffer.
        #/// </returns>
        #/// <remarks>
        #/// This method has similar functionality to the <c>xInfo.line</c> method, but it improves performance
        #/// and lowers network load when you are executing server-side code.When the <c>xInfo.line</c> method
        #/// is run on the server, it makes a call to the client to retrieve the number of lines in the Infolog
        #/// buffer. The <c>xGlobal::infologLine</c> method retrieves the server-side Infolog buffer line count.
        #/// This eliminates the requirement to call to the client. When the <c>xGlobal::infologLine</c> method
        #/// is called on the client, it returns the count directly from the Infolog buffer on the client.This
        #/// method is especially useful when you write server-side code that processes exceptions.The number of
        #/// lines in the Infolog is generally stored before entering a <c>try</c> / <c>catch</c> block.If an
        #/// exception occurs, the number of lines that were previously stored is used to determine which
        #/// messages were logged during the code in the <c>try</c> block. If no exceptions occur, the stored
        #/// Infolog buffer line count is often unused. If you use the <c>xGlobal::infologLine</c> method
        #/// instead of the <c>xInfo.line</c> method to retrieve the Infolog lines, a round-trip to the client
        #/// is prevented.
        #/// </remarks>
        #public static int infologLine()
        #{
        #    return xGlobal::infologLine();
        #}
      ENDSOURCE
      SOURCE #inRange
        #static boolean inRange(str _rangeValue, anytype _value, boolean _checkNull = true)
        #{
        #    TmpQueryRangeValue      t;
        #    Query                   q;
        #    QueryBuildDataSource    qbdS;
        #    QueryBuildRange         qbR;
        #
        #    QueryRun qR;
        #
        #    if (_checkNull)
        #        if (_value == nullValueBaseType(typeOf(_value), true))
        #            return false;
        #
        #    q    = new Query();
        #    qbdS = q.addDataSource(t.TableId);
        #
        #    switch (typeOf(_value))
        #    {
        #        case Types::Real:
        #            t.Real1 = _value;
        #            qbR = qbdS.addRange(fieldNum(TmpQueryRangeValue,Real1));
        #            break;
        #
        #        case Types::Integer:
        #            t.Int1 = _value;
        #            qbR = qbdS.addRange(fieldNum(TmpQueryRangeValue,Int1));
        #            break;
        #
        #        case Types::Date:
        #            t.Date1 = _value;
        #            qbR = qbdS.addRange(fieldNum(TmpQueryRangeValue,Date1));
        #            break;
        #
        #        case Types::String:
        #            t.Str1 = _value;
        #            qbR = qbdS.addRange(fieldNum(TmpQueryRangeValue,Str1));
        #            break;
        #
        #        case Types::Enum:
        #            t.Str1 = enum2str(_value);
        #            qbR = qbdS.addRange(fieldNum(TmpQueryRangeValue,Str1));
        #            break;
        #
        #        case Types::Int64:
        #            t.Int641 = any2int64(_value);
        #            qbR = qbdS.addRange(fieldNum(TmpQueryRangeValue,Int641));
        #            break;
        #
        #        case Types::Guid:
        #            t.Guid1 = any2guid(_value);
        #            qbR = qbdS.addRange(fieldNum(TmpQueryRangeValue,Guid1));
        #            break;
        #
        #        case Types::UtcDateTime:
        #            t.Date1 = _value;
        #            qbR = qbdS.addRange(fieldNum(TmpQueryRangeValue,DateTime1));
        #            break;
        #
        #        default:
        #            setPrefix(funcName());
        #            throw error(strFmt("@SYS26908",typeOf(_value)));
        #    }
        #
        #    qbR.value(_rangeValue);
        #
        #    t.insert();
        #    qR = new QueryRun(q);
        #    qR.setCursor(t);
        #    return qR.next();
        #}
      ENDSOURCE
      SOURCE #int2Hex
        ##DEFINE.HEXDIGITS('0123456789ABCDEF')
        #static str 12 int2Hex( int iValue, int digits = 0 )
        #{
        #    int     i;
        #    int     iTemp;
        #    str 12  result = '';
        #    boolean isFirstTime = true;
        #
        #    for (i=0;i<=7;i++)
        #    {
        #        iTemp = iValue & 0xf0000000u;
        #        iTemp = iTemp >> 28;
        #        iTemp = iTemp & 0x0000000f;
        #
        #        if (isFirstTime && iTemp != 0)
        #        {
        #            isFirstTime = false;
        #        }
        #        if (!(isFirstTime && iTemp == 0))
        #        {
        #            iTemp++;
        #            result += subStr(#HEXDIGITS,iTemp,1);
        #        }
        #        iValue = iValue << 4;
        #    }
        #    while ((digits > 0) && (strLen(result) < digits))
        #    {
        #        result  = '0' + result;
        #    }
        #    return result;
        #}
      ENDSOURCE
      SOURCE #int642int
        #static int int642int(int64 _value, boolean _throwIfError = true)
        #{ // cast int64 to integer with optional check for overflow
        #    if (_value >= 0)
        #    {
        #        if (_throwIfError && _value > intMax())
        #        {
        #            throw(error(Error::wrongUseOfFunction(funcName())));
        #        }
        #        return any2int(_value);
        #    }
        #
        #    if (_throwIfError && _value < intMin())
        #    {
        #        throw(error(Error::wrongUseOfFunction(funcName())));
        #    }
        #    return any2int(_value);
        #}
      ENDSOURCE
      SOURCE #int64Max
        #static int64 int64Max()
        #{
        #    return 0x7fffffffffffffff;
        #}
      ENDSOURCE
      SOURCE #int64Min
        #static int64 int64Min()
        #{
        #    return 0x8000000000000000u;
        #}
      ENDSOURCE
      SOURCE #intMax
        #static int intMax()
        #{
        #    return maxInt();
        #}
      ENDSOURCE
      SOURCE #intMin
        #static int intMin()
        #{
        #    return minInt();
        #}
      ENDSOURCE
      SOURCE #inverseContributionRatio
        #/// <summary>
        #/// Calculates the sale price based on the purchase price and the contribution ratio.
        #/// </summary>
        #/// <param name="purchase">The purchase price.</param>
        #/// <param name="contribution_ratio">The contribution ratio.</param>
        #/// <returns>The sale price based on the purchase price and the contribution ratio.</returns>
        #static real inverseContributionRatio(real purchase, real contribution_ratio)
        #{
        #    return idg(purchase, contribution_ratio);
        #}
      ENDSOURCE
      SOURCE #isAllowedToStartEventTracing
        #/// <summary>
        #/// Verifies if the Windows Identity of the current process is allowed to control event tracing sessions.
        #/// </summary>
        #/// <returns>
        #/// true if the Windows Identity of the current process is allowed to control event tracing sessions, false otherwise.
        #/// </returns>
        #/// <remarks>
        #/// Only users with administrative privileges, users in the Performance Log Users group, and services running as LocalSystem,
        #/// LocalService, NetworkService can control event tracing sessions. To grant a restricted user the ability to control trace
        #/// sessions, add them to the Performance Log Users group.
        #///
        #/// Windows XP and Windows 2000:  Anyone can control a trace session.
        #/// If the user is a member of the Performance Log Users group, they may not have permission to create the log file in the
        #/// specified folder.
        #/// </remarks>
        #private static boolean isAllowedToStartEventTracing()
        #{
        #    #define.NTAccountType('System.Security.Principal.NTAccount')
        #
        #    System.Security.Principal.WindowsIdentity               windowsIdentity;
        #    System.Security.Principal.WindowsPrincipal              windowsPrincipal;
        #    System.Security.Principal.SecurityIdentifier            userSid;
        #    System.Security.Principal.SecurityIdentifier            domainSid;
        #    System.Security.Principal.SecurityIdentifier            perfLogUserGroupSid;
        #    System.Security.Principal.IdentityReferenceCollection   identityRefCollection;
        #    System.Security.Principal.IdentityReference             identityReference;
        #    System.Security.Principal.NTAccount                     groupSid;
        #    System.Security.Principal.NTAccount                     perfGroupSid;
        #    int                                                     g, groupCount;
        #
        #    windowsIdentity = System.Security.Principal.WindowsIdentity::GetCurrent();
        #    windowsPrincipal = new System.Security.Principal.WindowsPrincipal(windowsIdentity);
        #
        #    // Windows users with administrative privileges can control event tracing sessions.
        #    if (windowsPrincipal.IsInRole(System.Security.Principal.WindowsBuiltInRole::Administrator))
        #    {
        #        return true;
        #    }
        #
        #    userSid = windowsIdentity.get_User();
        #    domainSid = userSid.get_AccountDomainSid();
        #
        #    // Services running as LocalSystem, LocalService, NetworkService can control event tracing sessions.
        #    if (userSid.Equals( new System.Security.Principal.SecurityIdentifier(System.Security.Principal.WellKnownSidType::NetworkServiceSid, domainSid)) ||
        #        userSid.Equals( new System.Security.Principal.SecurityIdentifier(System.Security.Principal.WellKnownSidType::LocalServiceSid, domainSid)) ||
        #        userSid.Equals( new System.Security.Principal.SecurityIdentifier(System.Security.Principal.WellKnownSidType::LocalSystemSid, domainSid)))
        #    {
        #        return true;
        #    }
        #
        #    perfLogUserGroupSid = new System.Security.Principal.SecurityIdentifier(System.Security.Principal.WellKnownSidType::BuiltinPerformanceLoggingUsersSid, domainSid);
        #    perfGroupSid = perfLogUserGroupSid.Translate(System.Type::GetType(#NTAccountType));
        #
        #    identityRefCollection = windowsIdentity.get_Groups();
        #    groupCount = identityRefCollection.get_Count();
        #
        #    for (g = 0; g < groupCount; g++)
        #    {
        #        identityReference = identityRefCollection.get_Item(g);
        #
        #        try
        #        {
        #            groupSid = identityReference.Translate(System.Type::GetType(#NTAccountType));
        #
        #            // Windows users in the Performance Log Users group can control event tracing sessions.
        #            if (perfGroupSid.Equals(groupSid))
        #            {
        #                return true;
        #            }
        #        }
        #        catch
        #        {
        #            continue;
        #        }
        #    }
        #
        #    return false;
        #}
      ENDSOURCE
      SOURCE #isAOS
        #static boolean isAOS()
        #{
        #    return xGlobal::isAOS();
        #}
      ENDSOURCE
      SOURCE #isClientAllowedToControlEventTracing
        #/// <summary>
        #/// Verifies if the Windows Identity of the account running the AX Client is allowed to control event tracing sessions.
        #/// </summary>
        #/// <returns>
        #/// true if the Windows Identity of the account running the AX Client is allowed to control event tracing sessions, false otherwise.
        #/// </returns>
        #/// <remarks>
        #/// Only users with administrative privileges, users in the Performance Log Users group, and services running as LocalSystem,
        #/// LocalService, NetworkService can control event tracing sessions. To grant a restricted user the ability to control trace
        #/// sessions, add them to the Performance Log Users group.
        #///
        #/// Windows XP and Windows 2000:  Anyone can control a trace session.
        #/// If the user is a member of the Performance Log Users group, they may not have permission to create the log file in the
        #/// specified folder.
        #/// </remarks>
        #public static client boolean isClientAllowedToControlEventTracing()
        #{
        #    return Global::isAllowedToStartEventTracing();
        #}
      ENDSOURCE
      SOURCE #isClientThin
        #client server static boolean isClientThin()
        #{
        #    return Session::aosClientMode() == AOSClientMode::Thin;
        #}
      ENDSOURCE
      SOURCE #isConfigMode
        #//To be used instead of appl.isConfigMode() to avoid c/s calls.
        #client server static boolean isConfigMode()
        #{
        #    SysGlobalCache  cache   = classfactory.globalCache();
        #    boolean         value;
        #
        #    if (cache.isSet(classStr(Global), funcName()))
        #        return cache.get(classStr(Global), funcName());
        #
        #    value = appl.isConfigMode();
        #    cache.set(classStr(Global), funcName(), value);
        #    return value;
        #}
      ENDSOURCE
      SOURCE #isCountryRegionRU
        #/// <summary>
        #/// Validates if the country, specified by Id, is Russian Federation.
        #/// </summary>
        #/// <param name="_countryRegionId">
        #/// Country Id.
        #/// </param>
        #/// <returns>
        #/// True, if ISO code for the country is 'RU'
        #/// </returns>
        #public server static boolean isCountryRegionRU(
        #    LogisticsAddressCountryRegionId _countryRegionId)
        #{
        #    #ISOCountryRegionCodes
        #    boolean                         isRU;
        #    LogisticsAddressCountryRegion   logisticsAddressCountryRegion;
        #
        #    logisticsAddressCountryRegion = LogisticsAddressCountryRegion::find(_countryRegionId);
        #
        #    isRU = logisticsAddressCountryRegion.isOcode == #isoRU;
        #
        #    // <RUP>
        #    if (!isRU &&
        #        _countryRegionId &&
        #        logisticsAddressCountryRegion.rPayParentCountryRegionId &&
        #        SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        #    {
        #        isRU = LogisticsAddressCountryRegion::find(logisticsAddressCountryRegion.rPayParentCountryRegionId).isOcode == #isoRU;
        #    }
        #    // </RUP>
        #
        #    return isRU;
        #}
      ENDSOURCE
      SOURCE #isDeveloper
        #public static boolean isDeveloper()
        #{
        #    SecurityRights rights = SecurityRights::construct();
        #
        #    return rights.isDeveloper();
        #}
      ENDSOURCE
      SOURCE #isGuest
        #static boolean isGuest()
        #{
        #    return xGlobal::isGuest();
        #}
      ENDSOURCE
      SOURCE #isInteger
        #static boolean isInteger(str txt)
        #{
        #    return str2IntOk( txt );
        #}
        #
      ENDSOURCE
      SOURCE #isLanguageArabic
        #static boolean isLanguageArabic(str lang)
        #{
        #    #define.LOWERCASE_AR('ar')
        #
        #    str language;
        #
        #    language = strLwr(subStr(lang, 0, 2));
        #    return (language == #LOWERCASE_AR);
        #}
      ENDSOURCE
      SOURCE #isLanguageRTL
        #/// <summary>
        #///    Checks if the specified language is 'Right to Left'.
        #/// </summary>
        #/// <param name="_languageId">
        #///    The language to check.
        #/// </param>
        #/// <returns>
        #///    true if the language is RTL; otherwise, false.
        #/// </returns>
        #static boolean isLanguageRTL(LanguageId _languageId)
        #{
        #    #Languages
        #    str lcLang;
        #
        #    lcLang = strLwr(subStr(_languageId, 0, 2));
        #    return (#arabicPrefix == lcLang ||
        #            #farsiPrefix == lcLang  ||
        #            #pashtoPrefix == lcLang ||
        #            #urduPrefix == lcLang   ||
        #            #hebrewPrefix == lcLang);
        #}
      ENDSOURCE
      SOURCE #isMatch
        #/// <summary>
        #/// Validates whether the specified regular expression finds a match in the specified input string.
        #/// </summary>
        #/// <param name="_input">
        #/// The string to search for the match.
        #/// </param>
        #/// <param name="_pattern">
        #/// The regular expression pattern to match.
        #/// </param>
        #/// <returns>
        #/// true if the regular expression finds a match; otherwise, false.
        #/// </returns>
        #public static boolean isMatch(
        #    str _input,
        #    str _pattern)
        #{
        #    System.Text.RegularExpressions.Regex regEx;
        #
        #    new InteropPermission(InteropKind::ClrInterop).assert();
        #
        #    //BP Deviation Documented
        #    regEx = new System.Text.RegularExpressions.Regex(_pattern);
        #    return regEx.IsMatch(_input);
        #}
      ENDSOURCE
      SOURCE #isNative
        #client server static boolean isNative()
        #{
        #    return ! appl.isSqlConnected();
        #}
      ENDSOURCE
      SOURCE #isPhysicallyExistingInDB
        #/// <summary>
        #///    Determines whether the specified table physically exists in the database.
        #/// </summary>
        #/// <param name="_tableId">
        #/// The ID of the table to check the existence in the database.
        #/// </param>
        #/// <returns>
        #///    true if the table physically exists in the database; otherwise, false.
        #/// </returns>
        #/// <remarks>
        #///    The table may not yet physically exist in the database during an upgrade scenario.
        #/// </remarks>
        #public static boolean isPhysicallyExistingInDB(TableId _tableId)
        #{
        #    SqlDictionary sqlDictionary;
        #
        #    select firstonly RecId from sqlDictionary
        #        where sqlDictionary.TabId == _tableId;
        #
        #    if (sqlDictionary.RecId == 0)
        #    {
        #        // The table does not yet physically exist in the database.
        #        return false;
        #    }
        #
        #    return true;
        #}
      ENDSOURCE
      SOURCE #isRecordTemplatePromptSuppressed
        #/// <summary>
        #/// Indicates whether the record template prompt should be suppressed for the given table.
        #/// </summary>
        #/// <param name="tabid">
        #/// The Table ID of the given table.
        #/// </param>
        #/// <returns>
        #/// true if the prompt should be suppressed; otherwise, false.
        #/// </returns>
        #/// <remarks>
        #/// This is the location for application teams to add tables for which a record template prompt should
        #/// be suppressed.
        #/// </remarks>
        #public static boolean isRecordTemplatePromptSuppressed(TableId tabid)
        #{
        #    boolean isSuppressed = false;
        #
        #    if (!Global::isRunningOnServer())
        #    {
        #        isSuppressed = infolog.globalCache().isSet(classStr(Global), staticMethodStr(Global, setRecordTemplatePromptGlobalSuppression));
        #    }
        #
        #    if (!isSuppressed)
        #    {
        #        switch(tabid)
        #        {
        #            default:
        #                isSuppressed=false;
        #                break;
        #        }
        #    }
        #
        #    return isSuppressed;
        #}
      ENDSOURCE
      SOURCE #isRunningMode
        #client server static boolean isRunningMode()
        #{
        #    SysGlobalCache cache = classfactory.globalCache();
        #    boolean        mode;
        #
        #    if (cache.isSet(classStr(Global), funcName()))
        #        return cache.get(classStr(Global), funcName());
        #
        #    if (! appl)
        #    {
        #        return false;
        #    }
        #
        #    mode = appl.isRunningMode();
        #    cache.set(classStr(Global), funcName(), mode);
        #    return mode;
        #}
        #
      ENDSOURCE
      SOURCE #isRunningOnServer
        #client server static boolean isRunningOnServer()
        #{
        #    return xGlobal::clientKind() == ClientType::Server;
        #}
      ENDSOURCE
      SOURCE #isServerAllowedToControlEventTracing
        #/// <summary>
        #/// Verifies if the Windows Identity of the account running the AOS process is allowed to control event tracing sessions.
        #/// </summary>
        #/// <returns>
        #/// true if the Windows Identity of the account running the AOS process is allowed to control event tracing sessions, false otherwise.
        #/// </returns>
        #/// <remarks>
        #/// Only users with administrative privileges, users in the Performance Log Users group, and services running as LocalSystem,
        #/// LocalService, NetworkService can control event tracing sessions. To grant a restricted user the ability to control trace
        #/// sessions, add them to the Performance Log Users group.
        #///
        #/// Windows XP and Windows 2000:  Anyone can control a trace session.
        #/// If the user is a member of the Performance Log Users group, they may not have permission to create the log file in the
        #/// specified folder.
        #/// </remarks>
        #public static server boolean isServerAllowedToControlEventTracing()
        #{
        #    return Global::isAllowedToStartEventTracing();
        #}
      ENDSOURCE
      SOURCE #isSessionActive
        #static boolean isSessionActive(Integer      _sessionId,
        #                               utcdatetime  sessionLoginDateTime,
        #                               boolean      checkSession = false
        #                              )
        #{
        #    xSession xSession;
        #    SysClientSessions session;
        #
        #    select session where session.SessionId == _sessionId;
        #    if ( session && session.Status > 0 )
        #    {
        #        xSession = new xSession(_sessionId,checkSession);
        #        if (xSession)
        #        {
        #
        #            if (xSession.loginDateTime() != sessionLoginDateTime)
        #                return false;
        #
        #            return true;
        #        }
        #    }
        #    return false;
        #}
        #
      ENDSOURCE
      SOURCE #isSysId
        #static boolean isSysId(int _id)
        #{
        #    return _id >= 0xf000 && _id <= 0xffff;
        #}
      ENDSOURCE
      SOURCE #isSystemAdministrator
        #public static boolean isSystemAdministrator()
        #{
        #    SecurityRights rights = SecurityRights::construct();
        #
        #    return rights.isSystemAdministrator();
        #}
      ENDSOURCE
      SOURCE #isTableUserEnabled
        #static boolean isTableUserEnabled(TableId tableId, AccessType accessType = AccessType::Edit)
        #{
        #    DictTable dt=new DictTable(tableId);
        #
        #    //validate arguments before using them
        #    if (dt == null)
        #        return false;
        #    else
        #        return dt.rights() >= accessType;
        #}
      ENDSOURCE
      SOURCE #isType
        #/*
        #
        #*/
        #static client server boolean isType(ExtendedTypeId _extendedTypeId, ExtendedTypeId _isExtendedTypeId)
        #{
        #    DictType dictType;
        #
        #    if (!_extendedTypeId)
        #    {
        #        return false;
        #    }
        #
        #    if (_extendedTypeId == _isExtendedTypeId)
        #    {
        #        return true;
        #    }
        #
        #    dictType = new DictType(_extendedTypeId);
        #
        #    if (dictType != null)
        #    {
        #        return Global::isType(dictType.extend(), _isExtendedTypeId);
        #    }
        #    else
        #    {
        #        return false;
        #    }
        #}
      ENDSOURCE
      SOURCE #isTypeTime
        #/*
        #Tests whether the specified type is inherited from a timeOfDay type
        #*/
        #static boolean isTypeTime(ExtendedDataTypeName _typeName)
        #{
        #    return Global::isType(extendedTypeName2Id(_typeName), extendedTypeNum(TimeOfDay));
        #}
      ENDSOURCE
      SOURCE #isValidAOTName
        #//Returns whether or not the passed in text is a valid AOT name
        #public static boolean isValidAOTName(str sText)
        #{
        #    int i, len = strLen(sText);
        #    char c;
        #
        #    for (i=1; i<=len; ++i)
        #    {
        #        c = subStr(sText,i,1);
        #
        #        if( !('0' <= c && c <= '9') &&
        #            !('a' <= c && c <= 'z') &&
        #            !('A' <= c && c <= 'Z') &&
        #            !('_' == c) )
        #        {
        #            return false;
        #        }
        #    }
        #
        #    return true;
        #}
        #
      ENDSOURCE
      SOURCE #isValidURL
        #static client server boolean isValidURL(URL url)
        #{
        #    InteropPermission   permission;
        #    boolean             ret;
        #    str                 urlFilter;
        #    System.Text.RegularExpressions.Regex regEx;
        #    System.Text.RegularExpressions.Match regMatch;
        #
        #    permission = new InteropPermission(InteropKind::ClrInterop);
        #    permission.assert();
        #    // The regular expression used to validate URL was taken from
        #    // http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dnpag2/html/paght000001.asp
        #    // and modfied slightly to allow URL's without the HTTP part.
        #    urlFilter = @"^(http(s?)\:\/\/)?[0-9a-zA-Z]([-.\w]*[0-9a-zA-Z])*(:(0-9)*)*(\/?)([a-zA-Z0-9\-\.\?\,\'\/\\\+&;%\$#_]*)?$";
        #    //BP Deviation documented
        #    regEx = new System.Text.RegularExpressions.Regex(urlFilter);
        #    regMatch = regEx.Match(url);
        #    ret = regMatch.get_Success();
        #
        #    return ret;
        #}
        #
      ENDSOURCE
      SOURCE #isVirtualCompany
        #/// <summary>
        #/// Checks whether the curext() is part of a virtual company or not.
        #/// </summary>
        #/// <returns>
        #/// true if the curext() is part of a virtual company; otherwise, false.
        #/// </returns>
        #public static server boolean isVirtualCompany()
        #{
        #    VirtualDataAreaList     vc1;
        #    container               result;
        #    SysGlobalObjectCache    globalCache;
        #
        #    //Try put pull from cache first
        #    globalCache = classfactory.globalObjectCache();
        #    result = globalCache.find(#ISVIRTUALCOMPANY, [curext()]);
        #
        #    if(result != conNull())
        #    {
        #        return conPeek(result, 1);
        #    }
        #
        #    select firstonly RecId from vc1 where vc1.Id == curext();
        #
        #    globalCache.insert(#ISVIRTUALCOMPANY, [curext()], [vc1.RecId != 0]);
        #
        #    return (vc1.RecId != 0);
        #}
      ENDSOURCE
      SOURCE #WIK_getMethodParameterName
        #public static IdentifierName WIK_getMethodParameterName(
        #    Object  _object,
        #    str     _funcName
        #    )
        #{
        #    DictMethod                      dictMethod;
        #
        #    dictMethod  = new DictMethod(
        #        UtilElementType::ClassInstanceMethod,
        #        classIdGet(_object),
        #        strContains(_funcName, '.') ? any2str(conPeek(str2con(_funcName, '.'), 2)) : _funcName);
        #
        #    return dictMethod && dictMethod.parameterCnt() ? dictMethod.parameterName(1) : _funcName;
        #}
      ENDSOURCE
      SOURCE #japaneseEraStr2Date_JP
        #/// <summary>
        #/// convert Japanese Era date to Gregorian date
        #/// </summary>
        #/// <param name="_date">
        #/// The Japanese Era date value
        #/// </param>
        #/// <returns>
        #/// return Gregorian date converted from Japanese Era date if the length of parameter "_date" permitted, else return null date.
        #/// </returns>
        #// <GJP>
        #public static date japaneseEraStr2Date_JP(str _date)
        #{
        #    date    gregdate;
        #    int     era;
        #    int     mth;
        #    int     day;
        #    int     strLength;
        #    str     tempStr;
        #    #define.Numbers("0123456789")
        #    #define.PositionOne(1)
        #    #define.PositionTwo(2)
        #    #define.PositionThree(3)
        #    #define.PositionFive(5)
        #    #define.BaseEraYear(1988)
        #    #define.LengthAllowed(6)
        #
        #    tempStr   = _date;
        #    strLength = strLen(tempStr);
        #
        #    if (strLength > #LengthAllowed)
        #    {
        #        tempStr = strRem(_date, #Numbers);
        #        tempStr = strRem(_date, tempStr);
        #    }
        #
        #    if (strLength == #LengthAllowed
        #        || (strLength > #LengthAllowed && strLen(tempStr) == #LengthAllowed))
        #    {
        #        era      = str2int(subStr(tempstr, #PositionOne, #PositionTwo));
        #        mth      = str2int(subStr(tempstr, #PositionThree, #PositionTwo));
        #        day      = str2int(subStr(tempstr, #PositionFive, #PositionTwo));
        #    }
        #
        #    if (era != 0
        #        && mth != 0
        #        && day != 0)
        #    {
        #        gregdate = mkDate(day, mth, era + #BaseEraYear);
        #    }
        #    else
        #    {
        #        checkFailed("@GLS63107");
        #        // The Japanese date should be in YY/MM/DD format.
        #    }
        #
        #    return gregdate;
        #}
        #// </GJP>
      ENDSOURCE
      SOURCE #joinMode2LinkType
        #public static FormLinkType joinMode2LinkType(JoinMode _joinMode)
        #{
        #    switch (_joinMode)
        #    {
        #        case JoinMode::ExistsJoin :
        #            return FormLinkType::ExistJoin;
        #        case JoinMode::InnerJoin :
        #            return FormLinkType::InnerJoin;
        #        case JoinMode::NoExistsJoin :
        #            return FormLinkType::NotExistJoin;
        #        case JoinMode::OuterJoin :
        #            return FormLinkType::OuterJoin;
        #        default :
        #            throw error(Error::wrongUseOfFunction(funcName()));
        #    }
        #}
      ENDSOURCE
      SOURCE #languageList
        #static container languageList()
        #{
        #    return xGlobal::languageList();
        #}
      ENDSOURCE
      SOURCE #layerExists
        #static boolean layerExists(UtilEntryLevel layer)
        #{
        #    UtilFile newUtil = new UtilFile('aod');
        #    str layers = newUtil.layers();
        #    int j;
        #
        #    while (strLine(layers, j))
        #    {
        #        if (strLine(layers, j) == enum2str(layer))
        #            return true;
        #        j++;
        #    }
        #
        #    return false;
        #}
      ENDSOURCE
      SOURCE #legacyID2Name
        #/// <summary>
        #///    Converts the legacy ID of an element to the name of an element.
        #/// </summary>
        #/// <param name="_type">
        #///    The type of the element.
        #/// </param>
        #/// <param name="_legacyId">
        #///    The legacy ID of the element.
        #/// </param>
        #/// <param name="_parentName">
        #///    The name of the parent of the element; optional.
        #/// </param>
        #/// <returns>
        #///    The name of the element that has the specified legacy ID; otherwise, an empty string.
        #/// </returns>
        #public static UtilElementName legacyID2Name(
        #    UtilElementType _type,
        #    int             _legacyId,
        #    UtilElementName _parentName = ''
        #)
        #{
        #    UtilElementId parentId;
        #    UtilIdElements utilElements;
        #
        #    switch (_type)
        #    {
        #        case UtilElementType::TableField:
        #        case UtilElementType::TableIndex:
        #            parentId = tableName2id(_parentName);
        #            break;
        #
        #        default:
        #            parentId = 0;
        #            break;
        #    }
        #
        #    select firstonly Name from utilElements
        #        where utilElements.Id == _legacyId &&
        #              utilElements.ParentId == parentId &&
        #              utilElements.RecordType == _type;
        #
        #    if (utilElements)
        #        return utilElements.Name;
        #
        #    return '';
        #}
      ENDSOURCE
      SOURCE #loadArrayFromXML
        #static int loadArrayFromXML (XmlNode n, Array a)
        #{
        #    XmlNamedNodeMap attrs;
        #    XmlNode elementNode = n;
        #    Struct s;
        #    int indexValue;
        #
        #    //validate arguments before using them
        #    if (n == null)
        #        return  0;
        #    elementNode = n.firstChild();
        #    while (elementNode)
        #    {
        #        attrs = elementNode.attributes();
        #        indexValue = str2int(attrs.getNamedItem('index').text());
        #
        #        // Syp Modifications - SP3 [V-ALEXA][HQ-921-681-FEAC] - BEGIn
        #        // s = valueFromXMLNode(a.typeId(), elementNode);
        #        if (elementNode.hasChildNodes())
        #            // Composite value. Dig into the the <value> ... </values>
        #            s = valueFromXMLNode(a.typeId(), elementNode.firstChild());
        #        else
        #            // Simple value
        #            s = valueFromXMLNode(a.typeId(), elementNode);
        #        // Syp Modifications - SP3 - ENd
        #
        #
        #        a.value(indexValue, s.value('value'));
        #        elementNode = elementNode.nextSibling();
        #    }
        #    return 0;
        #}
        #
      ENDSOURCE
      SOURCE #loadListFromXML
        #static int loadListFromXML(XmlNode n, List l)
        #{
        #    XmlNode elementNode;
        #    Struct s;
        #
        #    //validate arguments before using them
        #    if (n == null)
        #        return  0;
        #    elementNode = n.firstChild();
        #    while (elementNode)
        #    {
        #        // Syp Modifications - SP3 [V-ALEXA][HQ-921-681-FEAC] - BEGIn
        #        // s = valueFromXMLNode(l.typeId(), elementNode);
        #        if (elementNode.hasChildNodes())
        #            // Composite value. Dig into the the <value> ... </values>
        #            s = valueFromXMLNode(l.typeId(), elementNode.firstChild());
        #        else
        #            // Simple valu
        #            s = valueFromXMLNode(l.typeId(), elementNode);
        #        // Syp Modifications - SP3 - ENd
        #
        #        l.addEnd(s.value('value'));
        #        elementNode = elementNode.nextSibling();
        #    }
        #    return 0;
        #}
        #
      ENDSOURCE
      SOURCE #loadMapFromXML
        #static int loadMapFromXML(XmlNode n, Map m)
        #{
        #    XmlNode elementNode;
        #    XmlNode keyNode, valueNode;
        #    Struct keyValue, valueValue;
        #
        #    //validate arguments before using them
        #    if (n == null)
        #        return  0;
        #    elementNode = n.firstChild();
        #
        #    while (elementNode)
        #    {
        #        // Get the key and value nodes.
        #        keyNode = elementNode.firstChild();
        #        valueNode = keyNode.nextSibling();
        #
        #        // Syp Modifications - SP3 [V-ALEXA][HQ-921-681-FEAC] - BEGIn
        #        // keyValue = valueFromXMLNode(m.keyType(), keyNode);
        #        // valueValue = valueFromXMLNode(m.valueType(), valueNode);
        #        if (keyNode.hasChildNodes())
        #            // Composite value. Dig into the the <value> ... </values>
        #            keyValue = valueFromXMLNode(m.keyType(), keyNode.firstChild());
        #        else
        #            // Simple value
        #            keyValue = valueFromXMLNode(m.keyType(), keyNode);
        #
        #        if (valueNode.hasChildNodes())
        #            // Composite value. Dig into the the <value> ... </values>
        #            valueValue = valueFromXMLNode(m.valueType(), valueNode.firstChild());
        #        else
        #            // Simple value
        #            valueValue = valueFromXMLNode(m.valueType(), valueNode);
        #        // Syp Modifications - SP3 - ENd
        #
        #        m.insert(keyValue.value('value'), valueValue.value('value'));
        #
        #        elementNode = elementNode.nextSibling();
        #    }
        #    return 0;
        #}
        #
      ENDSOURCE
      SOURCE #loadSetFromXML
        #static int loadSetFromXML(XmlNode n, Set s)
        #{
        #    XmlNode elementNode;
        #    Struct res;
        #
        #    //validate arguments before using them
        #    if (n == null)
        #        return  0;
        #    elementNode = n.firstChild();
        #
        #    while (elementNode)
        #    {
        #        // Syp Modifications - SP3 [V-ALEXA][HQ-921-681-FEAC] - BEGIn
        #        // res = valueFromXMLNode(s.typeId(), elementNode);
        #        if (elementNode.hasChildNodes())
        #            // Composite value. Dig into the the <value> ... </values>
        #            res = valueFromXMLNode(s.typeId(), elementNode.firstChild());
        #        else
        #            // Simple value
        #            res = valueFromXMLNode(s.typeId(), elementNode);
        #        // Syp Modifications - SP3 - ENd
        #
        #        s.add(res.value('value'));
        #        elementNode = elementNode.nextSibling();
        #    }
        #    return 0;
        #}
        #
      ENDSOURCE
      SOURCE #loadStructFromXML
        #static int loadStructFromXML(XmlNode n, Struct s)
        #{
        #    XmlNode elementNode;
        #    XmlNamedNodeMap attrs;
        #    Types fieldType;
        #    str fieldName;
        #    Struct res;
        #
        #    //validate arguments before using them
        #    if (n == null)
        #        return  0;
        #    elementNode = n.firstChild();
        #
        #    while (elementNode)
        #    {
        #        // Get the name and type...
        #        attrs = elementNode.attributes();
        #        fieldType = Global::xmlGetTypeFromSpelling(attrs.getNamedItem('type').text());
        #        fieldName = attrs.getNamedItem('name').text();
        #
        #        // Syp Modifications - SP3 [V-ALEXA][HQ-921-681-FEAC] - BEGIn
        #        // res = valueFromXMLNode(fieldType, elementNode);
        #        if (elementNode.hasChildNodes())
        #            // Composite value. Dig into the the <value> ... </values>
        #            res = valueFromXMLNode(fieldType, elementNode.firstChild());
        #        else
        #            // Simple value
        #            res = valueFromXMLNode(fieldType, elementNode);
        #        // Syp Modifications - SP3 - ENd
        #
        #        s.value(fieldName, res.value('value'));
        #
        #        elementNode = elementNode.nextSibling();
        #    }
        #    return 0;
        #}
        #
      ENDSOURCE
      SOURCE #map2Con
        #public static container map2Con(Map _map)
        #{
        #    MapEnumerator mapEnum = _map.getEnumerator();
        #    container conKeys = conNull(), conValues = conNull();
        #
        #    while (mapEnum.moveNext())
        #    {
        #        conKeys += mapEnum.currentKey();
        #        conValues += mapEnum.currentValue();
        #    }
        #
        #    return [conKeys, conValues];
        #}
      ENDSOURCE
      SOURCE #mappingExists
        #/// <summary>
        #/// Validates if table is mapped.
        #/// </summary>
        #/// <param name="_mapId">
        #/// Map Id.
        #/// </param>
        #/// <param name="_tableId">
        #/// Table Id.
        #/// </param>
        #/// <param name="_mapField">
        #/// Map field Id.
        #/// </param>
        #/// <param name="_tableField">
        #/// Table field Id.
        #/// </param>
        #/// <returns>
        #/// true if table is mapped to the specified map.
        #/// </returns>
        #/// <remarks>
        #/// Depending on additional parameters validation drills down to fields mapping.
        #/// <list type="bullet">
        #/// <item>If <paramref name="_mapField"/> and <paramref name="_tableField"/> are empty:
        #/// returns true if the <paramref name="_mapId"/> map have a mapping for table <paramref name="_tableId"/></item>
        #/// <item>If <paramref name="_mapField"/> is not empty:
        #/// returns true if the <paramref name="_mapId"/> map have a mapping for it's field <paramref name="_mapField"/> for table <paramref name="_tableId"/></item>
        #/// <item>If <paramref name="_tableField"/> is not empty:
        #/// returns true if the <paramref name="_mapId"/> map have a mapping for table's field <paramref name="_tableField"/> for table <paramref name="_tableId"/></item>
        #/// <item>If <paramref name="_mapField"/> and <paramref name="_tableField"/> are not empty:
        #/// returns true if <paramref name="_mapField"/> is a mapping for <paramref name="_tableField"/> on map <paramref name="_mapId"/> for table <paramref name="_tableId"/></item>
        #/// </list>
        #/// </remarks>
        #static public boolean mappingExists(
        #    TableId _mapId,
        #    TableId _tableId,
        #    FieldId _mapField   = 0,
        #    FieldId _tableField = 0)
        #{
        #    boolean          ok;
        #    Map              map = MappingsInfo_RU::createMapWithFieldId( _tableId, _mapId);
        #    IdentifierName   fieldName;
        #
        #    if (!map.empty())
        #    {
        #        if (_mapField || _tableField)
        #        {
        #            if (_mapField && _tableField)
        #            {
        #                fieldName = fieldId2name(_mapId, _mapField);
        #
        #                if (map.exists(fieldName) && (map.lookup(fieldName) == _tableField))
        #                {
        #                    ok = true;
        #                }
        #            }
        #            else if (_mapField)
        #            {
        #                if (map.keySet().in(fieldId2name(_mapId, _mapField)))
        #                {
        #                    ok = true;
        #                }
        #            }
        #            else if (_tableField)
        #            {
        #                if (map.valueSet().in(_tableField))
        #                {
        #                    ok = true;
        #                }
        #            }
        #        }
        #        else
        #        {
        #            ok = true;
        #        }
        #    }
        #
        #    return ok;
        #}
      ENDSOURCE
      SOURCE #maxRecId
        #static RecId maxRecId()
        #{
        #    return 0x7fffffffffffffffu;
        #}
      ENDSOURCE
      SOURCE #maxUInt
        #static real maxUInt()
        #{
        #    return 4294967295.0;
        #}
      ENDSOURCE
      SOURCE #maxUIPercent
        #/// <summary>
        #///    Retrieves a large percentage value.
        #/// </summary>
        #/// <returns>
        #///    A value of 99999999999999.99.
        #/// </returns>
        #/// <remarks>
        #///    The Percent extended data type can hold a larger value, but for user interface purposes this value
        #///    is desirable.
        #/// </remarks>
        #static real maxUIPercent()
        #{
        #    return 99999999999999.99;
        #}
      ENDSOURCE
      SOURCE #menuItemTypeStr2Type
        #static MenuItemType menuItemTypeStr2Type(str _menuItemTypeStr)
        #{
        #    switch (_menuItemTypeStr)
        #    {
        #        case 'D' : return MenuItemType::Display;
        #        case 'O' : return MenuItemType::Output;
        #        case 'A' : return MenuItemType::Action;
        #        default  : return MenuItemType::Display;
        #    }
        #
        #    return MenuItemType::Display;
        #}
      ENDSOURCE
      SOURCE #minOne
        #static RealBase minOne(RealBase value)
        #{
        #    if (!value)
        #        return 1;
        #
        #    return value;
        #}
      ENDSOURCE
      SOURCE #minRecId
        #static RecId minRecId()
        #{
        #    return 0;
        #}
      ENDSOURCE
      SOURCE #modulo10
        #static int modulo10(str numeralsTxt, boolean calculateControl = false)
        #{
        #    int     idx;
        #    int     control;
        #    int     sumvalue;
        #    int     lengthTxt;
        #
        #    if (calculateControl)
        #        numeralsTxt = numeralsTxt + '0';
        #
        #    lengthTxt   = strLen(numeralsTxt);
        #    idx         = lengthTxt;
        #
        #    while (idx >= 1)
        #    {
        #        sumvalue = str2int(subStr(numeralsTxt, idx, 1)) * (((lengthTxt - idx) mod 2) + 1);
        #        control += (sumvalue mod 10) + (sumvalue div 10);
        #        idx--;
        #    }
        #
        #    control = (10 - (control mod 10)) mod 10;
        #
        #    return control;
        #}
      ENDSOURCE
      SOURCE #modulo11
        #static int modulo11(str 20 numeralsTxt)
        #{
        #    int             numerals;
        #    int             vector;
        #    int             sumNumerals;
        #
        #    vector      = 2;
        #    sumNumerals = 0;
        #    numeralsTxt = strKeep(numeralsTxt,'0123456789');
        #
        #    sumNumerals = str2int(subStr(numeralsTxt,999,-2));
        #    numeralsTxt =         strDel(numeralsTxt,999,-2);
        #
        #    while (numeralsTxt)
        #    {
        #        numerals    = str2int(subStr(numeralsTxt,999,-2)) * vector;
        #        numeralsTxt =         strDel(numeralsTxt,999,-2);
        #
        #        sumNumerals += numerals;
        #        vector     += 1;
        #
        #        if (vector > 7)
        #        {
        #          vector = 2;
        #        }
        #    }
        #
        #    return ((sumNumerals mod 11) == 0);
        #}
      ENDSOURCE
      SOURCE #monthNumberToName_LV
        #/* Month name in local declension (LV - language specific) */
        ##define.LV("LV")
        #static MonthName monthNumberToName_LV(Months _num, LanguageId _languageId = #LV)
        #{
        #    #define.january(1)
        #    #define.february(2)
        #    #define.march(3)
        #    #define.april(4)
        #    #define.may(5)
        #    #define.june(6)
        #    #define.july(7)
        #    #define.august(8)
        #    #define.september(9)
        #    #define.october(10)
        #    #define.november(11)
        #    #define.december(12)
        #
        #    MonthName   ret;
        #    Label       label = _languageId ? new Label(_languageId) : new Label();
        #
        #    switch (_num)
        #    {
        #        case #january :
        #            ret = label.extractString(literalStr("@GLS108549"));
        #            break;
        #
        #        case #february :
        #            ret = label.extractString(literalStr("@GLS108550"));
        #            break;
        #
        #        case #march :
        #            ret = label.extractString(literalStr("@GLS108551"));
        #            break;
        #
        #        case #april :
        #            ret = label.extractString(literalStr("@GLS108553"));
        #            break;
        #
        #        case #may :
        #            ret = label.extractString(literalStr("@GLS108554"));
        #            break;
        #
        #        case #june :
        #            ret = label.extractString(literalStr("@GLS108552"));
        #            break;
        #
        #        case #july :
        #            ret = label.extractString(literalStr("@GLS108555"));
        #            break;
        #
        #        case #august :
        #            ret = label.extractString(literalStr("@GLS108556"));
        #            break;
        #
        #        case #september :
        #            ret = label.extractString(literalStr("@GLS108557"));
        #            break;
        #
        #        case #october :
        #            ret = label.extractString(literalStr("@GLS108558"));
        #            break;
        #
        #        case #november :
        #            ret = label.extractString(literalStr("@GLS108559"));
        #            break;
        #
        #        case #december :
        #            ret = label.extractString(literalStr("@GLS108560"));
        #            break;
        #
        #        default :
        #            throw error(strFmt("@SYS54195",funcName()));
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #naDate
        #static date naDate()
        #{
        #    return dateMax();
        #}
      ENDSOURCE
      SOURCE #naInt
        #static int naInt()
        #{
        #    return intMin();
        #}
      ENDSOURCE
      SOURCE #name2Alias
        #static str name2Alias(str _name)
        #{
        #    return strRem(_name,  ' .,;/-:\\+'  );
        #}
      ENDSOURCE
      SOURCE #naReal
        #static real naReal()
        #{
        #    return realMin();
        #}
      ENDSOURCE
      SOURCE #naStr
        #static TempStr naStr()
        #{
        #    return num2char(255);
        #}
      ENDSOURCE
      SOURCE #nullValue
        #static anytype nullValue(anytype a)
        #{
        #    return nullValueBaseType(typeOf(a));
        #}
      ENDSOURCE
      SOURCE #nullValueBaseType
        #/// <summary>
        #/// Returns default (null) value for a given base type.
        #/// </summary>
        #/// <param name="_baseType">
        #/// Base type
        #/// </param>
        #/// <param name="_enumAsInt">
        #/// Treat base enum as integer
        #/// </param>
        #/// <returns>
        #/// Default value for a given base type.
        #/// </returns>
        #/// <remarks>
        #/// <paramref name="_enumAsInt"/>: In some cases the kernel expects an integer instead of enum value.
        #/// For example when "adding" a struct it must be a enum, when setting a enum it must a integer.
        #/// </remarks>
        #static anytype nullValueBaseType(
        #    Types   _baseType,
        #    boolean _enumAsInt = false)
        #{
        #    Common common;
        #
        #    switch (_baseType)
        #    {
        #        case Types::Container:
        #            return conNull();
        #
        #        case Types::Date:
        #            return dateNull();
        #
        #        case Types::UtcDateTime:
        #            return utcDateTimeNull();
        #
        #        case Types::Enum:
        #            if (_enumAsInt)
        #                return 0;
        #            return false; //Do not return noYes::No, as it is incompatible with all other enums;
        #
        #        case Types::Integer:
        #            return 0;
        #
        #        case Types::Real:
        #            return 0.0;
        #
        #        case Types::Record:
        #            return common;
        #
        #        case Types::String,
        #             Types::RString,
        #             Types::VarString:
        #            return '';
        #
        #        case Types::Class:
        #            return null;
        #
        #        case Types::UserType:
        #            return 0;
        #
        #        case Types::Int64:
        #            return any2int64(0);
        #
        #        case Types::Guid:
        #            return str2guid('{00000000-0000-0000-0000-000000000000}');
        #    }
        #    return 0;
        #}
      ENDSOURCE
      SOURCE #nullValueFromType
        #static anytype nullValueFromType(Types basetype)
        #{
        #    switch (basetype)
        #    {
        #        case Types::String:
        #        case Types::VarString:
        #        case Types::RString:
        #            return '';
        #        case Types::Integer:
        #        case Types::Int64:
        #        case Types::Real:
        #        case Types::Time:
        #        case Types::Enum:       //Do not assume any type, like noYes::No
        #            return 0;
        #        case Types::Date:
        #            return dateNull();
        #        case Types::UtcDateTime:
        #            return utcDateTimeNull();
        #        case Types::Guid:
        #            return str2guid('{00000000-0000-0000-0000-000000000000}');
        #        case Types::Container:
        #            return conNull();
        #        default:
        #            throw error(strFmt("@SYS12580",basetype));
        #    }
        #    return 0;
        #}
      ENDSOURCE
      SOURCE #num2expstr
        #static str num2expstr(real r, int _separator1 = 1, int _separator2 = 0)
        #{
        #    real log  = (r?log10(abs(r)):0);
        #    int  decs = real2int(log);
        #    real factor;
        #
        #    int i;
        #
        #    if (decs<=0 && frac(log))
        #        decs--;
        #
        #    if (decs > 7 || decs < -1)  //use exponent notation
        #    {
        #        factor = decs<0?10:0.1;
        #        for (i=1;i<=abs(decs);i++)
        #            r = r * factor;
        #//        r = r / exp10(decs);  //gives rounding error
        #        return num2str(r,0,numOfDec(r),1,0)+(decs?'e'+int2str(decs):'');
        #    }
        #    return num2str(r,0,numOfDec(r), _separator1, _separator2);
        #}
      ENDSOURCE
      SOURCE #num2Str0
        #static TempStr num2Str0(real      value,
        #                        int       length,
        #                        int       numOfDec = 0,
        #                        int       sepDec   = 0,
        #                        int       sep1000  = 0
        #                       )
        #{
        #    str 100         curTxt;
        #    boolean negative = false;
        #
        #    if (value < 0.0)
        #    {
        #        value = -value;
        #        negative = true;
        #        length -= 1;
        #    }
        #
        #    curTxt = num2str(value, 0, numOfDec, sepDec, sep1000);
        #    curTxt = strRep('0', length - strLen(curTxt)) + curTxt;
        #
        #    if (negative)
        #    {
        #        curTxt = '-' + curTxt;
        #    }
        #
        #    return curTxt;
        #}
      ENDSOURCE
      SOURCE #num2Text
        #static TempStr num2Text(real numerals)
        #{
        #
        #    #DEFINE.NumDec(2)
        #
        #    str    1        digit;
        #    str   30        numeralsTxt;
        #    str  250        characters;
        #
        #    numeralsTxt= num2str(numerals,0,#NumDec,2,0);
        #    characters= "";
        #
        #    while (numeralsTxt)
        #    {
        #        digit  = subStr(numeralsTxt,1,1);
        #        numeralsTxt= strDel(numeralsTxt,1,1);
        #
        #        switch(digit)
        #        {
        #            case '0': characters+= "@SYS2068";
        #                      break;
        #            case '1': characters+= "@SYS5437";
        #                      break;
        #            case '2': characters+= "@SYS26621";
        #                      break;
        #            case '3': characters+= "@SYS8860";
        #                      break;
        #            case '4': characters+= "@SYS5232";
        #                      break;
        #            case '5': characters+= "@SYS4069";
        #                      break;
        #            case '6': characters+= "@SYS8502";
        #                      break;
        #            case '7': characters+= "@SYS15319";
        #                      break;
        #            case '8': characters+= "@SYS12322";
        #                      break;
        #            case '9': characters+= "@SYS5479";
        #                      break;
        #
        #            default:   characters+= numeralsTxt+'/1'+strRep('0',#NumDec);
        #                       numeralsTxt = '';
        #
        #                       break;
        #        }
        #        characters+= ' ';
        #    }
        #    return characters;
        #}
      ENDSOURCE
      SOURCE #numberOfProcessors
        #static int numberOfProcessors()
        #{
        #    container       systemInfo;
        #    int             numberofProcessors;
        #    systemInfo = WinAPI::getSystemInfo();
        #    numberofProcessors = conPeek(systemInfo,6);
        #    return numberOfProcessors;
        #}
      ENDSOURCE
      SOURCE #numeralsToThaiTxt
        #/// <summary>
        #/// This method is used to convert a number to Thai text.
        #/// </summary>
        #/// <param name="_num">
        #/// The number to convert.
        #/// </param>
        #/// <returns>
        #/// The converted result of money amount in Thai text.
        #/// </returns>
        #/// <remarks>
        #/// The number is rounded to two decimal places. And the sign of number is ignored.
        #/// </remarks>
        #// <GTH>
        #static TempStr numeralsToThaiTxt(real _num)
        #{
        #    #define.DigitZero('ศูนย์')
        #    #define.DigitOne('หนึ่ง')
        #    #define.DigitTwo('สอง')
        #    #define.DigitThree('สาม')
        #    #define.DigitFour('สี่')
        #    #define.DigitFive('ห้า')
        #    #define.DigitSix('หก')
        #    #define.DigitSeven('เจ็ด')
        #    #define.DigitEight('แปด')
        #    #define.DigitNine('เก้า')
        #
        #    #define.NumEleventh('เอ็ด')
        #    #define.NumTwenty('ยี่')
        #
        #    #define.UnitTen('สิบ')
        #    #define.UnitHundred('ร้อย')
        #    #define.UnitThousand('พัน')
        #    #define.UnitTenThousand('หมื่น')
        #    #define.UnitHundredThousand('แสน')
        #    #define.UnitMillion('ล้าน')
        #
        #    #define.WordBaht('บาท')
        #    #define.WordOnly('ถ้วน')
        #    #define.WordDecimal('สตางค์')
        #
        #    #define.BlockDigitsNumber(6)
        #
        #
        #    str 200     returnTxt;
        #    str         digit[9];
        #    str         unit[7];
        #
        #    int         curDigit;
        #    int         curBlockLevel;
        #
        #    int64       integerPart = real2double(trunc(abs(_num)));
        #    int         decimalPart = (decRound(frac(abs(_num)), 2) * 100) mod 100;
        #    int         tenths      = decimalPart div 10 mod 10;
        #    int         hundredths  = decimalPart mod 10;
        #
        #    digit[1]    = #DigitOne;
        #    digit[2]    = #DigitTwo;
        #    digit[3]    = #DigitThree;
        #    digit[4]    = #DigitFour;
        #    digit[5]    = #DigitFive;
        #    digit[6]    = #DigitSix;
        #    digit[7]    = #DigitSeven;
        #    digit[8]    = #DigitEight;
        #    digit[9]    = #DigitNine;
        #
        #    unit[1] = '';
        #    unit[2] = #UnitTen;
        #    unit[3] = #UnitHundred;
        #    unit[4] = #UnitThousand;
        #    unit[5] = #UnitTenThousand;
        #    unit[6] = #UnitHundredThousand;
        #    unit[7] = #UnitMillion;
        #
        #
        #    // Init the base txt
        #    if (integerPart == 0 && decimalPart == 0)
        #    {
        #        returnTxt = #DigitZero + #WordBaht;
        #    }
        #    else if (integerPart == 0)
        #    {
        #        returnTxt = '';
        #    }
        #    else
        #    {
        #        returnTxt = #WordBaht;
        #    }
        #
        #    // Process the integer part
        #    curBlockLevel = 1;
        #    while (integerPart > 0)
        #    {
        #        curDigit    = int642int(integerPart mod 10);
        #        integerPart = integerPart div 10;
        #
        #        // Add unit for current level
        #        if (curDigit != 0)
        #        {
        #            returnTxt = unit[curBlockLevel] + returnTxt;
        #        }
        #
        #        // Add number txt for current level
        #        if (curBlockLevel == 1)
        #        {
        #            if (curDigit == 1 && (integerPart mod 10))
        #            {
        #                returnTxt = #NumEleventh + returnTxt;
        #            }
        #            else if (curDigit > 0)
        #            {
        #                returnTxt = digit[curDigit] + returnTxt;
        #            }
        #        }
        #        else if (curBlockLevel == 2)
        #        {
        #            if (curDigit == 2)
        #            {
        #                returnTxt = #NumTwenty + returnTxt;
        #            }
        #            else if (curDigit > 2)
        #            {
        #                returnTxt = digit[curDigit] + returnTxt;
        #            }
        #        }
        #        else
        #        {
        #            if (curDigit > 0)
        #            {
        #                returnTxt = digit[curDigit] + returnTxt;
        #            }
        #        }
        #
        #        curBlockLevel++;
        #        if (curBlockLevel > #BlockDigitsNumber)
        #        {
        #            if (integerPart > 0)
        #            {
        #                returnTxt = unit[curBlockLevel] + returnTxt;
        #            }
        #
        #            curBlockLevel = 1;
        #        }
        #    }
        #
        #    // Process decimal part
        #    if (decimalPart == 0)
        #    {
        #        returnTxt += #WordOnly;
        #    }
        #    else
        #    {
        #        if (tenths == 2)
        #        {
        #            returnTxt += #NumTwenty;
        #        }
        #        else if (tenths > 2)
        #        {
        #            returnTxt += digit[tenths];
        #        }
        #
        #        if (tenths > 0)
        #        {
        #            returnTxt += #UnitTen;
        #        }
        #
        #        if (tenths > 0 && hundredths == 1)
        #        {
        #            returnTxt += #NumEleventh;
        #        }
        #        else if (hundredths > 0)
        #        {
        #            returnTxt += digit[hundredths];
        #        }
        #
        #        returnTxt += #WordDecimal;
        #    }
        #
        #    return strFmt('(%1)', returnTxt);
        #}
        #// </GTH>
      ENDSOURCE
      SOURCE #numeralsToTxt
        #static TempStr numeralsToTxt(real _num)
        #{
        #    int     numOfPennies = (decRound(frac(_num), 2) * 100) mod 100;
        #    real    test         = _num - frac(_num);
        #
        #    int64   numOfTenths;
        #    str 20  ones[19], tenths[9], hundreds, thousands, millions, billions, trillions;
        #
        #    int64   temp;
        #    str 200 returntxt;
        #    int64   testLoc;
        #
        #    real modOperator(real a1, real a2)
        #    {
        #    int tmpi;
        #    real tmp1, tmp2;
        #    tmp1 = a1 / a2;
        #    tmpi = real2int(tmp1);
        #    tmp2 = tmpi;
        #    return (tmp1 - tmp2)*a2;
        #    }
        #
        #    real checkPower(real  _test, int64 _power)
        #    {
        #        int64   numOfPower;
        #
        #        if (_test >= _power)
        #        {
        #            testLoc = real2double(_test);
        #            numOfPower = testLoc div _power;
        #
        #            if (numOfPower >= 100)
        #            {
        #                temp = numOfPower div 100;
        #                returntxt = returntxt + ' ' + ones[temp] + ' ' + hundreds;
        #                numOfPower = numOfPower mod 100;
        #            }
        #            if (numOfPower >= 20)
        #            {
        #                temp = numOfPower div 10;
        #                returntxt = returntxt + ' ' + tenths[temp];
        #                numOfPower = numOfPower mod 10;
        #            }
        #            if (numOfPower >= 1)
        #            {
        #                returntxt = returntxt + ' ' + ones[numOfPower];
        #                numOfPower = numOfPower mod 10;
        #            }
        #            switch(_power)
        #            {
        #                case 1000000000000 :
        #                    returntxt = returntxt + ' ' + trillions;
        #                    _test = modOperator(_test, 1000000000000.00);
        #                    break;
        #                case 1000000000 :
        #                    returntxt = returntxt + ' ' + billions;
        #                    _test = modOperator(_test, 1000000000);
        #                    break;
        #                case 1000000 :
        #                    returntxt = returntxt + ' ' + millions;
        #                    _test = modOperator(_test, 1000000);
        #                    break;
        #                case 1000 :
        #                    returntxt = returntxt + ' ' + thousands;
        #                    _test = modOperator(_test, 1000);
        #                    break;
        #                case 100 :
        #                    returntxt = returntxt + ' ' + hundreds;
        #                    _test = modOperator(_test, 100);
        #                    break;
        #            }
        #        }
        #        return _test;
        #    }
        #
        #
        #
        #    ones[1] = "@SYS26620";
        #    ones[2] = "@SYS26621";
        #    ones[3] = "@SYS26622";
        #    ones[4] = "@SYS26626";
        #    ones[5] = "@SYS26627";
        #    ones[6] = "@SYS26628";
        #    ones[7] = "@SYS26629";
        #    ones[8] = "@SYS26630";
        #    ones[9] = "@SYS26631";
        #    ones[10] = "@SYS26632";
        #    ones[11] = "@SYS26633";
        #    ones[12] = "@SYS26634";
        #    ones[13] = "@SYS26635";
        #    ones[14] = "@SYS26636";
        #    ones[15] = "@SYS26637";
        #    ones[16] = "@SYS26638";
        #    ones[17] = "@SYS26639";
        #    ones[18] = "@SYS26640";
        #    ones[19] = "@SYS26641";
        #
        #    tenths[1] = 'Not used';
        #    tenths[2] = "@SYS26643";
        #    tenths[3] = "@SYS26644";
        #    tenths[4] = "@SYS26645";
        #    tenths[5] = "@SYS26646";
        #    tenths[6] = "@SYS26647";
        #    tenths[7] = "@SYS26648";
        #    tenths[8] = "@SYS26649";
        #    tenths[9] = "@SYS26650";
        #
        #    hundreds    = "@SYS26651";
        #    thousands   = "@SYS26652";
        #    millions    = "@SYS26653";
        #    billions    = "@SYS26654";
        #    trillions   = "@SYS101697";
        #
        #
        #    test = checkPower(test, 1000000000000);
        #    test = checkPower(test, 1000000000);
        #    test = checkPower(test, 1000000);
        #    test = checkPower(test, 1000);
        #    test = checkPower(test, 100);
        #
        #    if (test >= 20)
        #    {
        #        testLoc = real2double(test);
        #        numOfTenths = testLoc div 10;
        #
        #        returntxt = returntxt + ' ' + tenths[numofTenths];
        #        numOfTenths = numOfTenths mod 10;
        #        test = real2int(test) mod 10;
        #    }
        #    if (test >= 1)
        #    {
        #        numOfTenths = real2int(test);
        #        returntxt = returntxt + ' ' + ones[numOfTenths];
        #    }
        #
        #    if (numOfPennies)
        #    {
        #        returntxt = '***' + returntxt + ' ' + "@SYS5534" + ' ' + num2str(numOfPennies,0,0,0,0) + '/100';
        #    }
        #    else
        #    {
        #        returntxt = '***' + returntxt + ' ' + "@SYS5534" + ' ' + '00/100';
        #    }
        #
        #    return returntxt;
        #}
      ENDSOURCE
      SOURCE #numeralsToTxt_BR
        #static TempStr numeralsToTxt_BR(real _amount, NumeralsToTxtOptions_BR _options = NumeralsToTxtOptions_BR::default())
        #{
        #    str fullText;
        #    boolean firstWord = true;
        #    int64 intAmount;
        #    int64 intCentsAmount;
        #    int64 sideAmount;
        #    int64 sidePower;
        #    int64 partAmount;
        #    int64 partPower;
        #    int64 curPartAmount;
        #    real  centsAmount;
        #
        #    str prependConnector(str _txt)
        #    {
        #        str retVal = _txt;
        #
        #        if (!firstWord && retVal != "")
        #        {
        #            if (_options.parmAndText() && (!(curPartAmount mod partPower) || partPower < 100))
        #            {
        #                retVal = _options.parmAndText() + " " + retVal;
        #            }
        #            retVal = " " + retVal;
        #        }
        #
        #        return retVal;
        #    }
        #
        #    str fixCasing(str _txt)
        #    {
        #        str retVal = _txt;
        #
        #        if (firstWord && _options.parmCapitalFirstWord())
        #        {
        #            retVal = Global::str2CapitalWord(retVal);
        #        }
        #
        #        return retVal;
        #    }
        #
        #    str parsePart(int64 _partAmount)
        #    {
        #        str retVal;
        #        str partText;
        #
        #        partAmount = _partAmount;
        #
        #        for (   partPower = 100 ;
        #                partPower > 0 ;
        #                partPower = partPower / 10)
        #        {
        #            curPartAmount = _partAmount mod (partPower * 10);
        #            if (curPartAmount div partPower)
        #            {
        #                if (curPartAmount)
        #                {
        #                    if (curPartAmount == 1)
        #                    {
        #                        if (firstWord)
        #                        {
        #                            partText = _options.parmOneAsTheFirstWord();
        #                        }
        #                        else if (sidePower == 1000 && _partAmount == 1)
        #                        {
        #                            partText = _options.parmOneAsInOneThousand();
        #                        }
        #                        else if (_partAmount == 1)
        #                        {
        #                            partText = _options.parmOneAsInOnePart();
        #                        }
        #                        else
        #                        {
        #                            partText = _options.parmOneRegular();
        #                        }
        #                    }
        #                    else
        #                    {
        #                        partText = _options.numberText(curPartAmount);
        #                    }
        #
        #                    partText =  fixCasing(prependConnector(partText));
        #                    firstWord = false;
        #
        #                    retVal += partText;
        #                }
        #
        #                if (curPartAmount >= 10 && curPartAmount <= 19)
        #                {
        #                    break;
        #                }
        #            }
        #        }
        #
        #        return retVal;
        #    }
        #
        #    str parseSide(int64 _sideAmount)
        #    {
        #        str     retVal;
        #        int64   curAmount = _sideAmount;
        #
        #        sideAmount = _sideAmount;
        #        for (   sidePower = 1000000000 ;
        #                sidePower > 0 ;
        #                sidePower = sidePower / 1000)
        #        {
        #            curAmount = _sideAmount div sidePower;
        #
        #            if (curAmount)
        #            {
        #                retVal += parsePart(curAmount);
        #                if (sidePower > 1)
        #                {
        #                    retVal += strFmt(" %1", _options.powerText(_sideAmount));
        #                }
        #            }
        #
        #            _sideAmount = _sideAmount mod sidePower;
        #        }
        #
        #        return retVal;
        #    }
        #
        #    intAmount = real2int(_amount);
        #    fullText = parseSide(intAmount);
        #    if (fullText)
        #    {
        #        fullText += " " + _options.currencyText(intAmount);
        #    }
        #
        #    if (_options.fixedTextForCents() != "")
        #    {
        #        fullText += _options.fixedTextForCents();
        #    }
        #    else
        #    {
        #        centsAmount = (_amount - sideAmount) * 100;
        #        intCentsAmount = real2int(centsAmount);
        #        if (intCentsAmount)
        #        {
        #            fullText += strFmt("%1 %2", parseSide(intCentsAmount), _options.currencyCentsText(intCentsAmount));
        #        }
        #    }
        #
        #    return fullText;
        #}
      ENDSOURCE
      SOURCE #numeralsToTxt_CN
        #/// <summary>
        #///     Convert numerals to Chinese format text.
        #/// </summary>
        #/// <param name="_number">
        #///     The numeral to be converted.
        #/// </param>
        #/// <param name="_type">
        #///     Specify whether to use Chinese simplified language.
        #/// </param>
        #/// <param name="_isMoney">
        #///     Specify whether to convert as Chinese money format.
        #/// </param>
        #/// <param name="_numLen">
        #///     The number length that should be converted.
        #/// </param>
        #/// <returns>
        #///     The converted string.
        #/// </returns>
        #/// <remarks>
        #///     This method is uptaken from older version, and make some changes to fix bugs.
        #/// </remarks>
        #// <GCN>
        #static TempStr numeralsToTxt_CN(RealBase _number, NoYes _type, NoYes _isMoney, Counter _numLen)
        #{
        #    TempStr strNum[10];
        #    TempStr strUnitSegmentDetail[16];
        #    TempStr strUnitDecimalPart[2];
        #    TempStr strUnitSegment[6];
        #
        #    TempStr result;
        #    TempStr strFirst;
        #    TempStr strEnd;
        #
        #    Counter lngNumberLen;
        #    Counter lngI;
        #    Counter lngJ;
        #    Counter pos;
        #
        #    TempStr strNumber;
        #    TempStr strTmp;
        #
        #    #MacroLib.Num2Char_CN
        #    #define.DecimalPrecisionOfAmount(2)
        #
        #    TempStr cutRightZero(TempStr _strNumber)
        #    {
        #        Counter     tempLen;
        #        Counter     i;
        #        TempStr     tempStr;
        #        TempStr     returnStr;
        #
        #        tempLen   = strLen(_strNumber);
        #        returnStr = _strNumber;
        #        for (i = tempLen; i >= 0; i--)
        #        {
        #            tempStr = strDel(returnStr, 1, i - 1);
        #            if (tempStr == #Decimal)
        #            {
        #                returnStr = strDel(returnStr, i, i);
        #                return returnStr;
        #            }
        #            else
        #            {
        #                if (tempStr == #Zero)
        #                {
        #                    returnStr = strDel(returnStr, i, i - 1);
        #                }
        #                else
        #                {
        #                    return returnStr;
        #                }
        #            }
        #        }
        #        return '';
        #    }
        #
        #    TempStr decimalfraction2chinese(TempStr _strDecimal,NoYes _isMon)
        #    {
        #        Counter lntgJ;
        #        Counter decimalLen;
        #        TempStr tempEndstr;
        #
        #        decimalLen = strLen(_strDecimal);
        #
        #        for (lntgJ = decimalLen; lntgJ >=1; lntgJ--)
        #        {
        #            if (str2int(subStr(_strDecimal, strLen(_strDecimal), -1)) == 0)
        #            {
        #                _strDecimal = subStr(_strDecimal, 1, strLen(_strDecimal) - 1);
        #            }
        #            else
        #            {
        #                break;
        #            }
        #        }
        #
        #        decimalLen = strLen(_strDecimal);
        #        tempEndstr = '';
        #
        #        for (lntgJ = 1; lntgJ <= decimalLen; lntgJ++)
        #        {
        #            if (str2int(subStr(_strDecimal, lntgJ, 1)) == 0)
        #            {
        #                if (_isMon == NoYes::No)
        #                {
        #                    if (lntgJ == decimalLen)
        #                    {
        #                        tempEndstr = tempEndstr;
        #                    }
        #                    else
        #                    {
        #                        tempEndstr = tempEndstr + strNum[10];
        #                    }
        #                }
        #                else
        #                {
        #                    if (lntgJ == 1)
        #                    {
        #                        tempEndstr = tempEndstr + strNum[10]+strUnitDecimalPart[1];
        #                    }
        #                }
        #            }
        #            else
        #            {
        #                if (_isMon == NoYes::Yes)
        #                {
        #                    tempEndstr = tempEndstr + strNum[str2int(subStr(_strDecimal, lntgJ, 1))] + strUnitDecimalPart[lntgJ];
        #                    if (decimalLen == 1)
        #                    {
        #                        tempEndstr = tempEndstr + #Integer;
        #                    }
        #                }
        #                else
        #                {
        #                    tempEndstr = tempEndstr + strNum[str2int(subStr(_strDecimal, lntgJ, 1))];
        #                }
        #            }
        #        }
        #        return tempEndstr;
        #    }
        #
        #    Counter getDecimalLen(RealBase _numb, Counter _numL)
        #    {
        #        Counter lntgI;
        #        Counter decimalLen;
        #        TempStr lngTmp;
        #
        #        lngTmp = strLTrim(strRTrim(num2str(_numb, 10, #DecimalPrecisionOfAmount, 1, 0)));
        #        lntgI = strFind(lngTmp,#Decimal,1,strLen(lngTmp));
        #        decimalLen  = _numL - lntgI;
        #        if (decimalLen < 0)
        #        {
        #            decimalLen = 0;
        #        }
        #        return decimalLen;
        #    }
        #
        #    TempStr keep2digits(TempStr _strNumber)
        #    {
        #        Counter lntgI;
        #        Counter numberLen;
        #        TempStr strTemp;
        #        TempStr strDotAfter;
        #
        #        numberLen = strLen(_strNumber);
        #        lntgI     = strFind(_strNumber, #Decimal, 1, numberLen);
        #        if (lntgI)
        #        {
        #            strTemp      = _strNumber + #Zeros;
        #            strDotAfter = subStr(strTemp, lntgI + 1, str2int(#NumTwo));
        #            if (strDotAfter == #Zeros)
        #            {
        #                strTemp = subStr(_strNumber, 1, lntgI-1);
        #            }
        #            else
        #            {
        #                strTemp = subStr(strTemp, 1, lntgI + str2int(#NumTwo));
        #            }
        #        }
        #        return strLTrim(strRTrim(strTemp));
        #    }
        #
        #    TempStr number2Chinese(TempStr _strNumber)
        #    {
        #        Counter strNumberLen;
        #        Counter lntgI;
        #        Counter lntgJ;
        #        TempStr strTemp;
        #        TempStr resultNumber;
        #
        #        resultNumber = '';
        #
        #        strNumberLen=strLen(_strNumber);
        #        if (strNumberLen == 0)
        #        {
        #            return '';
        #        }
        #        else
        #        {
        #            lntgI = 1;
        #            for (lntgJ = strNumberLen; lntgJ >= 1; lntgJ--)
        #            {
        #                strTemp=subStr(_strNumber, lntgJ, -1);
        #                if (strTemp == #Zero)
        #                {
        #                    if (resultNumber != '')
        #                    {
        #                        if (subStr(_strNumber,lntgJ+1,-1) != #Zero)
        #                        {
        #                            resultNumber = strNum[10] + resultNumber;
        #                        }
        #                    }
        #                }
        #                else
        #                {
        #                    resultNumber = strNum[str2int(strTemp)] + strUnitSegmentDetail[lntgI] + resultNumber;
        #                }
        #                lntgI = lntgI + 1;
        #            }
        #        }
        #        return resultNumber;
        #    }
        #
        #    void setUnit(NoYes _istype)
        #    {
        #        if (_istype == NoYes::No)
        #        {
        #            strNum[1] = #Cone;
        #            strNum[2] = #Ctwo;
        #            strNum[3] = #Cthree;
        #            strNum[4] = #Cfour;
        #            strNum[5] = #Cfive;
        #            strNum[6] = #Csix;
        #            strNum[7] = #Cseven;
        #            strNum[8] = #Ceight;
        #            strNum[9] = #Cnine;
        #            strNum[10] = #Czero;
        #
        #            strUnitSegmentDetail[1] = '';
        #            strUnitSegmentDetail[2] = #Cten;
        #            strUnitSegmentDetail[3] = #Chundred;
        #            strUnitSegmentDetail[4] = #Cthousand;
        #        }
        #        else if (_istype == NoYes::Yes)
        #        {
        #            strNum[1] = #Lone;
        #            strNum[2] = #Ltwo;
        #            strNum[3] = #Lthree;
        #            strNum[4] = #Lfour;
        #            strNum[5] = #Lfive;
        #            strNum[6] = #Lsix;
        #            strNum[7] = #Lseven;
        #            strNum[8] = #Leight;
        #            strNum[9] = #Lnine;
        #            strNum[10] = #Lzero;
        #
        #            strUnitSegmentDetail[1] = '';
        #            strUnitSegmentDetail[2] = #Lten;
        #            strUnitSegmentDetail[3] = #Lhundred;
        #            strUnitSegmentDetail[4] = #Lthousand;
        #        }
        #    }
        #
        #    void setUnitB(NoYes _isMony)
        #    {
        #        if (_isMony == NoYes::Yes)
        #        {
        #            strUnitDecimalPart[1] = #Penny;
        #            strUnitDecimalPart[2] = #Cent;
        #        }
        #        else
        #        {
        #            strUnitDecimalPart[1] = '';
        #            strUnitDecimalPart[2] = '';
        #        }
        #    }
        #
        #    void setUnitC(NoYes _isMony, NoYes _istype)
        #    {
        #        if (_isMony == NoYes::Yes)
        #        {
        #            if (_istype == NoYes::No)
        #            {
        #                strUnitSegment[1] = #Cyuan;
        #            }
        #            else
        #            {
        #                strUnitSegment[1] = #Lyuan;
        #            }
        #        }
        #        else
        #        {
        #            strUnitSegment[1] = '';
        #        }
        #        strUnitSegment[2] = #CMillion;
        #        strUnitSegment[3] = #CBillion;
        #        strUnitSegment[4] = #CMillion;
        #    }
        #
        #    if (_numLen > str2int(#NumSixteen))
        #    {
        #        warning(strFmt("@GLS54781", #NumSixteen));
        #        return '';
        #    }
        #
        #    setUnit(_type);
        #    setUnitB(_isMoney);
        #    setUnitC(_isMoney, _type);
        #
        #
        #    if (_isMoney == NoYes::Yes)
        #    {
        #        _number = round(_number, Currency::find(Ledger::accountingCurrency()).RoundingPrecision);
        #    }
        #
        #    if (_number == 0)
        #    {
        #        if (_isMoney == NoYes::Yes)
        #        {
        #            result = strNum[10] + strUnitSegment[1] + #Integer;
        #        }
        #        else
        #        {
        #            result = strNum[10];
        #        }
        #    }
        #    else
        #    {
        #        strNumber    = num2str(_number, str2int(#NumTen), getDecimalLen(_number, _numLen),1 ,0);
        #        strNumber    = strLTrim(strRTrim(strNumber));
        #        pos          = strFind(strNumber, '.', 1, strLen(strNumber));
        #        if (pos != 0)
        #        {
        #            strNumber = cutRightZero(strNumber);
        #        }
        #        lngNumberLen = strLen(strNumber);
        #        lngI = strFind(strNumber, #Decimal, 1, lngNumberLen);
        #        if (_isMoney == NoYes::Yes)
        #        {
        #            if (!lngI)
        #            {
        #                strEnd = #Integer;
        #            }
        #            else
        #            {
        #                strEnd = '';
        #                strNumber = keep2digits(strNumber) ;
        #            }
        #        }
        #        else
        #        {
        #            if (!lngI)
        #            {
        #                strEnd = '';
        #            }
        #            else
        #            {
        #                strEnd = #Point;
        #            }
        #        }
        #
        #        lngNumberLen = strLen(strNumber);
        #
        #        if (subStr(strNumber, 1,1) == #Minus)
        #        {
        #            strFirst = #Negative;
        #            strNumber = strDel(strNumber, 1, 1);
        #            lngNumberLen = lngNumberLen - 1;
        #        }
        #        else
        #        {
        #            strFirst = '';
        #        }
        #
        #        lngI = strFind(strNumber, #Decimal, 1, lngNumberLen);
        #
        #        if (lngI)
        #        {
        #            strTmp = subStr(strNumber, lngI + 1, lngNumberLen);
        #
        #            strEnd=strEnd + decimalfraction2chinese(strTmp, _isMoney);
        #
        #            strNumber = subStr(strNumber,1, lngI - 1);
        #            lngNumberLen = strLen(strNumber);
        #        }
        #
        #        result = '';
        #
        #        lngJ = lngNumberLen / str2int(#NumFour);
        #
        #        if (lngJ * str2int(#NumFour) < lngNumberLen)
        #        {
        #            lngJ = lngJ + 1;
        #        }
        #
        #        for (lngI = 0; lngI < lngJ; lngI++)
        #        {
        #            if (lngI != lngJ - 1)
        #            {
        #                result = number2Chinese(subStr(strNumber, lngNumberLen - lngI * str2int(#NumFour), -str2int(#NumFour))) + strUnitSegment[lngI + 1] + result;
        #            }
        #            else
        #            {
        #                result = number2Chinese(subStr(strNumber, 1, lngNumberLen - lngI * str2int(#NumFour))) + strUnitSegment[lngI + 1] + result;
        #            }
        #        }
        #    }
        #
        #    // Insert zero when cmilliton is empty but not empty after cmillion.
        #    lngNumberLen = strLen(result);
        #    lngI = strScan(result, strUnitSegment[3] + strUnitSegment[2], 1, lngNumberLen);
        #    if (lngI == lngNumberLen - 1
        #        || (lngI + 2 <= lngNumberLen
        #            && (subStr(result, lngI + 2, 1)     == #Decimal
        #                || subStr(result, lngI + 2, 1)  == strUnitSegment[1]
        #                || subStr(result, lngI + 2, 1)  == strNum[10])))
        #    {
        #        result = strReplace(result, strUnitSegment[3] + strUnitSegment[2], strUnitSegment[3]);
        #    }
        #    else
        #    {
        #        result = strReplace(result, strUnitSegment[3] + strUnitSegment[2], strUnitSegment[3] + strNum[10]);
        #    }
        #
        #    if (result == strUnitSegment[1] && _isMoney == NoYes::Yes )
        #    {
        #        result = strNum[10] + result;
        #    }
        #
        #    if (strLen(result) == 0 && _isMoney == NoYes::No)
        #    {
        #        result = strNum[10] + result;
        #    }
        #
        #    result = strFirst + result + strEnd;
        #
        #    return result;
        #}
        #// </GCN>
      ENDSOURCE
      SOURCE #numeralsToTxt_EN
        #static TempStr numeralsToTxt_EN(real _num)
        #{
        #    int     numOfPennies = (decRound(frac(_num), 2) * 100) mod 100;
        #    real    test         = _num - frac(_num);
        #
        #    int64   numOfTenths;
        #    str 20  ones[19], tenths[9], hundreds, thousands, millions, billions, trillions;
        #
        #    int64   temp;
        #    str 200 returntxt;
        #    int64   testLoc;
        #
        #    real modOperator(real a1, real a2)
        #    {
        #    int tmpi;
        #    real tmp1, tmp2;
        #    tmp1 = a1 / a2;
        #    tmpi = real2int(tmp1);
        #    tmp2 = tmpi;
        #    return (tmp1 - tmp2)*a2;
        #    }
        #
        #    real checkPower(real  _test, int64 _power)
        #    {
        #        int64   numOfPower;
        #
        #        if (_test >= _power)
        #        {
        #            testLoc = real2double(_test);
        #            numOfPower = testLoc div _power;
        #            if (numOfPower >= 100)
        #            {
        #                temp = numOfPower div 100;
        #                returntxt = returntxt + ' ' + ones[temp] + ' ' + hundreds;
        #                numOfPower = numOfPower mod 100;
        #            }
        #            if (numOfPower >= 20)
        #            {
        #                temp = numOfPower div 10;
        #                returntxt = returntxt + ' ' + tenths[temp];
        #                numOfPower = numOfPower mod 10;
        #            }
        #            if (numOfPower >= 1)
        #            {
        #                returntxt = returntxt + ' ' + ones[numOfPower];
        #                numOfPower = numOfPower mod 10;
        #            }
        #            switch(_power)
        #            {
        #                case 1000000000000 :
        #                    returntxt = returntxt + ' ' + trillions;
        #                    _test = modOperator(_test, 1000000000000.00);
        #                    break;
        #                case 1000000000 :
        #                    returntxt = returntxt + ' ' + billions;
        #                    _test = modOperator(_test, 1000000000);
        #                    break;
        #                case 1000000 :
        #                    returntxt = returntxt + ' ' + millions;
        #                    _test = modOperator(_test, 1000000);
        #                    break;
        #                case 1000 :
        #                    returntxt = returntxt + ' ' + thousands;
        #                    _test = modOperator(_test, 1000);
        #                    break;
        #                case 100 :
        #                    returntxt = returntxt + ' ' + hundreds;
        #                    _test = modOperator(_test, 100);
        #                    break;
        #            }
        #        }
        #        return _test;
        #    }
        #
        #    #Define.text_1('One')
        #    #Define.text_2('Two')
        #    #Define.text_3('Three')
        #    #Define.text_4('Four')
        #    #Define.text_5('Five')
        #    #Define.text_6('Six')
        #    #Define.text_7('Seven')
        #    #Define.text_8('Eight')
        #    #Define.text_9('Nine')
        #    #Define.text_10('Ten')
        #    #Define.text_11('Eleven')
        #    #Define.text_12('Twelve')
        #    #Define.text_13('Thirteen')
        #    #Define.text_14('Fourteen')
        #    #Define.text_15('Fifteen')
        #    #Define.text_16('Sixteen')
        #    #Define.text_17('Seventeen')
        #    #Define.text_18('Eighteen')
        #    #Define.text_19('Nineteen')
        #    #Define.text_20('Twenty')
        #    #Define.text_30('Thirty')
        #    #Define.text_40('Forty')
        #    #Define.text_50('Fifty')
        #    #Define.text_60('Sixty')
        #    #Define.text_70('Seventy')
        #    #Define.text_80('Eighty')
        #    #Define.text_90('Ninety')
        #    #Define.text_100('Hundred')
        #    #Define.text_1000('Thousand')
        #    #Define.text_1000000('Million')
        #    #Define.text_1000000000('Billion')
        #    #Define.text_1000000000000('Trillion')
        #    #Define.text_and('and')
        #
        #    ones[1] = #text_1;
        #    ones[2] = #text_2;
        #    ones[3] = #text_3;
        #    ones[4] = #text_4;
        #    ones[5] = #text_5;
        #    ones[6] = #text_6;
        #    ones[7] = #text_7;
        #    ones[8] = #text_8;
        #    ones[9] = #text_9;
        #    ones[10] = #text_10;
        #    ones[11] = #text_11;
        #    ones[12] = #text_12;
        #    ones[13] = #text_13;
        #    ones[14] = #text_14;
        #    ones[15] = #text_15;
        #    ones[16] = #text_16;
        #    ones[17] = #text_17;
        #    ones[18] = #text_18;
        #    ones[19] = #text_19;
        #
        #    tenths[1] = 'Not used';
        #    tenths[2] = #text_20;
        #    tenths[3] = #text_30;
        #    tenths[4] = #text_40;
        #    tenths[5] = #text_50;
        #    tenths[6] = #text_60;
        #    tenths[7] = #text_70;
        #    tenths[8] = #text_80;
        #    tenths[9] = #text_90;
        #
        #    hundreds    = #text_100;
        #    thousands   = #text_1000;
        #    millions    = #text_1000000;
        #    billions    = #text_1000000000;
        #    trillions   = #text_1000000000000;
        #
        #
        #    test = checkPower(test, 1000000000000);
        #    test = checkPower(test, 1000000000);
        #    test = checkPower(test, 1000000);
        #    test = checkPower(test, 1000);
        #    test = checkPower(test, 100);
        #
        #    if (test >= 20)
        #    {
        #        testLoc = real2double(test);
        #        numOfTenths = testLoc div 10;
        #        returntxt = returntxt + ' ' + tenths[numofTenths];
        #        numOfTenths = numOfTenths mod 10;
        #        test = real2int(test) mod 10;
        #    }
        #    if (test >= 1)
        #    {
        #        numOfTenths = real2int(test);
        #        returntxt = returntxt + ' ' + ones[numOfTenths];
        #    }
        #
        #    if (numOfPennies)
        #    {
        #        returntxt = '***' + returntxt + ' ' + #text_and + ' ' + num2str(numOfPennies,0,0,0,0) + '/100';
        #    }
        #    else
        #    {
        #        returntxt = '***' + returntxt + ' ' + #text_and + ' ' + '00/100';
        #    }
        #
        #    return returntxt;
        #}
      ENDSOURCE
      SOURCE #numeralsToTxt_ES
        #static TempStr numeralsToTxt_ES(real             _num,
        #                                GenderMaleFemale _gender          = GenderMaleFemale::Female,
        #                                boolean          _enclose         = true,
        #                                CurrencyCodeISO  _currencyCodeISO = '',
        #                                boolean          _isMexican       = false,
        #                                boolean          _isCheck         = false)
        #{
        #    int     numOfPennies = (decRound(frac(_num), 2) * 100) mod 100;
        #    real    test         = _num - frac(_num);
        #    real    auxtest = 0;
        #
        #    real    numOfTenths ;
        #    str 20  ones[19], twenties[9], tenths[9], muchhundreds, hundreds, thousands, muchmillions, millions, billions, muchhunmillions, trillions, muchtrillions;
        #
        #    str 200 returntxt;
        #
        #    str     cpStr;
        #    int64   cpInt;
        #
        #    #Define.text_1_male('Uno')
        #    #Define.text_1_female('Una')
        #    #Define.text_2('Dos')
        #    #Define.text_3('Tres')
        #    #Define.text_4('Cuatro')
        #    #Define.text_5('Cinco')
        #    #Define.text_6('Seis')
        #    #Define.text_7('Siete')
        #    #Define.text_8('Ocho')
        #    #Define.text_9('Nueve')
        #    #Define.text_10('Diez')
        #    #Define.text_11('Once')
        #    #Define.text_12('Doce')
        #    #Define.text_13('Trece')
        #    #Define.text_14('Catorce')
        #    #Define.text_15('Quince')
        #    #Define.text_16('Dieciseis')
        #    #Define.text_17('Diecisiete')
        #    #Define.text_18('Dieciocho')
        #    #Define.text_19('Diecinueve')
        #
        #    #Define.text_20('Veinte')
        #
        #    #Define.text_21_female('Veintiuna')
        #    #Define.text_21_male('Veintiun')
        #    #Define.text_22('Veintidos')
        #    #Define.text_23('Veintitres')
        #    #Define.text_24('Veinticuatro')
        #    #Define.text_25('Veinticinco')
        #    #Define.text_26('Veintiseis')
        #    #Define.text_27('Veintisiete')
        #    #Define.text_28('Veintiocho')
        #    #Define.text_29('Veintinueve')
        #
        #    #Define.text_30('Treinta')
        #    #Define.text_40('Cuarenta')
        #    #Define.text_50('Cincuenta')
        #    #Define.text_60('Sesenta')
        #    #Define.text_70('Setenta')
        #    #Define.text_80('Ochenta')
        #    #Define.text_90('Noventa')
        #
        #    #Define.text_100('Cien')
        #    #Define.text_100_female('cientas')
        #    #Define.text_100_male('cientos')
        #    #Define.text_100_much('Cientos')
        #    #Define.text_100_begin('Ciento')
        #
        #    #Define.text_500_female('Quinientas')
        #    #Define.text_500_male('Quinientos')
        #
        #    #Define.text_7_begin('Sete')
        #    #Define.text_9_begin('Nove')
        #
        #    #Define.text_1000('Mil')
        #
        #    #Define.text_1000000('Millon')
        #    #Define.text_1000000_much('Millones')
        #    #Define.text_1000000000('Mil millones')
        #    #Define.text_1000000000000('Trillón')
        #    #Define.text_1000000000000_much('Trillónes')
        #
        #    #Define.text_and('y')
        #    #Define.text_with('con')
        #
        #    #Define.text_cents_GBP(' peniques')
        #    #Define.text_cents_USD(' centavos')
        #    #Define.text_cents_EUR(' centimos')
        #
        #    #Define.currencyCodeISO_UK('GBP')
        #    #Define.currencyCodeISO_USA('USD')
        #
        #    #Define.text_print_entire_cents('00/100')
        #    #Define.text_print_cents('/100')
        #    #Define.text_pesos('pesos')
        #
        #    str centsName()
        #    {
        #        str 9 centText;
        #        switch (_currencyCodeISO)
        #        {
        #            case #currencyCodeISO_UK:
        #                centText = #text_cents_GBP;
        #                break;
        #            case #currencyCodeISO_USA:
        #                centText = #text_cents_USD;
        #                break;
        #            default:
        #                centText = #text_cents_EUR;
        #        }
        #        return centText;
        #    }
        #
        #    ones[1] = #text_1_male;
        #    ones[2] = #text_2;
        #    ones[3] = #text_3;
        #    ones[4] = #text_4;
        #    ones[5] = #text_5;
        #    ones[6] = #text_6;
        #    ones[7] = #text_7;
        #    ones[8] = #text_8;
        #    ones[9] = #text_9;
        #    ones[10] = #text_10;
        #    ones[11] = #text_11;
        #    ones[12] = #text_12;
        #    ones[13] = #text_13;
        #    ones[14] = #text_14;
        #    ones[15] = #text_15;
        #    ones[16] = #text_16;
        #    ones[17] = #text_17;
        #    ones[18] = #text_18;
        #    ones[19] = #text_19;
        #
        #    twenties[1] = _gender == GenderMaleFemale::Female ? #text_21_female: #text_21_male;
        #    twenties[2] = #text_22;
        #    twenties[3] = #text_23;
        #    twenties[4] = #text_24;
        #    twenties[5] = #text_25;
        #    twenties[6] = #text_26;
        #    twenties[7] = #text_27;
        #    twenties[8] = #text_28;
        #    twenties[9] = #text_29;
        #
        #    tenths[1] = ''; // Not used
        #    tenths[2] = #text_20;
        #    tenths[3] = #text_30;
        #    tenths[4] = #text_40;
        #    tenths[5] = #text_50;
        #    tenths[6] = #text_60;
        #    tenths[7] = #text_70;
        #    tenths[8] = #text_80;
        #    tenths[9] = #text_90;
        #
        #    hundreds    = #text_100;
        #
        #    muchhundreds = _gender == GenderMaleFemale::Female ? #text_100_female: #text_100_male;
        #
        #    muchhunmillions = #text_100_much;
        #
        #    thousands   = #text_1000;
        #    millions    = #text_1000000;
        #    muchmillions = #text_1000000_much;
        #
        #    billions    = #text_1000000000;
        #    trillions   = #text_1000000000000;
        #    muchtrillions = #text_1000000000000_much;
        #
        #    [cpInt, cpStr] = Global::checkPower(any2int64(test), 1000000000000, _gender, _isMexican);
        #    test = str2num(int642str(cpInt));
        #    if (cpStr)
        #    {
        #        returntxt = returntxt + ' ' + cpStr;
        #    }
        #
        #    [cpInt, cpStr] = Global::checkPower(any2int64(test), 1000000000, _gender, _isMexican);
        #    test = str2num(int642str(cpInt));
        #    if (cpStr)
        #    {
        #        returntxt = returntxt + ' ' + cpStr;
        #    }
        #
        #    [cpInt, cpStr] = Global::checkPower(any2int64(test), 1000000, _gender, _isMexican);
        #    test = str2num(int642str(cpInt));
        #    if (cpStr)
        #    {
        #        returntxt = returntxt + ' ' + cpStr;
        #    }
        #
        #    [cpInt, cpStr] = Global::checkPower(any2int64(test), 1000, _gender, _isMexican);
        #    test = str2num(int642str(cpInt));
        #    if (cpStr)
        #    {
        #        returntxt = returntxt + ' ' + cpStr;
        #    }
        #
        #    [cpInt, cpStr] = Global::checkPower(any2int64(test), 100, _gender, _isMexican);
        #    test = str2num(int642str(cpInt));
        #    if (cpStr)
        #    {
        #        returntxt = returntxt + ' ' + cpStr;
        #    }
        #
        #    if (test >= 20)
        #    {
        #        numOfTenths = real2int(test) div 10;
        #        if (test > 20 && test < 30)
        #        {
        #            returntxt = returntxt + ' ' + twenties[test-20];
        #        }
        #        else
        #        {
        #            returntxt = returntxt + ' ' + tenths[numofTenths];
        #        }
        #        numOfTenths = real2int(numOfTenths) mod 10;
        #        auxtest = test;
        #        test = real2int(test) mod 10;
        #    }
        #
        #    if ((test >= 1) && !(auxtest > 20 && auxtest < 30))
        #    {
        #        numOfTenths = test;
        #        if (numOfTenths == 1)
        #        {
        #            if (auxtest == 0)
        #            {
        #                returntxt = returntxt + ' ' + (_gender == GenderMaleFemale::Female ? #text_1_female : #text_1_male);
        #            }
        #            else
        #            {
        #                returntxt = returntxt + ' ' + #text_and + ' ' + (_gender == GenderMaleFemale::Female ? #text_1_female : #text_1_male);
        #            }
        #        }
        #        else
        #        {
        #            if (( auxtest > 20 ))
        #            {
        #               returntxt = returntxt + ' ' + #text_and + ' ' + ones[numOfTenths];
        #            }
        #            else
        #            {
        #               returntxt = returntxt + ' ' + ones[numOfTenths];
        #            }
        #        }
        #    }
        #
        #    auxtest = 0;
        #
        #    if (_isMexican)
        #    {
        #        if (_isCheck) //For checks, need to insert pesos into the string.
        #        {
        #            if (numOfPennies < 0.5)
        #            {
        #                returntxt = returntxt + ' ' + #text_pesos + ' ' + #text_print_entire_cents;
        #            }
        #            else
        #            {
        #                if (numOfPennies >= 0.5 && numOfPennies < 9.5)
        #                {
        #                    returntxt = returntxt + ' ' + #text_pesos + ' 0' + num2str(numOfPennies,1,0,1,0) + #text_print_cents;
        #                }
        #                else
        #                {
        #                    returntxt = returntxt + ' ' + #text_pesos + ' ' + num2str(numOfPennies,2,0,1,0) + #text_print_cents;
        #                }
        #            }
        #
        #            returntxt = strUpr(subStr(returntxt, 1, 2)) + strLwr(subStr(returntxt, 3, strLen(returntxt) - 2));
        #
        #            if(_enclose)
        #            {
        #                returntxt = '***' + returntxt + '***' ;
        #            }
        #        }
        #        else
        #        {
        #            if (numOfPennies < 0.5)
        #            {
        #                returntxt = returntxt + ' ' + #text_print_entire_cents;
        #            }
        #            else
        #            {
        #                if (numOfPennies >= 0.5 && numOfPennies < 9.5)
        #                {
        #                    returntxt = returntxt + ' 0' + num2str(numOfPennies,1,0,1,0) + #text_print_cents;
        #                }
        #                else
        #                {
        #                    returntxt = returntxt + ' ' + num2str(numOfPennies,2,0,1,0) + #text_print_cents;
        #                }
        #            }
        #
        #            returntxt = strUpr(subStr(returntxt, 1, 2)) + strLwr(subStr(returntxt, 3, strLen(returntxt) - 2));
        #
        #            if(_enclose)
        #            {
        #                returntxt = '***' + returntxt + '***' ;
        #            }
        #        }
        #    }
        #    else
        #    {
        #        if (numOfPennies)
        #        {
        #            returntxt = strUpr(returntxt) + ' ' + #text_with + strUpr(numeralsToTxt_ES(numOfPennies, GenderMaleFemale::Male, false))+ centsName();
        #        }
        #        if(_enclose)
        #        {
        #            returntxt = '***' + strUpr(returntxt) + '***';
        #        }
        #    }
        #
        #    if (subStr(returntxt, 1, 4) == '*** ')
        #    {
        #        returntxt = strDel(returntxt, 4, 1);
        #    }
        #    if (subStr(returntxt, strLen(returntxt)-3, 4) == ' ***')
        #    {
        #        returntxt = strDel(returntxt, strLen(returntxt) -3,1);
        #    }
        #
        #    return returntxt;
        #}
      ENDSOURCE
      SOURCE #numeralsToTxt_FR
        #static TempStr numeralsToTxt_FR(real _num, boolean _isFrenchCheck = false)
        #{
        #    int     numOfPennies = (decRound(frac(_num), 2) * 100) mod 100;
        #    real    test         = _num - frac(_num);
        #
        #    int64   numOfTens, seventyNum, ninetyNum;
        #    str 25  ones[19], tens[9], seventies[9], nineties[9];
        #    str 10  zero, hundred, hundreds, thousands, million, millions, billion, billions, trillion, trillions;
        #
        #    str 2   pennies;
        #    str 5   currency;
        #
        #    int64   temp;
        #    str 200 returntxt;
        #    int64   testLoc;
        #
        #    #Define.euro('euro')
        #    #Define.euros('euros')
        #    #Define.text_0('Zéro')
        #    #Define.text_1('Un')
        #    #Define.text_2('Deux')
        #    #Define.text_3('Trois')
        #    #Define.text_4('Quatre')
        #    #Define.text_5('Cinq')
        #    #Define.text_6('Six')
        #    #Define.text_7('Sept')
        #    #Define.text_8('Huit')
        #    #Define.text_9('Neuf')
        #    #Define.text_10('Dix')
        #    #Define.text_11('Onze')
        #    #Define.text_12('Douze')
        #    #Define.text_13('Treize')
        #    #Define.text_14('Quatorze')
        #    #Define.text_15('Quinze')
        #    #Define.text_16('Seize')
        #    #Define.text_17('Dix-Sept')
        #    #Define.text_18('Dix-Huit')
        #    #Define.text_19('Dix-Neuf')
        #    #Define.text_20('Vingt')
        #    #Define.text_30('Trente')
        #    #Define.text_40('Quarante')
        #    #Define.text_50('Cinquante')
        #    #Define.text_60('Soixante')
        #    #Define.text_70('Soixante-Dix')
        #    #Define.text_71('Soixante Et Onze')
        #    #Define.text_72('Soixante-Douze')
        #    #Define.text_73('Soixante-Treize')
        #    #Define.text_74('Soixante-Quatorze')
        #    #Define.text_75('Soixante-Quinze')
        #    #Define.text_76('Soixante-Seize')
        #    #Define.text_77('Soixante-Dix-Sept')
        #    #Define.text_78('Soixante-Dix-Huit')
        #    #Define.text_79('Soixante-Dix-Neuf')
        #    #Define.text_80('Quatre-Vingts')
        #    #Define.text_81('Quatre-Vingt-Un')
        #    #Define.text_80s('Quatre-Vingt')
        #    #Define.text_90('Quatre-Vingt-Dix')
        #    #Define.text_91('Quatre-Vingt-Onze')
        #    #Define.text_92('Quatre-Vingt-Douze')
        #    #Define.text_93('Quatre-Vingt-Treize')
        #    #Define.text_94('Quatre-Vingt-Quatorze')
        #    #Define.text_95('Quatre-Vingt-Quinze')
        #    #Define.text_96('Quatre-Vingt-Seize')
        #    #Define.text_97('Quatre-Vingt-Dix-Sept')
        #    #Define.text_98('Quatre-Vingt-Dix-Huit')
        #    #Define.text_99('Quatre-Vingt-Dix-Neuf')
        #    #Define.text_100('Cent')
        #    #Define.text_100s('Cents')
        #    #Define.text_1000('Mille')
        #    #Define.text_1000000('Million')
        #    #Define.text_1000000s('Millions')
        #    #Define.text_1000000000('Millard')
        #    #Define.text_1000000000s('Millards')
        #    #Define.text_1000000000000('Trillion')
        #    #Define.text_1000000000000s('Trillions')
        #    #Define.text_and('Et')
        #    #Define.text_cents('Cts')
        #
        #
        #    real modOperator(real a1, real a2)
        #    {
        #        int  tmpi;
        #        real tmp1, tmp2;
        #        tmp1 = a1 / a2;
        #        tmpi = real2int(tmp1);
        #        tmp2 = tmpi;
        #        return (tmp1 - tmp2)*a2;
        #    }
        #
        #    str 25 buildHundredString(real _number, int64 _power)
        #    {
        #        str 25      hundredStrTxt;
        #        boolean     use_And = false;
        #        ;
        #
        #        // 90-99
        #        if (_number >= 90 && _number <= 99)
        #        {
        #            ninetyNum = real2int(_number) mod 90;
        #            if (ninetyNum != 0)
        #            {
        #                hundredStrTxt = hundredStrTxt + ' ' + nineties[ninetyNum];
        #            }
        #            else
        #            {
        #                numOfTens = real2int(_number) div 10;
        #                hundredStrTxt = hundredStrTxt + ' ' + tens[numOfTens];
        #            }
        #            _number = 0;
        #        }
        #
        #        // 81
        #        if (_number == 81)
        #        {
        #            hundredStrTxt = hundredStrTxt + ' ' + #text_81;
        #            _number = 0;
        #        }
        #
        #        // 80
        #        if (_number == 80)
        #        {
        #            hundredStrTxt = hundredStrTxt + ' ' + #text_80;
        #            _number = 0;
        #        }
        #
        #        // 70-79
        #        if (_number >= 70 && _number <= 79)
        #        {
        #            seventyNum = real2int(_number) mod 70;
        #            if (seventyNum != 0)
        #            {
        #                hundredStrTxt = hundredStrTxt + ' ' + seventies[seventyNum];
        #            }
        #            else
        #            {
        #                numOfTens = _number / 10;
        #                hundredStrTxt = hundredStrTxt + ' ' + tens[numOfTens];
        #            }
        #            _number = 0;
        #        }
        #
        #        // 20-69, 82-89
        #        if (_number >= 20)
        #        {
        #            numOfTens = _number / 10;
        #            hundredStrTxt = hundredStrTxt + ' ' + tens[numOfTens];
        #            numOfTens = numOfTens mod 10;
        #            _number = real2int(_number) mod 10;
        #
        #            if (_number >= 2 && _number <= 9)
        #            {
        #                hundredStrTxt = hundredStrTxt + '-';
        #            }
        #
        #            if (_number == 1)
        #            {
        #                use_And = true;
        #            }
        #        }
        #
        #        // 2-19
        #        if (_number >= 2)
        #        {
        #            numOfTens = real2int(_number);
        #
        #            // If the last character in the hundredStrTxt string is a '-'
        #            if (strCmp(subStr(hundredStrTxt, strLen(hundredStrTxt), 1), '-') == 0)
        #            {
        #                hundredStrTxt = hundredStrTxt + ones[numOfTens];
        #            }
        #            else
        #            {
        #                hundredStrTxt = hundredStrTxt + ' ' + ones[numOfTens];
        #            }
        #        }
        #
        #        // 1
        #        if (_number == 1 && (_power != 100))
        #        {
        #            if (use_And)
        #            {
        #                hundredStrTxt = hundredStrTxt + ' ' + #text_and + ' ' + #text_1;
        #            }
        #            else
        #            {
        #                hundredStrTxt = hundredStrTxt + ' ' + #text_1;
        #            }
        #        }
        #
        #        // 0
        #        // Only print 'Zero' if no other non-penny number has been printed
        #        if ((_number == 0) && (_power == 0) && (returntxt == "") && (hundredStrTxt == ""))
        #        {
        #            hundredStrTxt = hundredStrTxt + ' ' + #text_0;
        #        }
        #
        #        return hundredStrTxt;
        #    }
        #
        #    real checkPower(real  _test, int64 _power)
        #    {
        #        int64   numOfPower;
        #
        #        if (_test >= _power)
        #        {
        #            // Build the 'over one hundred' portion of the string for each power
        #            testLoc = real2double(_test);
        #            numOfPower = testLoc div _power;
        #            if (numOfPower >= 100)
        #            {
        #                temp = numOfPower div 100;
        #                // If it is 'Cent', no 'Un' is needed
        #                if (temp == 1)
        #                {
        #                    returntxt = returntxt + ' ' + hundred;
        #                }
        #                else
        #                {
        #                    returntxt = returntxt + ' ' + ones[temp] + ' ' + hundred;
        #                }
        #                numOfPower = numOfPower mod 100;
        #            }
        #
        #            // Make sure that 'un' isn't printed in front of 'mille' for numbers such as 3001000 or 1000
        #            if ( !((real2int(_test / _power) == 1) && (_power == 1000)) )
        #            {
        #                // Build the 'under one hundred' portion of the string for each power
        #                returntxt = returntxt + buildHundredString(any2real(numOfPower), _power);
        #            }
        #
        #            switch(_power)
        #            {
        #                case 1000000000000 :    // Trillion
        #                {
        #                    if ((_test / _power) == 1)
        #                    {
        #                        returntxt = returntxt + ' ' + trillion;
        #                    }
        #                    else
        #                    {
        #                        returntxt = returntxt + ' ' + trillions;
        #                    }
        #                    _test = modOperator(_test, 1000000000000.00);
        #                    break;
        #                }
        #                case 1000000000 :       // Billion
        #                {
        #                    if ((_test / _power) == 1)
        #                    {
        #                        returntxt = returntxt + ' ' + billion;
        #                    }
        #                    else
        #                    {
        #                        returntxt = returntxt + ' ' + billions;
        #                    }
        #                    _test = modOperator(_test, 1000000000);
        #                    break;
        #                }
        #                case 1000000 :          // Million
        #                {
        #                    if ((_test / _power) == 1)
        #                    {
        #                        returntxt = returntxt + ' ' + million;
        #                    }
        #                    else
        #                    {
        #                        returntxt = returntxt + ' ' + millions;
        #                    }
        #                    _test = modOperator(_test, 1000000);
        #                    break;
        #                }
        #                case 1000 :             // Thousands
        #                {
        #                    returntxt = returntxt + ' ' + thousands;
        #                    _test = modOperator(_test, 1000);
        #                    break;
        #                }
        #                case 100 :              // Hundreds
        #                {
        #                    if ((real2int(test) mod 100 == 0) && (numOfPower != 1))
        #                    {
        #                        returntxt = returntxt + ' ' + hundreds;
        #                    }
        #                    else
        #                    {
        #                        returntxt = returntxt + ' ' + hundred;
        #                    }
        #                    _test = modOperator(_test, 100);
        #                    break;
        #                }
        #            }
        #        }
        #        return _test;
        #    }
        #
        #    ones[1] = #text_1;
        #    ones[2] = #text_2;
        #    ones[3] = #text_3;
        #    ones[4] = #text_4;
        #    ones[5] = #text_5;
        #    ones[6] = #text_6;
        #    ones[7] = #text_7;
        #    ones[8] = #text_8;
        #    ones[9] = #text_9;
        #    ones[10] = #text_10;
        #    ones[11] = #text_11;
        #    ones[12] = #text_12;
        #    ones[13] = #text_13;
        #    ones[14] = #text_14;
        #    ones[15] = #text_15;
        #    ones[16] = #text_16;
        #    ones[17] = #text_17;
        #    ones[18] = #text_18;
        #    ones[19] = #text_19;
        #
        #    tens[1] = 'Not used';
        #    tens[2] = #text_20;
        #    tens[3] = #text_30;
        #    tens[4] = #text_40;
        #    tens[5] = #text_50;
        #    tens[6] = #text_60;
        #    tens[7] = #text_70;
        #    tens[8] = #text_80s;
        #    tens[9] = #text_90;
        #
        #    seventies[1] = #text_71;
        #    seventies[2] = #text_72;
        #    seventies[3] = #text_73;
        #    seventies[4] = #text_74;
        #    seventies[5] = #text_75;
        #    seventies[6] = #text_76;
        #    seventies[7] = #text_77;
        #    seventies[8] = #text_78;
        #    seventies[9] = #text_79;
        #
        #    nineties[1] = #text_91;
        #    nineties[2] = #text_92;
        #    nineties[3] = #text_93;
        #    nineties[4] = #text_94;
        #    nineties[5] = #text_95;
        #    nineties[6] = #text_96;
        #    nineties[7] = #text_97;
        #    nineties[8] = #text_98;
        #    nineties[9] = #text_99;
        #
        #    zero        = #text_0;
        #    hundred     = #text_100;
        #    hundreds    = #text_100s;
        #    thousands   = #text_1000;
        #    million     = #text_1000000;
        #    millions    = #text_1000000s;
        #    billion     = #text_1000000000;
        #    billions    = #text_1000000000s;
        #    trillion    = #text_1000000000000;
        #    trillions   = #text_1000000000000s;
        #
        #
        #    // Builds the string from the highest power digits on down, returntxt is updated in each call
        #    //  Note: These must be called in decreasing order of powers
        #    test = checkPower(test, 1000000000000);
        #    test = checkPower(test, 1000000000);
        #    test = checkPower(test, 1000000);
        #    test = checkPower(test, 1000);
        #    test = checkPower(test, 100);
        #
        #    returntxt = strLTrim(returntxt) + buildHundredString(test, 0);
        #
        #    if(_isFrenchCheck)
        #    {
        #        if (_num < 2)
        #        {
        #            currency = #euro;
        #        }
        #        else
        #        {
        #            currency = #euros;
        #        }
        #    }
        #
        #    // Adds on the penny portion of the string
        #    if (numOfPennies)
        #    {
        #        if(_isFrenchCheck)
        #        {
        #            pennies =  num2str(numOfPennies,0,0,0,0);
        #            if (strLen(pennies) == 1)
        #            {
        #                pennies = int2str(0) + pennies;
        #            }
        #
        #            returntxt = '*' + returntxt + ' ' + currency + ' ' + #text_and + ' ' + pennies + ' ' +  #text_cents + '*';
        #        }
        #        else
        #        {
        #            returntxt = '***' + returntxt + ' ' + #text_and + ' ' + num2str(numOfPennies,0,0,0,0) + '/100';
        #        }
        #    }
        #    else
        #    {
        #        if(_isFrenchCheck)
        #        {
        #            returntxt = '*' + returntxt + ' ' + currency + '*' ;
        #        }
        #        else
        #        {
        #            returntxt = '***' + returntxt + ' ' + #text_and + ' ' + '00/100';
        #        }
        #    }
        #
        #    if(_isFrenchCheck)
        #    {
        #        return strUpr(returntxt);
        #    }
        #    else
        #    {
        #        return returntxt;
        #    }
        #}
      ENDSOURCE
      SOURCE #numeralsToTxt_IN
        #/// <summary>
        #/// Convert numerals to Hindi format text.
        #/// </summary>
        #/// <param name="_num">
        #/// The numeral to be converted.
        #/// </param>
        #/// <returns>
        #/// The converted string.
        #/// </returns>
        #static TempStr numeralsToTxt_IN(real _num)
        #{
        #    int     numOfPennies = (decRound(frac(_num), 2) * 100) mod 100;
        #    real    amount         = _num - frac(_num);
        #    int     numOfTenths;
        #    str 20  ones[19], tenths[9], hundreds, thousands, millions, billions, trillions;
        #
        #    int64   temp;
        #    str 200 returntxt;
        #    boolean checkStatus = false;
        #    #define.paise("paise")
        #
        #    real modOperator(real a1, real a2)
        #    {
        #    int tmpi;
        #    real tmp1, tmp2;
        #    tmp1 = a1 / a2;
        #    tmpi = real2int(tmp1);
        #    tmp2 = tmpi;
        #    return (tmp1 - tmp2)*a2;
        #    }
        #
        #    real checkPower(real  _amount, int64 _power)
        #    {
        #        int64   numOfPower;
        #
        #        if (_amount >= _power)
        #        {
        #            numOfPower = real2int(_amount) div _power;
        #            if (numOfPower >= 100)
        #            {
        #                temp = numOfPower div 100;
        #                returntxt = returntxt + ' ' + ones[temp] + ' ' + hundreds;
        #                numOfPower = numOfPower mod 100;
        #            }
        #            if (numOfPower >= 20)
        #            {
        #                temp = numOfPower div 10;
        #                returntxt = returntxt + ' ' + tenths[temp];
        #                numOfPower = numOfPower mod 10;
        #            }
        #            if (numOfPower >= 1)
        #            {
        #                returntxt = returntxt + ' ' + ones[numOfPower];
        #                numOfPower = numOfPower mod 10;
        #            }
        #            switch(_power)
        #            {
        #                case 1000000000000:
        #                    returntxt = returntxt + ' ' + trillions;
        #                    _amount = modOperator(_amount, 1000000000000.00);
        #                    break;
        #                case 1000000000:
        #                    returntxt = returntxt + ' ' + billions;
        #                    _amount = modOperator(_amount, 1000000000);
        #                    break;
        #                case 1000000:
        #                    returntxt = returntxt + ' ' + millions;
        #                    _amount = modOperator(_amount, 1000000);
        #                    break;
        #                case 1000:
        #                    returntxt = returntxt + ' ' + thousands;
        #                    _amount = modOperator(_amount, 1000);
        #                    break;
        #                case 100:
        #                    returntxt = returntxt + ' ' + hundreds;
        #                    _amount = modOperator(_amount, 100);
        #                    break;
        #                default:
        #                    break;
        #            }
        #        }
        #        return _amount;
        #    }
        #
        #    ;
        #
        #    ones[1] = "@SYS26620";
        #    ones[2] = "@SYS26621";
        #    ones[3] = "@SYS26622";
        #    ones[4] = "@SYS26626";
        #    ones[5] = "@SYS26627";
        #    ones[6] = "@SYS26628";
        #    ones[7] = "@SYS26629";
        #    ones[8] = "@SYS26630";
        #    ones[9] = "@SYS26631";
        #    ones[10] = "@SYS26632";
        #    ones[11] = "@SYS26633";
        #    ones[12] = "@SYS26634";
        #    ones[13] = "@SYS26635";
        #    ones[14] = "@SYS26636";
        #    ones[15] = "@SYS26637";
        #    ones[16] = "@SYS26638";
        #    ones[17] = "@SYS26639";
        #    ones[18] = "@SYS26640";
        #    ones[19] = "@SYS26641";
        #
        #    tenths[1] = 'Not used';
        #    tenths[2] = "@SYS26643";
        #    tenths[3] = "@SYS26644";
        #    tenths[4] = "@SYS26645";
        #    tenths[5] = "@SYS26646";
        #    tenths[6] = "@SYS26647";
        #    tenths[7] = "@SYS26648";
        #    tenths[8] = "@SYS26649";
        #    tenths[9] = "@SYS26650";
        #
        #    hundreds    = "@SYS26651";
        #    thousands   = "@SYS26652";
        #    millions    = "@SYS26653";
        #    billions    = "@SYS26654";
        #    trillions   = "@SYS101697";
        #
        #
        #    amount = checkPower(amount, 1000000000000);
        #    amount = checkPower(amount, 1000000000);
        #    amount = checkPower(amount, 1000000);
        #    amount = checkPower(amount, 1000);
        #    amount = checkPower(amount, 100);
        #
        #    if (amount >= 20)
        #    {
        #        numOfTenths = real2int(amount) div 10;
        #        returntxt = returntxt + ' ' + tenths[numofTenths];
        #        numOfTenths = numOfTenths mod 10;
        #        amount = real2int(amount) mod 10;
        #    }
        #    if (amount >= 1)
        #    {
        #        numOfTenths = real2int(amount);
        #        returntxt = returntxt + ' ' + ones[numOfTenths];
        #    }
        #
        #    if (numOfPennies >= 20)
        #    {
        #        numOfTenths = numOfPennies div 10;
        #        returntxt =  returntxt + ' '+"@SYS5534" +' '+ tenths[numofTenths];
        #        numOfTenths = numOfTenths mod 10;
        #        numOfPennies = numOfPennies mod 10;
        #        checkStatus = true;
        #    }
        #    if (numOfPennies >= 1)
        #    {
        #        numOfTenths = real2int(numOfPennies);
        #        returntxt = checkStatus == true ? returntxt + ' ' + ones[numOfTenths] : returntxt + ' '+"@SYS5534" +' ' + ones[numOfTenths];
        #        checkStatus = true;
        #    }
        #    if (numOfPennies == 0 && !checkStatus)
        #    {
        #        returntxt = returntxt + ' ' + "@SYS5534"+' '+"@SYS2068";
        #    }
        #
        #    return   returntxt + ' ' + #paise;
        #
        #}
      ENDSOURCE
      SOURCE #numeralsToTxt_NL
        #static TempStr numeralsToTxt_NL(real _num, boolean _enclose = true)
        #{
        #    /*
        #        Given a real number, this function will round the decimal places to 2 decimal places,
        #        translate that number into Dutch and return that value.  Negative numbers will
        #        return the traslation for the positive number (absolute value).  The maximum
        #        number this function will translate is 999,999,999,999,999.
        #    */
        #    int      numOfPennies = (decRound(frac(abs(_num)), 2) * 100) mod 100;
        #    int64    numbOfDollars = any2int64(abs(_num) - frac(abs(_num)));
        #
        #    int64   temp;
        #    str 300 returntxt;
        #    str 25  lessThan100[99], zero, hundred, thousand, million, billion, trillion, and, hundredth, oneHundredth;
        #    str 1 space;
        #
        #    //Define Macros
        #    #Define.Text0('Nul')                        // 0 - Zero
        #    #Define.Text1('Een')                        // 1 - One
        #    #Define.Text2('Twee')                       // 2 - Two
        #    #Define.Text3('Drie')                       // 3 - Three
        #    #Define.Text4('Vier')                       // 4 - Four
        #    #Define.Text5('Vijf')                       // 5 - Five
        #    #Define.Text6('Zes')                        // 6 - Six
        #    #Define.Text7('Zeven')                      // 7 - Seven
        #    #Define.Text8('Acht')                       // 8 - Eight
        #    #Define.Text9('Negen')                      // 9 - Nine
        #    #Define.Text10('Tien')                      // 10 - Ten
        #    #Define.Text11('Elf')                       // 11 - Eleven
        #    #Define.Text12('Twaalf')                    // 12 - Twelve
        #    #Define.Text13('Dertien')                   // 13 - Thirteen
        #    #Define.Text14('Veertien')                  // 14 - Fourteen
        #    #Define.Text15('Vijftien')                  // 15 - Fifteen
        #    #Define.Text16('Zestien')                   // 16 - Sixteen
        #    #Define.Text17('Zeventien')                 // 17 - Seventeen
        #    #Define.Text18('Achttien')                  // 18 - Eighteen
        #    #Define.Text19('Negentien')                 // 19 - Nineteen
        #    #Define.Text20('Twintig')                   // 20 - Twenty
        #    #Define.Text21('Eenentwintig')              // 21 - Twenty One
        #    #Define.Text22('Tweeëntwintig')             // 22 - Twenty Two
        #    #Define.Text23('Drieëntwintig')             // 23 - Twenty Three
        #    #Define.Text24('Vierentwintig')             // 24 - Twenty Four
        #    #Define.Text25('Vijfentwintig')             // 25 - Twenty Five
        #    #Define.Text26('Zesentwintig')              // 26 - Twenty Six
        #    #Define.Text27('Zevenentwintig')            // 27 - Twenty Seven
        #    #Define.Text28('Achtentwintig')             // 28 - Twenty Eight
        #    #Define.Text29('Negenentwintig')            // 29 - Twenty Nine
        #    #Define.Text30('Dertig')                    // 30 - Thirty
        #    #Define.Text31('Eenendertig')               // 31 - Thirty One
        #    #Define.Text32('Tweeëndertig')              // 32 - Thirty Two
        #    #Define.Text33('Drieëndertig')              // 33 - Thirty Three
        #    #Define.Text34('Vierendertig')              // 34 - Thirty Four
        #    #Define.Text35('Vijfendertig')              // 35 - Thirty Five
        #    #Define.Text36('Zesendertig')               // 36 - Thirty Six
        #    #Define.Text37('Zevenendertig')             // 37 - Thirty Seven
        #    #Define.Text38('Achtendertig')              // 38 - Thirty Eight
        #    #Define.Text39('Negenendertig')             // 39 - Thirty Nine
        #    #Define.Text40('Veertig')                   // 40 - Forty
        #    #Define.Text41('Eenenveertig')              // 41 - Forty One
        #    #Define.Text42('Tweeënveertig')             // 42 - Forty Two
        #    #Define.Text43('Drieënveertig')             // 43 - Forty Three
        #    #Define.Text44('Vierenveertig')             // 44 - Forty Four
        #    #Define.Text45('Vijfenveertig')             // 45 - Forty Five
        #    #Define.Text46('Zesenveertig')              // 46 - Forty Six
        #    #Define.Text47('Zevenenveertig')            // 47 - Forty Sept
        #    #Define.Text48('Achtenveertig')             // 48 - Forty Eight
        #    #Define.Text49('Negenenveertig')            // 49 - Forty Nine
        #    #Define.Text50('Vijftig')                   // 50 - Fifty
        #    #Define.Text51('Eenenvijftig')              // 51 - Fifty One
        #    #Define.Text52('Tweeënvijftig')             // 52 - Fifty Deux
        #    #Define.Text53('Drieënvijftig')             // 53 - Fifty Three
        #    #Define.Text54('Vierenvijftig')             // 54 - Fifty Four
        #    #Define.Text55('Vijfenvijftig')             // 55 - Fifty Five
        #    #Define.Text56('Zesenvijftig')              // 56 - Fifty Six
        #    #Define.Text57('Zevenenvijftig')            // 57 - Fifty Seven
        #    #Define.Text58('Achtenvijftig')             // 58 - Fifty Eight
        #    #Define.Text59('Negenenvijftig')            // 59 - Fifty Nine
        #    #Define.Text60('Zestig')                    // 60 - Sixty
        #    #Define.Text61('Eenenzestig')               // 61 - Sixty One
        #    #Define.Text62('Tweeënzestig')              // 62 - Sixty Two
        #    #Define.Text63('Drieënzestig')              // 63 - Sixty Three
        #    #Define.Text64('Vierenzestig')              // 64 - Sixty Four
        #    #Define.Text65('Vijfenzestig')              // 65 - Sixty Five
        #    #Define.Text66('Zesenzestig')               // 66 - Sixty Six
        #    #Define.Text67('Zevenenzestig')             // 67 - Sixty Seven
        #    #Define.Text68('Achtenzestig')              // 68 - Sixty Eight
        #    #Define.Text69('Negenenzestig')             // 69 - Sixty Nine
        #    #Define.Text70('Zeventig')                  // 70 - Seventy
        #    #Define.Text71('Eenenzeventig')             // 71 - Seventy One
        #    #Define.Text72('Tweeënzeventig')            // 72 - Seventy Two
        #    #Define.Text73('Drieënzeventig')            // 73 - Seventy Three
        #    #Define.Text74('Vierenzeventig')            // 74 - Seventy Four
        #    #Define.Text75('Vijfenzeventig')            // 75 - Seventy Five
        #    #Define.Text76('Zesenzeventig')             // 76 - Seventy Six
        #    #Define.Text77('Zevenenzeventig')           // 77 - Seventy Seven
        #    #Define.Text78('Achtenzeventig')            // 78 - Seventy Eight
        #    #Define.Text79('Negenenzeventig')           // 79 - Seventy Nine
        #    #Define.Text80('Tachtig')                   // 80 - Eighty
        #    #Define.Text81('Eenentachtig')              // 81 - Eighty One
        #    #Define.Text82('Tweeëntachtig')             // 82 - Eighty Two
        #    #Define.Text83('Drieëntachtig')             // 83 - Eighty Three
        #    #Define.Text84('Vierentachtig')             // 84 - Eighty Four
        #    #Define.Text85('Vijfentachtig')             // 85 - Eighty Five
        #    #Define.Text86('Zesentachtig')              // 86 - Eighty Six
        #    #Define.Text87('Zevenentachtig')            // 87 - Eighty Seven
        #    #Define.Text88('Achtentachtig')             // 88 - Eighty Eight
        #    #Define.Text89('Negenentachtig')            // 89 - Eighty Nine
        #    #Define.Text90('Negentig')                  // 90 - Ninety
        #    #Define.Text91('Eenennegentig')             // 91 - Ninety One
        #    #Define.Text92('Tweeënnegentig')            // 92 - Ninety Two
        #    #Define.Text93('Drieënnegentig')            // 93 - Ninety Three
        #    #Define.Text94('Vierennegentig')            // 94 - Ninety Four
        #    #Define.Text95('Vijfennegentig')            // 95 - Ninety Five
        #    #Define.Text96('Zesennegentig')             // 96 - Ninety Six
        #    #Define.Text97('Zevenennegentig')           // 97 - Ninety Seven
        #    #Define.Text98('Achtennegentig')            // 98 - Ninety Eight
        #    #Define.Text99('Negenennegentig')           // 99 - Ninety Nine
        #    #Define.Text100('Honderd')                  // 100 - One Hundred
        #    #Define.Text1000('Duizend')                 // 1000 - One Thousand
        #    #Define.Text1000000('Miljoen')              // 1000000 - Million
        #    #Define.Text1000000000('Miljard')           // 1000000000 - Billion
        #    #Define.Text1000000000000('Triljoen')       // 1000000000000 - Trillion
        #    #Define.TextAnd('En')                       // and
        #    #Define.TextHundredth('Hondersten')         // Hundredths
        #    #Define.TextOneHundredth('Honderste')       // One Hundredths
        #    #Define.Space(' ')
        #
        #    /*
        #        Inline function builds the "hundreds" string.  In Dutch, this string is created the same way for
        #        all powers.  For instance, 123 (in Dutch) is the same rather used in the context of 123 or 123,000
        #        The function expects a number between 1 and 999.  Any other number will return a
        #        blank string.
        #    */
        #    str 50 buildHundredStr(int64 _number)
        #    {
        #        str 50 rtnStr;
        #        int64 numOfPower
        #
        #        ;
        #
        #        if (_number > 0 && _number < 1000)
        #        {
        #            numOfPower = _number div 100;
        #
        #            if ((_number mod 100 == 0) && (numOfPower == 1))
        #            {
        #                rtnStr = hundred;
        #            }
        #            else
        #            {
        #                if  (numOfPower == 1)
        #                {
        #                    rtnStr = hundred + lessThan100[_number mod 100];
        #                }
        #                else
        #                {
        #                    if (_number mod 100 == 0)
        #                    {
        #                        rtnStr = lessThan100[numOfPower] + hundred;
        #                    }
        #                    else
        #                    {
        #                        if (numOfPower > 0)
        #                        {
        #                            rtnStr = lessThan100[numOfPower] + hundred + lessThan100[_number mod 100];
        #                        }
        #                        else
        #                        {
        #                            rtnStr = lessThan100[_number mod 100];
        #                        }
        #                    }
        #                }
        #            }
        #        }
        #        return rtnStr;
        #
        #    }
        #
        #    /*
        #        Inline function determines how many of the given power exists in the given number.  The function
        #        then appends the appropriat Dutch string to returntxt.  Lastly, the function will remove the given
        #        power from the number (leaving only the portion of the number that is less than the given power).
        #        This value is then returned to the caller.
        #    */
        #    int64 checkPower(int64  _number, int64 _power)
        #    {
        #
        #        int64   numOfPower = 0;
        #
        #        //Determine how many of the given power exists in the given number
        #        if (_number >= _power)
        #        {
        #            numOfPower = _number div _power;
        #        }
        #
        #        //Append the appropriate string for the given power to returntxt
        #        switch(_power)
        #        {
        #            case 1000000000000 :    //Trillions
        #                if (numOfPower > 0)
        #                {
        #                    returntxt = returntxt + buildHundredStr(numOfPower) + space + trillion + space;
        #                }
        #                break;
        #            case 1000000000 :       //Billions
        #                if (numOfPower > 0)
        #                {
        #                    returntxt = returntxt + buildHundredStr(numOfPower) + space + billion + space;
        #                }
        #                break;
        #            case 1000000 :          //Millions
        #                if (numOfPower > 0)
        #                {
        #                    returntxt = returntxt + buildHundredStr(numOfPower) + space + million + space;
        #                }
        #                break;
        #            case 1000 :             //Thousands
        #                if (numOfPower > 0)
        #                {
        #                    if ( numOfPower == 1)
        #                    {
        #                        returntxt = returntxt + thousand + space;
        #                    }
        #                    else
        #                    {
        #                        returntxt = returntxt +  buildHundredStr(numOfPower) + thousand + space;
        #                    }
        #                }
        #                break;
        #            case 1 :                //Hundreds (or Ones)
        #                if (numOfPower > 0)
        #                {
        #                    returntxt = returntxt + buildHundredStr(numOfPower);
        #                }
        #                else
        #                {
        #                    if (numbOfDollars == 0)
        #                    {
        #                        returntxt = zero;
        #                    }
        #                }
        #                break;
        #        }
        #
        #        //Remove the current power from the number and return
        #        _number = _number - (numOfPower * _power);
        #        return _number;
        #
        #    }
        #
        #    ;
        #
        #    //If number is greater than 999,999,999,999,999 then no translation is done. Return empty string.
        #    if (decRound(_num, 2) > 999999999999999)
        #    {
        #        return returntxt;
        #    }
        #
        #    //Initializing variables
        #    zero = #Text0;
        #    lessThan100[1] = #Text1;
        #    lessThan100[2] = #Text2;
        #    lessThan100[3] = #Text3;
        #    lessThan100[4] = #Text4;
        #    lessThan100[5] = #Text5;
        #    lessThan100[6] = #Text6;
        #    lessThan100[7] = #Text7;
        #    lessThan100[8] = #Text8;
        #    lessThan100[9] = #Text9;
        #    lessThan100[10] = #Text10;
        #    lessThan100[11] = #Text11;
        #    lessThan100[12] = #Text12;
        #    lessThan100[13] = #Text13;
        #    lessThan100[14] = #Text14;
        #    lessThan100[15] = #Text15;
        #    lessThan100[16] = #Text16;
        #    lessThan100[17] = #Text17;
        #    lessThan100[18] = #Text18;
        #    lessThan100[19] = #Text19;
        #    lessThan100[20] = #Text20;
        #    lessThan100[21] = #Text21;
        #    lessThan100[22] = #Text22;
        #    lessThan100[23] = #Text23;
        #    lessThan100[24] = #Text24;
        #    lessThan100[25] = #Text25;
        #    lessThan100[26] = #Text26;
        #    lessThan100[27] = #Text27;
        #    lessThan100[28] = #Text28;
        #    lessThan100[29] = #Text29;
        #    lessThan100[30] = #Text30;
        #    lessThan100[31] = #Text31;
        #    lessThan100[32] = #Text32;
        #    lessThan100[33] = #Text33;
        #    lessThan100[34] = #Text34;
        #    lessThan100[35] = #Text35;
        #    lessThan100[36] = #Text36;
        #    lessThan100[37] = #Text37;
        #    lessThan100[38] = #Text38;
        #    lessThan100[39] = #Text39;
        #    lessThan100[40] = #Text40;
        #    lessThan100[41] = #Text41;
        #    lessThan100[42] = #Text42;
        #    lessThan100[43] = #Text43;
        #    lessThan100[44] = #Text44;
        #    lessThan100[45] = #Text45;
        #    lessThan100[46] = #Text46;
        #    lessThan100[47] = #Text47;
        #    lessThan100[48] = #Text48;
        #    lessThan100[49] = #Text49;
        #    lessThan100[50] = #Text50;
        #    lessThan100[51] = #Text51;
        #    lessThan100[52] = #Text52;
        #    lessThan100[53] = #Text53;
        #    lessThan100[54] = #Text54;
        #    lessThan100[55] = #Text55;
        #    lessThan100[56] = #Text56;
        #    lessThan100[57] = #Text57;
        #    lessThan100[58] = #Text58;
        #    lessThan100[59] = #Text59;
        #    lessThan100[60] = #Text60;
        #    lessThan100[61] = #Text61;
        #    lessThan100[62] = #Text62;
        #    lessThan100[63] = #Text63;
        #    lessThan100[64] = #Text64;
        #    lessThan100[65] = #Text65;
        #    lessThan100[66] = #Text66;
        #    lessThan100[67] = #Text67;
        #    lessThan100[68] = #Text68;
        #    lessThan100[69] = #Text69;
        #    lessThan100[70] = #Text70;
        #    lessThan100[71] = #Text71;
        #    lessThan100[72] = #Text72;
        #    lessThan100[73] = #Text73;
        #    lessThan100[74] = #Text74;
        #    lessThan100[75] = #Text75;
        #    lessThan100[76] = #Text76;
        #    lessThan100[77] = #Text77;
        #    lessThan100[78] = #Text78;
        #    lessThan100[79] = #Text79;
        #    lessThan100[80] = #Text80;
        #    lessThan100[81] = #Text81;
        #    lessThan100[82] = #Text82;
        #    lessThan100[83] = #Text83;
        #    lessThan100[84] = #Text84;
        #    lessThan100[85] = #Text85;
        #    lessThan100[86] = #Text86;
        #    lessThan100[87] = #Text87;
        #    lessThan100[88] = #Text88;
        #    lessThan100[89] = #Text89;
        #    lessThan100[90] = #Text90;
        #    lessThan100[91] = #Text91;
        #    lessThan100[92] = #Text92;
        #    lessThan100[93] = #Text93;
        #    lessThan100[94] = #Text94;
        #    lessThan100[95] = #Text95;
        #    lessThan100[96] = #Text96;
        #    lessThan100[97] = #Text97;
        #    lessThan100[98] = #Text98;
        #    lessThan100[99] = #Text99;
        #    hundred = #Text100;
        #    thousand = #Text1000;
        #    million = #Text1000000;
        #    billion = #Text1000000000;
        #    trillion = #Text1000000000000;
        #    and = #TextAnd;
        #    zero = #Text0;
        #    hundredth = #TextHundredth;
        #    oneHundredth = #TextOneHundredth;
        #    space = #Space;
        #
        #    temp = numbOfDollars;
        #
        #    // Builds the string from the highest power digits on down, returntxt is updated in each call
        #    //  Note: These must be called in decreasing order of powers
        #    temp = checkPower(temp, 1000000000000);
        #    temp = checkPower(temp, 1000000000);
        #    temp = checkPower(temp, 1000000);
        #    temp = checkPower(temp, 1000);
        #    temp = checkPower(temp, 1);
        #
        #    //Remove any trailing spaces
        #    returntxt = strRTrim(returntxt);
        #
        #    //Build penny string
        #    switch (numOfPennies)
        #    {
        #        case 0:
        #            //Do nothing.  Decimals are not included when equal to 0/100.
        #            break;
        #        case 1:
        #            returntxt = returntxt + space + and + space + lessThan100[1] + space + oneHundredth;
        #            break;
        #        default:
        #            returntxt = returntxt + space + and + space + lessThan100[numOfPennies] + space + hundredth;
        #            break;
        #    }
        #
        #    //Capitalize the first letter of the string and lower case the rest.
        #    if (strLen(returntxt) > 0)
        #    {
        #        returntxt = strUpr(subStr(returntxt, 1, 1)) + strLwr(subStr(returntxt,2,strLen(returntxt) -1));
        #    }
        #
        #    //Add asteriks to string
        #    if (_enclose)
        #    {
        #        returntxt = '***' + returntxt;
        #    }
        #    return returntxt;
        #
        #
        #}
        #
      ENDSOURCE
      SOURCE #numOfDec
        #static int numOfDec(real r)
        #{
        #    str s = num2str(frac(abs(r)),0,16,1,0);
        #    return strLen(strDel(s,strNFind(s,'0',strLen(s),-strLen(s))+1,strLen(s)))-2;
        #}
      ENDSOURCE
      SOURCE #objectFromXMLNode
        #client static Object objectFromXMLNode(XmlNode n)
        #{
        #    DictClass dc;
        #    Object retval;
        #
        #    boolean hasCreateFromXMLMethod(DictClass _dc)
        #    {
        #        int i;
        #        for (i = 1; i <= _dc.staticMethodCnt(); i++)
        #        {
        #            if (_dc.staticMethod(i) == 'CreateFromXML')
        #                return true;
        #        }
        #        return false;
        #    }
        #
        #    //validate arguments before using them
        #    if (n == null)
        #        return null;
        #
        #    dc = new DictClass(className2Id(n.nodeName()));
        #    if (dc)
        #    {
        #        if (hasCreateFromXMLMethod(dc))
        #        {   // Call it
        #
        #            // BP deviation documented
        #            retval = dc.callStatic('createFromXML', n);
        #        }
        #        else
        #        {   // Use new
        #            retval = dc.makeObject();
        #            // Syp Modifications - SP3 [V-ALEXA][HQ-921-681-FEAC] - BEGIn
        #            retval.loadFromXMl(n);
        #            // Syp Modifications - SP3 - ENd
        #        }
        #        // Syp Modifications - SP3 [V-ALEXA][HQ-921-681-FEAC] - BEGIn
        #        //retval.loadFromXMl(n);
        #        // Syp Modifications - SP3 - ENd
        #    }
        #    return retval;
        #}
        #
      ENDSOURCE
      SOURCE #operatingSystem
        #static OperatingSystem operatingSystem()
        #{
        #    OperatingSystem operatingSystem = '';
        #    int majorVersion, minorVersion, buildNumber, platformID;
        #    anytype dummy;
        #    container con;
        #
        #    //dwMajorVersion
        #    //dwMinorVersion
        #    //dwBuildNumber
        #    //dwPlatformID 0=Win 3.x, 1=95/98, 2=WinNT, 3=...
        #    //szCSDVersion add. info
        #
        #
        #    con = WinAPI::getVersion();
        #    if (conLen(con)==5)
        #    {
        #        [majorversion, minorversion, buildnumber, platformID, dummy] = con;
        #
        #        switch (conPeek(con,4))
        #        {
        #            case 0:
        #            case 1:
        #                operatingSystem += strFmt('%1', OperatingSystemList::Windows9598);
        #                break;
        #            case 2:
        #                if (majorVersion <5)
        #                    operatingSystem += strFmt('%1', OperatingSystemList::WindowsNT);
        #                else
        #                    operatingSystem += strFmt('%1', OperatingSystemList::Windows2000);
        #                break;
        #        }
        #        operatingSystem += strFmt(' Build: %1.%2.%3',majorversion,minorVersion,buildNumber);
        #    }
        #    return operatingSystem;
        #}
      ENDSOURCE
      SOURCE #payment
        #/// <summary>
        #/// Calculates the amount that must be paid every period to repay a loan.
        #/// </summary>
        #/// <param name="principal">The amount that was originally borrowed.</param>
        #/// <param name="interest">The interest that is applied each period to the amount borrowed.</param>
        #/// <param name="life">The number of periods over which the loan is repaid.</param>
        #/// <returns>The amount that must be paid every period.</returns>
        #static real payment(real principal, real interest, real life)
        #{
        #    return pmt(principal, interest, life);
        #}
      ENDSOURCE
      SOURCE #pdsCleanIsCWCache
        #/// <summary>
        #/// Clears the cached value of the catch weight check for the specified item ID.
        #/// </summary>
        #/// <param name="_itemId">
        #/// The item ID to clear the cache for; optional.
        #/// </param>
        #/// <remarks>
        #/// The entire cache for this check is cleared if no item ID is specified.
        #/// </remarks>
        #[SysObsoleteAttribute('This method is obsolete because information about catch weight items is no longer stored in the cache', true)]
        #public static void pdsCleanIsCWCache(ItemId _itemId = '')
        #{
        #}
      ENDSOURCE
      SOURCE #pdsIsCWFullVisItem
        #/// <summary>
        #/// Check if the item is a full visibility catch weight enabled item.
        #/// </summary>
        #/// <param name="_itemId">
        #/// the item to check
        #/// </param>
        #/// <returns>
        #/// true, if the item is catch weight enabled, that the serial dimension is active and the serial dimension has the serial control active;
        #/// false otherwise
        #/// </returns>
        #public static boolean pdsIsCWFullVisItem(ItemId _itemId)
        #{
        #    InventTable                          inventTable = InventTable::find(_itemId);
        #    InventDimGroupFieldSetup             inventDimGroupFieldSetup;
        #    EcoResTrackingDimensionGroupFldSetup dimSetup;
        #
        #
        #    dimSetup = EcoResTrackingDimensionGroupFldSetup::findByDimensionGroupFieldId(
        #                    inventTable.trackingDimensionGroup(),
        #                    fieldNum(InventDim, InventSerialId));
        #    inventDimGroupFieldSetup = InventDimGroupFieldSetup::newEcoResTrackingDimensionGroupFldSetup(dimSetup);
        #
        #    return #PdsCatchWeightEnabled
        #        && pdsIsCWItem(_itemId)
        #        && inventDimGroupFieldSetup.isActive()
        #        && inventDimGroupFieldSetup.isPhysicalInventoryEnabled()
        #        && (inventDimGroupFieldSetup.isSerialNumberControlEnabled() == NoYes::Yes);
        #}
      ENDSOURCE
      SOURCE #pdsIsCWItem
        #/// <summary>
        #/// Check if the item is a catch weight enabled item
        #/// </summary>
        #/// <param name="_itemId">
        #/// The ID of the item to check.
        #/// </param>
        #/// <returns>
        #/// true, if the item is catch weight enabled;
        #/// false otherwise.
        #/// </returns>
        #/// <remarks>
        #/// The function always returns false, if the configuration key for the
        #/// catch weight functionality is turned off.
        #/// </remarks>
        #public static boolean pdsIsCWItem(ItemId _itemId)
        #{
        #    return #PdsCatchWeightEnabled
        #        && PdsCatchWeightItem::exist(_itemId);
        #}
      ENDSOURCE
      SOURCE #pdsIsPositive
        #/// <summary>
        #/// Check if a numeric value is greater than 0
        #/// </summary>
        #/// <param name="_value">
        #/// The value to check
        #/// </param>
        #/// <returns>
        #/// true if the value is positive (greater than 0)
        #/// false otherwise
        #/// </returns>
        #public static boolean pdsIsPositive(real _value)
        #{
        #    return _value > 0;
        #}
      ENDSOURCE
      SOURCE #pdsShowCustomHelp
        #/// <summary>
        #/// Show custom HTML help for Process enhanced forms when there is application documentation.
        #/// </summary>
        #/// <param name="_form" type="FormRun">Running form or dialog.</param>
        #/// <param name="_taskId" type="Integer">Task id value passed to task method</param>
        #/// <returns type="boolean">true if this method displayed custom help; false otherwise.</returns>
        #/// <remarks>
        #/// This method should be used in cases where the standard form ignores the form
        #/// help properties because there is an Application Documentation node for the
        #/// class, menu item, or report. Note that help for reports always exist in an
        #/// Application Documentation node.
        #///
        #/// To provide the custom help file and topic, this method will look for
        #/// a special method in the caller: pdsHtmlHelp.
        #///
        #/// public container pdsHtmlHelp()
        #/// {
        #///     #define.PmfHelpFile('PMFHelp')
        #///     #define.MyFormHelpTopc('PMF.chm://html/myhelptopic.html')
        #///     ;
        #///
        #///     return [#PmfHelpFile, #MyFormHelpTopic];
        #/// }
        #///
        #/// The pdsHtmlHelp method must return a container with two element. Element
        #/// 1 is the help file, element 2 is the help topic. This method may return
        #/// a container with a differing number of elements, such as connull(), to
        #/// signify that there is no applicable custom help.
        #///
        #/// For reports, you may add the method to the report object. For dialog started
        #/// from a class (standard dialog forms based on Dialg), add the method to the class.
        #/// For other forms, in addition to adding the pdsHtmlForm method to the form, you
        #/// will need to override the task method and call pdsShowCustomHelp(this, _taskId).
        #/// In this case, do not call super() if pdsShowCustomHelp returns true otherwise
        #/// two different help pages will be shown.
        #/// </remarks>
        #public client static boolean pdsShowCustomHelp(FormRun _form, int _taskId)
        #{
        #    #define.PdsFormHelpOverride('pdsHtmlHelp')
        #    #define.HelpFileId_Elem  (1)
        #    #define.HelpTopicId_Elem (2)
        #
        #    #define.RequiredContainerElements (2)
        #
        #    #define.ClassMethodPath('\\Classes\\%1\\%2')
        #
        #    #Task
        #
        #    Object              caller;
        #    boolean             isDialog;
        #    DictClass           dictClass;
        #    RunbaseReportStd    reportRunStd;
        #    str                 reportName;
        #    str                 path;
        #
        #    boolean showHelp(Object _obj)
        #    {
        #        container           helpInfo;
        #        str                 helpFile;
        #        str                 helpTopic;
        #
        #        helpInfo = _obj.pdsHtmlHelp();
        #        if (conLen(helpInfo) == #RequiredContainerElements)
        #        {
        #            [helpFile, helpTopic] = helpInfo;
        #            HelpDocumentManager::showHelpTopic(helpTopic);
        #            return true;
        #        }
        #
        #        return false;
        #    }
        #
        #    if (_taskId == #taskF1)
        #    {
        #        if (formHasMethod(_form, #PdsFormHelpOverride) && showHelp(_form))
        #        {
        #            return true;
        #        }
        #
        #        if (_form.args())
        #        {
        #            caller = _form.args().caller();
        #        }
        #
        #        if (caller && typeOf(caller) == Types::Class)
        #        {
        #            if (Dialog::isDialogClass(caller))
        #            {
        #                caller   = caller.caller();
        #                isDialog = true;
        #            }
        #
        #            if (isDialog && classIdGet(caller) == classNum(RunbaseReportStd))
        #            {
        #                reportRunStd = caller;
        #                reportName   = reportRunStd.lastValueElementName();
        #                if (SysReportRun::hasMethod(reportName, #PdsFormHelpOverride))
        #                {
        #                    return showHelp(reportRunStd.reportRun());
        #                }
        #            }
        #
        #            // check for help override method on the caller and search
        #            // the inheritance hierarchy
        #            dictClass = new DictClass(classIdGet(caller));
        #            do
        #            {
        #                path = strFmt(#ClassMethodPath, dictClass.name(),
        #                    #PdsFormHelpOverride);
        #                if (TreeNode::findNode(path))
        #                {
        #                    return showHelp(caller);
        #                }
        #
        #                // Keep looking up the class hierarchy
        #                dictClass = new DictClass(dictClass.extend());
        #            }
        #            while (dictClass);
        #        }
        #    }
        #
        #    return false;
        #}
      ENDSOURCE
      SOURCE #percent
        #static real percent(real     value,
        #             real     base
        #            )
        #{
        #    if (base)
        #        return value / base * 100;
        #
        #    return 0;
        #}
      ENDSOURCE
      SOURCE #physicalMemory
        #static PhysicalMemory physicalMemory()
        #{
        #    container     memoryStatus;
        #    real    memoryInMB;
        #
        #    memoryStatus = WinAPI::getMemoryStatus();
        #
        #    if (conLen(memoryStatus)==8)
        #    {
        #        memoryInMB = round (conPeek(memoryStatus,3)/1024/1024,1)+1; // it seems like adding one is a good idea, otherwise you see results like 383, instead of 384
        #        return real2int(memoryInMB);
        #    }
        #
        #    return 0;
        #}
      ENDSOURCE
      SOURCE #pickClass
        #static int pickClass(boolean  showSystem = false)
        #{
        #    Object  formRun;
        #    container names;
        #    int i;
        #    #ResAppl
        #    Dictionary dict = new Dictionary();
        #
        #    formRun = classfactory.createPicklist();
        #    formRun.init();
        #
        #    for (i=1; i<=dict.classCnt(); i++)
        #    {
        #        if (showSystem || !isSysId(dict.classCnt2Id(i)))
        #            names += dict.className(dict.classCnt2Id(i));
        #    }
        #    formRun.choices(names, #ImageClass);
        #    formRun.caption("@SYS26387");
        #    formRun.run();
        #    formRun.wait();
        #    if (formRun.choice())
        #    {
        #        return dict.className2Id(formRun.choice());
        #    }
        #
        #    return 0;
        #}
      ENDSOURCE
      SOURCE #pickDataArea
        #static DataArea pickDataArea()
        #{
        #    Object  formRun;
        #    Args    args;
        #
        #    args = new Args(formStr(SysPick));
        #    args.parm(' 6');
        #    formRun = classfactory.formRunClass(args);
        #    formRun.init();
        #    formRun.run();
        #    formRun.wait();
        #    return formRun.selection();
        #}
      ENDSOURCE
      SOURCE #pickDomain
        #static DomainId pickDomain()
        #{
        #    Object  formRun;
        #    Args    args;
        #
        #    args = new Args(formStr(SysPick));
        #    args.parm('10');
        #    formRun = classfactory.formRunClass(args);
        #    formRun.init();
        #    formRun.run();
        #    formRun.wait();
        #    return formRun.selection();
        #}
      ENDSOURCE
      SOURCE #pickEnumValue
        #static int pickEnumValue(EnumId _enumId, boolean _omitZero = false)
        #{
        #    Object      formRun;
        #    container   names;
        #    container   values;
        #    int         i,value = -1,valueIndex;
        #    str         name;
        #    #ResAppl
        #    DictEnum dictEnum = new DictEnum(_enumId);
        #    ;
        #    if (!dictEnum)
        #        return -1;
        #
        #
        #    for (i=1;i<=dictEnum.values();i++)
        #    {
        #        value = dictEnum.index2Value(i);
        #        if (!(_omitZero && (value == 0)))
        #        {
        #            names += dictEnum.index2Label(i);
        #            values += value;
        #        }
        #    }
        #    formRun = classfactory.createPicklist();
        #    formRun.init();
        #    formRun.choices(names, #ImageClass);
        #    formRun.caption(dictEnum.label());
        #    formRun.run();
        #    formRun.wait();
        #    name = formRun.choice();
        #    value = formRun.choiceInt();
        #    if (value>=0) // the picklist form returns -1 if a choice has not been made
        #    {
        #        valueIndex = -1;
        #        for (i=1;i<=conLen(names);i++)
        #        {
        #            if (name == conPeek(names,i))
        #            {
        #                valueIndex = i;
        #                break;
        #            }
        #        }
        #        if (valueIndex>=0)
        #            return conPeek(values,valueIndex);
        #    }
        #
        #
        #    return value;
        #}
      ENDSOURCE
      SOURCE #pickField
        #static int pickField(TableId tableId)
        #{
        #    Object  formRun;
        #    Args    args;
        #
        #    args = new Args(formStr(SysPick));
        #    args.parm(' 2'+int2str(tableId));
        #    formRun = classfactory.formRunClass(args);
        #    formRun.init();
        #    formRun.run();
        #    formRun.wait();
        #    if (formRun.selection())
        #        return formRun.selection();
        #    return 0;
        #}
      ENDSOURCE
      SOURCE #pickIndex
        #static int pickIndex(IndexId indexId)
        #{
        #    Object  formRun;
        #    Args    args;
        #
        #    args = new Args(formStr(SysPick));
        #    args.parm(' 3'+int2str(indexId));
        #    formRun = classfactory.formRunClass(args);
        #    formRun.init();
        #    formRun.run();
        #    formRun.wait();
        #    if (formRun.selection())
        #        return formRun.selection();
        #    return 0;
        #}
      ENDSOURCE
      SOURCE #pickInterface
        #static int pickInterface(boolean  showSystem = false)
        #{
        #    Object  formRun;
        #    container names;
        #    int i;
        #    #ResAppl
        #    Dictionary dict = new Dictionary();
        #    DictClass dc;
        #
        #    formRun = classfactory.createPicklist();
        #    formRun.init();
        #
        #    for (i=1; i<=dict.classCnt(); i++)
        #    {
        #        dc = new DictClass(dict.classCnt2Id(i));
        #        if (showSystem || !isSysId(dict.classCnt2Id(i)))
        #        {
        #            if (dc.isInterface())
        #                names += dict.className(dict.classCnt2Id(i));
        #        }
        #    }
        #    formRun.choices(names, #ImageClass);
        #    formRun.caption("@SYS69603");
        #    formRun.run();
        #    formRun.wait();
        #    if (formRun.choice())
        #    {
        #        return dict.className2Id(formRun.choice());
        #    }
        #
        #    return 0;
        #}
      ENDSOURCE
      SOURCE #pickList
        #/*
        #    Map description:
        #                      ID              TEXT
        #        map = new Map(Types::String,  Types::String)
        #        OR
        #        map = new Map(Types::Integer, Types::String)
        #*/
        #static str pickList(Map _map, str _columnHeader = '', str _title = "@SYS5704", boolean _modal = false)
        #{
        #    FormRun  formRun;
        #    Object  formRunObject;
        #    Args    args;
        #
        #    args = new Args(formStr(SysPick));
        #    args.parm(' 0');
        #    args.parmObject(_map);
        #
        #    formRun = classfactory.formRunClass(args);
        #    formRun.init();
        #    formRun.run();
        #    formRunObject = formRun;
        #    formRunObject.setColumnHeader(_columnHeader);
        #    formRunObject.setCaption(_title);
        #    formRun.wait(_modal);
        #
        #    if (formRunObject.selection())
        #    {
        #        return formRunObject.selection();
        #    }
        #    return '';
        #}
      ENDSOURCE
      SOURCE #pickTable
        #static int pickTable(boolean  showMap     = false,               // Show maps?
        #                     boolean  showTemp    = false,               // Show temporary tables?
        #                     boolean  showSystem  = false,               // Show system tables?
        #                     boolean  showView    = false,               // Show tables which are views?
        #                     boolean  checkRights = false                // Only show tables which the user has View rights to?
        #                    )
        #{
        #    Object  formRun;
        #    container names;
        #    int i;
        #    #ResAppl
        #    Dictionary dict = new Dictionary();
        #    DictTable dictTable;
        #    sysPickList sysPickList;
        #
        #    formRun = classfactory.createPicklist();
        #    formRun.init();
        #    sysPickList = new sysPickList(formRun);
        #    for (i=1; i<=dict.tableCnt(); i++)
        #    {
        #        if (showSystem || !isSysId(dict.tableCnt2Id(i)))
        #        {
        #            dictTable = new DictTable(dict.tableCnt2Id(i));
        #            if ( (showMap  || ! dictTable.isMap()) &&
        #                 (showTemp || ! dictTable.isTmp()) &&
        #                 (showView || ! dictTable.isView())
        #               )
        #            {
        #                if (checkRights)
        #                {
        #                    if (dictTable.rights() >= AccessType::View)
        #                    {
        #                        names += dictTable.name();
        #                    }
        #                }
        #                else
        #                {
        #                    names += dictTable.name();
        #                }
        #            }
        #        }
        #    }
        #    formRun.choices(names, #ImageTable);
        #    formRun.caption("@SYS9678");
        #    formRun.run();
        #    formRun.wait();
        #    if (formRun.choice())
        #    {
        #        return dict.tableName2Id(formRun.choice());
        #    }
        #
        #    return 0;
        #}
      ENDSOURCE
      SOURCE #pickUser
        #/*
        #    Map description:
        #                      User id        User name
        #        map = new Map(Types::String, Types::String)
        #*/
        #static UserId pickUser(Map _map = null, boolean _modal = false)
        #{
        #    FormRun formRun;
        #    Object  formRunObject;
        #    Args    args;
        #
        #    args = new Args(formStr(SysPick));
        #    args.parm(' 4');
        #    args.parmObject(_map);
        #
        #    formRun = classfactory.formRunClass(args);
        #    formRun.init();
        #    formRun.run();
        #    formRun.wait(_modal);
        #
        #    formRunObject = formRun;
        #
        #    return formRunObject.selection();
        #
        #}
      ENDSOURCE
      SOURCE #pickUserGroup
        #static UserGroupId pickUserGroup(UserId userId = '')
        #{
        #    Object  formRun;
        #    Args    args;
        #
        #    args = new Args(formStr(SysPick));
        #    args.parm(' 5' + userId);
        #    formRun = classfactory.formRunClass(args);
        #    formRun.init();
        #    formRun.run();
        #    formRun.wait();
        #    return formRun.selection();
        #}
      ENDSOURCE
      SOURCE #pmfTableHasChanged
        #/// <summary>
        #/// Check if any field value of a record has changed
        #/// </summary>
        #/// <param name="_common">
        #/// The record to check for change
        #/// </param>
        #/// <returns>
        #/// true, if any field value has changed
        #/// false otherwise
        #/// </returns>
        #/// <remarks>
        #/// All fields, that have base types less than 7 will be checked;
        #/// all other fields will NOT be checked.
        #/// </remarks>
        #public static boolean pmfTableHasChanged(Common _common)
        #{
        #    DictTable   dictTable;
        #    DictField   dictField;
        #    Common      origBuf;
        #    int         i;
        #
        #    #define.baseType(7)
        #
        #    origBuf = _common.orig();
        #    dictTable = new DictTable(_common.TableId);
        #
        #    for (i = 1; i <= dictTable.fieldCnt(); i++)
        #    {
        #        dictField = new DictField(_common.TableId,dictTable.fieldCnt2Id(i));
        #        if (dictField.baseType() < #baseType)
        #        {
        #            if (_common.(dictField.id()) != origBuf.(dictField.id()))
        #            {
        #                return true;
        #            }
        #        }
        #    }
        #
        #    return false;
        #}
      ENDSOURCE
      SOURCE #presentValue
        #/// <summary>
        #/// Calculates the present value of an annuity where an amount is received over multiple periods and
        #/// the interest rate is deducted for each period.
        #/// </summary>
        #/// <param name="amount">
        #/// The amount paid during each period.
        #/// </param>
        #/// <param name="interest">
        #/// The interest rate.
        #/// </param>
        #/// <param name="life">
        #/// The number of times that the value specified by the amount parameter is paid.
        #/// </param>
        #/// <returns>
        #/// The current value of an annuity.
        #/// </returns>
        #/// <remarks>
        #/// This method calculates the present value of an annuity where the amount is received over multiple
        #/// periods and the interest rate is deducted for each period.This method is a rename of the <c>pV</c>
        #/// function.
        #/// </remarks>
        #static real presentValue(real amount, real interest, real life)
        #{
        #    return pv(amount, interest, life);
        #}
      ENDSOURCE
      SOURCE #primaryLanguageId
        #static int primaryLanguageId (int languageId)
        #{
        #    return languageId & 0x3ff;
        #}
      ENDSOURCE
      SOURCE #processorInfo
        #static ProcessorInfo processorInfo()
        #{
        #    container       systemInfo;
        #    ProcessorInfo   processorInfo = '';
        #    int             processorArchitecture, processorLevel, processorRevision;
        #    int             processorRevisionFamily,processorRevisionStepping;
        #    systemInfo = WinAPI::getSystemInfo();
        #
        #
        #    if (conLen(systemInfo)==10)
        #    {
        #        processorArchitecture = conPeek(systemInfo,1);
        #        processorLevel = conPeek(systemInfo,9);
        #        processorRevision = conPeek(systemInfo,10);
        #        if (processorArchitecture == 0) // make sure it is intel
        #        {
        #            switch (processorLevel)
        #            {
        #                case 3:
        #                    processorInfo += strFmt('386');
        #                    break;
        #                case 4:
        #                    processorInfo += strFmt('486');
        #                    break;
        #                case 5:
        #                    processorRevisionStepping = processorRevision mod 256;
        #                    processorRevisionFamily = processorRevision / 256;
        #                    processorInfo += 'Pentium ';
        #                    break;
        #                case 6:
        #                    processorRevisionStepping = processorRevision mod 256;
        #                    processorRevisionFamily = processorRevision / 256;
        #                    processorInfo += 'Pentium III';
        #                    break;
        #                case 7:
        #                    processorRevisionStepping = processorRevision mod 256;
        #                    processorRevisionFamily = processorRevision / 256;
        #                    processorInfo += 'Pentium IV';
        #                    break;
        #            }
        #            processorInfo += strFmt(' Model: %1 step. %2',processorRevisionFamily, processorRevisionStepping);
        #        }
        #    }
        #
        #    return processorInfo;
        #}
      ENDSOURCE
      SOURCE #queryDeleteDynalinks
        #/*
        #Deletes ranges in Q which is in InitQ.
        #*/
        #static void queryDeleteDynalinks(
        #    Query       q,
        #    Query       initQ,
        #    int         initQdsNo = 1
        #    )
        #{
        #    SysQuery::deleteDynalinks(q,initQ,initQdsNo);
        #}
      ENDSOURCE
      SOURCE #queryIsPackedOk
        #/*MAN
        #Method to test a packed queryrun container is legal.
        #*/
        #static boolean queryIsPackedOk(PackedQueryRun packed)
        #{
        #    return SysQuery::isPackedOk(packed);
        #}
      ENDSOURCE
      SOURCE #queryMergeRanges
        #static void queryMergeRanges(
        #    Query       q,
        #    Query       initQ,
        #    int         initQdsNo = 1,
        #    boolean     alwaysAddDatasource     = false,
        #    boolean     addSameFieldRange       = true
        #    )
        #{
        #    SysQuery::mergeRanges(q,initQ,initQdsNo,alwaysAddDatasource,addSameFieldRange);
        #}
      ENDSOURCE
      SOURCE #queryName2Pname
        #client server static str queryName2Pname(QueryName queryName)
        #{
        #    MenuFunction mf;
        #    Query query;
        #
        #    try
        #    {
        #        mf = new MenuFunction(queryName, MenuItemType::Action);
        #    }
        #    catch(Exception::Internal)
        #    {
        #        mf = null;
        #    }
        #
        #    if (mf)
        #    {
        #        return mf.label();
        #    }
        #
        #    query = new Query(queryName);
        #    if (query)
        #    {
        #        return query.title();
        #    }
        #    return '';
        #}
      ENDSOURCE
      SOURCE #queryNotValue
        #static str queryNotValue(anytype A)
        #{
        #    return SysQuery::valueNot(a);
        #}
      ENDSOURCE
      SOURCE #queryNotValueCon_W
        #static str queryNotValueCon_W(container _values)
        #{
        #    return '!' + con2Str(_values, ',!');
        #}
      ENDSOURCE
      SOURCE #queryRange
        #/// <summary>
        #///    Returns a string that represents a range filter that can be used as value for
        #///    <c>QueryBuildRange</c>.
        #/// </summary>
        #/// <param name="_From">
        #///    The lower bound of the range; optional.
        #/// </param>
        #/// <param name="_To">
        #///    The upper bound of the range; optional.
        #/// </param>
        #/// <param name="treatOnlyNullAsUnbound">
        #///    A Boolean value that specifies whether to treat empty values as unbound; optional.
        #/// </param>
        #/// <returns>
        #///    A string representing a range filter that can be used as a value for the <c>QueryBuildRange</c>
        #///    method.
        #/// </returns>
        #/// <remarks>
        #///    This method generally returns the string in the format of '_from..._to'. If _from is null or empty
        #///    value and <c>treatOnlyNullAsUnbound</c> is set to false, the value is dropped from the string and
        #///    it becomes '..._to'. _from in this case represents an unbound value. This also applies for _to.
        #///    When both _from and _to are unbound values, the function returns an empty string and the range
        #///    filter will be dropped from the query when it is used as value for the <c>QueryBuildRange</c>
        #///    method.
        #/// </remarks>
        #static str queryRange(
        #    anytype _From,
        #    anytype _To,
        #    boolean treatOnlyNullAsUnbound = false)
        #{
        #    return SysQuery::range(_From,_To,treatOnlyNullAsUnbound);
        #}
        #
      ENDSOURCE
      SOURCE #queryRangeConcat
        #static str queryRangeConcat(
        #    str     _queryRange,
        #    anytype _value)
        #{
        #    if (_queryRange)
        #        return _queryRange + ',' + queryValue(_value);
        #    return queryValue(_value);
        #}
      ENDSOURCE
      SOURCE #queryValue
        #static str queryValue(anytype A)
        #{
        #    return SysQuery::value(a);
        #}
      ENDSOURCE
      SOURCE #real2double
        #/// <summary>
        #///    Converts a value of <c>real</c> type into a <c>System.Double</c> type specified in <c>_value</c>
        #///    parameter.
        #/// </summary>
        #/// <param name="_value">
        #///    The value to be converted.
        #/// </param>
        #/// <returns>
        #///    A <c>System.Decimal</c> object.
        #/// </returns>
        #public static System.Double real2double(real _value)
        #{
        #    System.Decimal decimalValue;
        #    System.Double doubleValue;
        #
        #    decimalValue = CLRInterop::getObjectForAnyType( _value );
        #    doubleValue  = System.Decimal::ToDouble( decimalValue );
        #
        #    return doubleValue;
        #}
      ENDSOURCE
      SOURCE #real2int
        #client server static int real2int(real _realValue)
        #{
        #    return any2int(_realValue);
        #    /*
        #    Note that this is equivalent of any2int(trunc(_realValue)) meaning that no rounding is performed
        #
        #    Examples:
        #    info(strfmt("%1", real2int(123.456)));  // returns 123
        #    info(strfmt("%1", real2int(123.756)));  // returns 123
        #    info(strfmt("%1", real2int(-123.456))); // returns -123
        #    info(strfmt("%1", real2int(-123.756))); // returns -123
        #    */
        #}
      ENDSOURCE
      SOURCE #real2UnsignedInt
        #static int real2UnsignedInt(real r)
        #{
        #    real rmaxInt = maxInt();
        #    if (r<0)
        #        return 0;
        #
        #    if (r>2*rmaxInt)
        #        return 0;
        #
        #    if (r>rmaxInt)
        #        return any2int(-r+maxInt());
        #
        #    return any2int(r);
        #}
      ENDSOURCE
      SOURCE #realMax
        #/// <summary>
        #/// Returns the max value allowed for real allowed by IL and the Interpretor.
        #/// This value is the maximum able to be marshalled between X++ and Managed Code.
        #/// Real can still be assigned values up to the original max 9.e127 but will throw an out of bounds exception in IL.
        #/// </summary>
        #/// <returns>Accepted max value for IL and the Interpreter</returns>
        #static real realMax()
        #{
        #    return 9.999999999999999e15;
        #}
      ENDSOURCE
      SOURCE #realMin
        #/// <summary>
        #/// Returns the min value allowed for real allowed by IL and the Interpretor.
        #/// This value is the minimum able to be marshalled between X++ and Managed Code.
        #/// Real can still be assigned values down to the original min -9.e127 but will throw an out of bounds exception in IL.
        #/// </summary>
        #/// <returns>Accepted min value for IL and the Interpreter</returns>
        #static real realMin()
        #{
        #    return -9.999999999999999e15;
        #}
      ENDSOURCE
      SOURCE #record2DynaKey
        #static str record2DynaKey(Common rec)
        #{
        #    TableId     tableId     = rec.TableId;
        #    DictTable   dictTable   = new DictTable(tableId);
        #    IndexId     indexId     = dictTable.indexUnique();
        #    DictIndex   dictIndex   = dictTable.indexObject(indexId);
        #    str buf;
        #    int indexCnt;
        #    int fieldsInIndex;
        #    FieldId fieldId;
        #
        #str any2strLocal(anytype t)
        #{
        #    return t;
        #}
        #
        #    if (dictIndex.name() == 'RecId')                                            // RecId as index
        #        return '['+int2str(fieldNum(Common,RecId))+':'+int642str(rec.RecId)+']';
        #    else
        #    {
        #        fieldsInIndex = dictIndex.numberOfFields();
        #        for (indexCnt = 1; indexCnt <= fieldsInIndex; indexCnt++)
        #        {
        #            fieldId    = dictIndex.field(indexCnt);
        #            buf += '[' + int2str(fieldId) + ':';
        #            switch (typeOf(rec.(fieldId)))
        #            {
        #                case Types::Date:
        #                    buf += date2str(rec.(fieldId),-1,-1,-1,-1,-1,-1, DateFlags::None);
        #                    break;
        #                case Types::UtcDateTime:
        #                    buf += datetime2str(rec.(fieldId), DateFlags::None);
        #                    break;
        #                default:
        #                    //buf += any2StrLocal(strReplace(rec.(fieldId),' ', '%20'));
        #                    buf += any2StrLocal(rec.(fieldId));
        #            }
        #            buf += ']';
        #        }
        #        if (dictIndex.allowDuplicates())
        #        {
        #            buf += '['+int2str(fieldNum(Common,RecId))+':'+int642str(rec.RecId)+']';
        #        }
        #    }
        #    return buf;
        #}
      ENDSOURCE
      SOURCE #recordFromXMLNode
        #// Input is <Record table="name"> <Field:field1> value </Field:field1> ... </Record>
        #static Common recordFromXMLNode(XmlNode n, Common c = null)
        #{
        #    TableId table;
        #    FieldId field;
        #    DictTable dt;
        #    DictField df;
        #    XmlNode fieldNode;
        #    str fieldName;
        #    Struct content;
        #    XmlNode tableName;
        #    Types t;
        #    int extendedFieldIndex;
        #
        #    //validate arguments before using them
        #    if (n == null)
        #        return null;
        #    // If we don't have an incoming buffer, one is created
        #    if (prmisDefault(c))
        #    {
        #        // Create a buffer of the correct type
        #        tableName = n.attributes().getNamedItem('name');
        #
        #        // If node does not contain name attribute, try with table attribute.
        #        if (tableName == null)
        #        {
        #            tableName = n.attributes().getNamedItem('table');
        #        }
        #
        #        // Check if table node can be accessed
        #        if (tableName != null)
        #        {
        #            table = tableName2id(tableName.nodeValue());
        #            dt = new DictTable(table);
        #            c = dt.makeRecord();
        #        }
        #    }
        #    else
        #    {
        #        table = c.TableId;
        #        dt = new DictTable(table);
        #    }
        #
        #    fieldNode = n.firstChild();
        #    while (fieldNode)
        #    {
        #        fieldName = fieldNode.attributes().getNamedItem('name').text();
        #        field = dt.fieldName2Id(fieldName);
        #        df = new DictField(table, field);
        #
        #        t = df.baseType();
        #        if (t == Types::Enum) //Enums need to be treated as Integers. By defult, Enums are getting treated as a boolean and hence loosing its value.
        #            t = Types::Integer;
        #
        #        if (t == Types::Container)
        #        {
        #            content = valueFromXMLNode (t, fieldNode.firstChild());
        #        }
        #        else
        #        {
        #            content = valueFromXMLNode (t, fieldNode);
        #        }
        #
        #        // If array substitute the fieldId of the array EDT with the fieldId of the elements
        #        if (df.arraySize() > 1)
        #        {
        #           extendedFieldIndex = str2int(fieldNode.attributes().getNamedItem('offset').text());
        #           c.(fieldId2Ext(field, extendedFieldIndex)) = content.value('value');
        #        }
        #        else
        #        {
        #            c.(field) = content.value('value');
        #        }
        #
        #
        #        fieldNode = fieldNode.nextSibling();
        #    }
        #    return c;
        #}
      ENDSOURCE
      SOURCE #reportHasMethod
        #static boolean reportHasMethod(ReportRun rr, IdentifierName methodName)
        #{
        #    boolean         ret = false;
        #    SysReportRun    sysReportRun;
        #
        #    if (SysDictClass::isEqualOrSuperclass(classIdGet(rr), classNum(SysReportRun)))
        #    {
        #        sysReportRun = rr;
        #        ret = sysReportRun.reportHasMethod(methodName);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #reportName2Pname
        #client server static str reportName2Pname(ReportName reportName)
        #{
        #    MenuFunction mf;
        #    Report report;
        #
        #    try
        #    {
        #        mf = new MenuFunction(reportName, MenuItemType::Output);
        #    }
        #    catch(Exception::Internal)
        #    {
        #        mf = null;
        #    }
        #
        #    if (mf &&
        #        mf.label())
        #    {
        #        return mf.label();
        #    }
        #
        #    report = new Report(reportName);
        #    if (report && report.design())
        #    {
        #        return report.design().caption();
        #    }
        #    return '';
        #
        #}
      ENDSOURCE
      SOURCE #reportSendDocuRef
        #static void reportSendDocuRef(
        #    ReportRun   reportRun,
        #    Common      common
        #    )
        #{
        #    DocuRef docuRef;
        #
        #    docuRef.recordLevelSecurity(true);
        #    while select docuRef
        #        index RefIdx
        #        where docuRef.RefCompanyId    == common.DataAreaId    &&
        #              docuRef.RefTableId      == common.TableId       &&
        #              docuRef.RefRecId        == common.RecId
        #    {
        #        reportRun.send(docuRef);
        #    }
        #}
      ENDSOURCE
      SOURCE #rgb2Hex
        #/// <summary>
        #/// Converts RGB values to hexadecimal.
        #/// </summary>
        #/// <param name="_r">
        #/// Red value.
        #/// </param>
        #/// <param name="_g">
        #/// Green value.
        #/// </param>
        #/// <param name="_b">
        #/// Blue value.
        #/// </param>
        #/// <returns>
        #/// The hexadecimal representation of the RGB values.
        #/// </returns>
        #public static SysColorHex rgb2Hex(RGBintR _r, RGBintG _g, RGBintB _b)
        #{
        #    SysColorHex colorHex;
        #    colorHex = int2Hex(_r, 2);
        #    colorHex += int2Hex(_g, 2);
        #    colorHex += int2Hex(_b, 2);
        #
        #    return colorHex;
        #}
      ENDSOURCE
      SOURCE #roundDown
        #static real roundDown(
        #    real      value,
        #    real      unit
        #    )
        #{
        #    real    roundedValue;
        #
        #    roundedValue = round(value,unit);
        #    // Check for special case
        #    if (value== roundedValue)
        #        return value;
        #    // for numerical reasons we subtract the major part of the number before rounding
        #    return round(value - roundedValue - unit/2, unit)+roundedValue;
        #    //return round(value - unit/(2+unit/10),unit); // the new suggestion
        #}
      ENDSOURCE
      SOURCE #roundDownDec
        #static real roundDownDec(
        #    real     value,
        #    int      numDec)
        #{
        #    real            unit = 1;
        #    while (numDec > 0)
        #    {
        #        unit        = unit/10;
        #        numDec      = numDec-1;
        #    }
        #
        #    return roundDown(value,unit);
        #}
      ENDSOURCE
      SOURCE #roundUp
        #static real roundUp(
        #    real      value,
        #    real      unit
        #    )
        #{
        #    real    roundedValue;
        #
        #    roundedValue = round(value,unit);
        #    // Check for special case
        #    if (value== roundedValue)
        #        return value;
        #    // for numerical reasons we subtract the major part of the number before rounding
        #    return round(value - roundedValue + unit/2, unit)+roundedValue;
        #    //return round(value - unit/(2+unit/10),unit); // the new suggestion
        #}
        #
      ENDSOURCE
      SOURCE #roundUpDec
        #static real roundUpDec(real     value,
        #                int      numDec)
        #{
        #    real            unit = 1;
        #    while (numDec > 0)
        #    {
        #        unit        = unit/10;
        #        numDec      = numDec-1;
        #    }
        #
        #    return roundUp(value,unit);
        #}
      ENDSOURCE
      SOURCE #roundZero
        #static real roundZero(real      value,
        #               real      unit
        #              )
        #{
        #    if (value >= 0)
        #        return roundDown(value, unit);
        #
        #    return roundUp(  value, unit);
        #
        #}
      ENDSOURCE
      SOURCE #roundZeroDec
        #static real roundZeroDec(real    value,
        #                         int     numDec)
        #{
        #    real unit = 1;
        #    while (numDec > 0)
        #    {
        #        unit       = unit/10;
        #        numDec     = numDec-1;
        #    }
        #
        #    if (value >= 0)
        #        return roundDown(value,unit);
        #
        #    return roundUp(value,unit);
        #}
      ENDSOURCE
      SOURCE #rowsDisplayedInListPage
        #// return the number of rows to display in a list page
        #static int rowsDisplayedInListPage()
        #{
        #    return EPGlobalParameters::rowsDisplayedinListPage();
        #}
      ENDSOURCE
      SOURCE #runClassMethodIL
        #/// <summary>
        #/// Runs the specified method and makes sure it is executed under the Xpp IL.
        #/// </summary>
        #/// <param name="_className">
        #/// The name of the class that contains the method.
        #/// </param>
        #/// <param name="_methodName">
        #/// The static method to call.
        #/// </param>
        #/// <param name="_params">
        #/// The container of parameters to pass to the method.
        #/// </param>
        #/// <param name="_ignoreTtsLevel">
        #/// Forces to IL even if the tts level is larger than 0.
        #/// </param>
        #/// <returns>
        #/// The result of the method call as a container.
        #/// </returns>
        #/// <remarks>
        #/// This demands the <c>XppILExecutePermission</c> class and asserts both the <c>RunAsPermission</c>
        #/// and <c>ExecutePermission</c>. The call will transition to Xpp IL using <c>runAs</c> if running
        #/// interpreted. If running as Xpp IL, the method is just called directly.As there may be some
        #/// overhead, this method should only be used on computationally expensive methods.This method will not
        #/// transition to IL if the current tts level is larger than 0 (unless forced) because transaction
        #/// scope does not flow across IL boundaries.IL is also referred to as CIL, for the common intermediate
        #/// language of the .NET Framework.
        #/// </remarks>
        #public static server container runClassMethodIL(ClassName _className, MethodName _methodName, container _params, boolean _ignoreTtsLevel = false)
        #{
        #    return SysDictClass::invokeStaticMethodIL(_className, _methodName, _params, _ignoreTtsLevel);
        #}
      ENDSOURCE
      SOURCE #runTableMethodIL
        #/// <summary>
        #/// Runs the specified method and makes sure it is executed under Xpp IL.
        #/// </summary>
        #/// <param name="_tableName">
        #/// The name of the table that contains the method.
        #/// </param>
        #/// <param name="_methodName">
        #/// The static method to called.
        #/// </param>
        #/// <param name="_params">
        #/// The container of parameters to pass to the method.
        #/// </param>
        #/// <param name="_ignoreTtsLevel">
        #/// Forces to IL even if the tts level is larger than 0.
        #/// </param>
        #/// <returns>
        #/// The result of the method call as a container.
        #/// </returns>
        #/// <remarks>
        #/// This demands the <c>XppILExecutePermission</c> class and asserts both the <c>RunAsPermission</c>
        #/// and <c>ExecutePermission</c>. The call will transition to Xpp IL using <c>runAs</c> if running
        #/// interpreted. If running as Xpp IL, the method is just called directly. As there may be some
        #/// overhead, this method should only be used on computationally expensive methods. This method will
        #/// not transition to IL if the current tts level is larger than 0 (unless forced) because transaction
        #/// scope does not flow across IL boundaries.IL is also referred to as CIL, for the common intermediate
        #/// language of the .NET Framework.
        #/// </remarks>
        #public static server container runTableMethodIL(TableName _tableName, MethodName _methodName, container _params, boolean _ignoreTtsLevel = false)
        #{
        #    return SysDictTable::invokeStaticMethodIL(_tableName, _methodName, _params, _ignoreTtsLevel);
        #}
      ENDSOURCE
      SOURCE #sax2Supported
        #static boolean sax2Supported()
        #{
        #    COM objDoc;
        #    int infoItem = infologLine();
        #    boolean retval = true;
        #
        #    try
        #    {
        #        objDoc = new COM('Msxml2.DOMDocument.3.0');
        #    }
        #    catch (Exception::Internal)
        #    {
        #        infolog.clear(infoItem);
        #        retval = false;
        #    }
        #
        #    return retval;
        #}
      ENDSOURCE
      SOURCE #securitykeyId2Name
        #static SecurityKeyName securitykeyId2Name(SecurityKeyId _securityKeyId)
        #{
        #    DictSecurityKey dictSecurityKey = new DictSecurityKey(_securityKeyId);
        #    if (dictSecurityKey)
        #        return dictSecurityKey.name();
        #    return '';
        #}
      ENDSOURCE
      SOURCE #securityKeyName2Id
        #static SecurityKeyId securityKeyName2Id(IdentifierName _name)
        #{
        #    Dictionary dict = new Dictionary();
        #    return dict.securityKeyName2Id(_name);
        #}
        #
      ENDSOURCE
      SOURCE #selectMultiple
        #/*
        #Returns container with the status of how the form is closed plus the selected ids.
        #*/
        #static client container selectMultiple(
        #    Caption     _caption,
        #    str         _info,                   // An info text displayed in the top of the form
        #    container   _choices,
        #    container   _headers = conNull(),    // If null, the list view is used
        #    Object      _caller = null
        #    )
        #{
        #    Args                    args;
        #    FormRun                 formRun;
        #    Object                  obj;
        #
        #    args = new Args(formStr(SysListSelect));
        #    args.caller(_caller);
        #    formRun = classfactory.formRunClass(args);
        #    formRun.init();
        #    formRun.design().visible(true);
        #    obj = formRun;
        #    obj.infotxt(_info);
        #    obj.choices(_choices);
        #    obj.headers(_headers);
        #    formRun.run();
        #    obj.setCaption(_caption);
        #    formRun.wait();
        #
        #    return [formRun.closedOk(),obj.selected()];
        #}
      ENDSOURCE
      SOURCE #selectSingle
        #/*
        #Returns container with the status of how the form is closed plus the selected ids.
        #*/
        #static client container selectSingle(
        #    Caption     _caption,
        #    str         _info,                   // An info text displayed in the top of the form
        #    container   _choices,
        #    container   _headers = conNull(),    // If null, the list view is used
        #    Object      _caller = null
        #    )
        #{
        #    Args                    args;
        #    FormRun                 formRun;
        #    Object                  obj;
        #    container               selected;
        #
        #    args = new Args(formStr(SysListSelect));
        #    args.caller(_caller);
        #    formRun = classfactory.formRunClass(args);
        #    formRun.init();
        #    formRun.design().visible(true);
        #    obj = formRun;
        #    obj.infotxt(_info);
        #    obj.choices(_choices);
        #    obj.headers(_headers);
        #    obj.selectSingle();
        #
        #    formRun.run();
        #    obj.setCaption(_caption);
        #    formRun.wait();
        #
        #    selected = obj.selected();
        #    if (conLen(selected) > 0)
        #    {
        #        return [formRun.closedOk(),[conPeek(selected,1)]];
        #    }
        #    return [formRun.closedOk(), conNull()];
        #}
      ENDSOURCE
      SOURCE #setProperty
        #/* MAN
        #    Modifies the value of a property in the supplied property set.
        #    If the property does not exist the original property set is returned.
        #*/
        ##Properties
        #static str setProperty(str properties, str propertyname, str value)
        #{
        #    str s = properties;
        #    int slen=strLen(s);
        #    int propertyPos;
        #    int arrayPos;
        #    int propertyLen;
        #
        #    propertyPos = findPropertyPos(properties, propertyname);
        #    if (propertyname == #PropertyExtendedDataType)
        #    {
        #        // Extended property may be written on multiple lines
        #        arrayPos = strScan(s, 'ARRAY', propertyPos, slen);
        #        if (arrayPos)
        #        {
        #            // ARRAY was found so move to the correct place
        #            propertyPos = arrayPos;
        #            propertyPos = strScan(s, '\n', propertyPos,slen);
        #            if (!propertyPos)
        #                return s;
        #            propertyPos++;
        #        }
        #    }
        #    propertyLen = strScan(s, '\n', propertyPos, slen);
        #    if (!propertyPos)
        #        return s;
        #
        #    propertyPos = strScan(s, '#', propertyPos,   slen)+1;
        #
        #    if (!propertyLen)
        #        propertyLen = slen;
        #
        #    s = strDel(s, propertyPos, propertyLen-propertyPos+1);
        #    s = strIns(s, value+'\n', propertyPos);
        #    return s;
        #}
        #
      ENDSOURCE
      SOURCE #setRecordTemplatePromptGlobalSuppression
        #/// <summary>
        #/// Sets whether the record template prompt should be suppressed.
        #/// </summary>
        #/// <param name="_isRecordTemplatePromptGloballySuppressed">
        #/// true if the prompt should be suppressed; otherwise, false.
        #/// </param>
        #public static void setRecordTemplatePromptGlobalSuppression(boolean _isRecordTemplatePromptGloballySuppressed)
        #{
        #    if (_isRecordTemplatePromptGloballySuppressed)
        #    {
        #        infolog.globalCache().set(classStr(Global), staticMethodStr(Global, setRecordTemplatePromptGlobalSuppression), true);
        #    }
        #    else
        #    {
        #        infolog.globalCache().remove(classStr(Global), staticMethodStr(Global, setRecordTemplatePromptGlobalSuppression));
        #    }
        #}
      ENDSOURCE
      SOURCE #showFieldAccessException
        #/// <summary>
        #///    Retrieves an exception message if a user does not have the necessary access level.
        #/// </summary>
        #/// <param name="_common">
        #///    A table buffer that indicates the fields to which the user has access; optional.
        #/// </param>
        #/// <param name="_fieldList">
        #///    The list of fields to display in the message; optional.
        #/// </param>
        #/// <param name="_neededAccessLevel">
        #///    The access level that is needed; optional.
        #/// </param>
        #/// <param name="_helpUrl">
        #///    The help link for the message to display; optional.
        #/// </param>
        #/// <param name="_sysInfoAction">
        #///    The layout type of the Infolog window; optional.
        #/// </param>
        #/// <returns>
        #///    An exception message.
        #/// </returns>
        #/// <remarks>
        #///    This method determines whether a buffer and list of fields are specified.If the field list is
        #///    specified than it will be displayed to the user; otherwise, the list will be generated
        #///    automatically if the table buffer is specified.This method checks for access for all fields in the
        #///    table buffer and stores the fields that cannot be accessed in a list.If both the buffer and filter
        #///    are not specified, a default error message is displayed.If the access level is not specified and a
        #///    table buffer has not been specified, the needed access level is set to view.
        #/// </remarks>
        #public client server static Exception showFieldAccessException(
        #    Common          _common = null,
        #    TreeNodeTxt     _fieldList = '',
        #    AccessRight     _neededAccessLevel = AccessRight::View,
        #    URL             _helpUrl = '',
        #    SysInfoAction   _sysInfoAction = null)
        #{
        #    SysDictTable    dictTable;
        #    SysDictField    sysDictField;
        #    TreeNodeTxt     localFieldList = _fieldList;
        #    int             i;
        #
        #
        #    if (_common != null
        #        && localFieldList == '')
        #    {
        #        dictTable = new SysDictTable(_common.TableId);
        #        if (dictTable)
        #        {
        #            for (i = 1; i <= dictTable.fieldCnt(); i++)
        #            {
        #                sysDictField = new SysDictField(_common.TableId, dictTable.fieldCnt2Id(i));
        #
        #                if (_common.fieldAccessRight(_common.TableId, sysDictField.id()) < _neededAccessLevel)
        #                {
        #                    if (localFieldList == '')
        #                    {
        #                        localFieldList = fieldId2name(_common.TableId, sysDictField.id());
        #                    }
        #                    else
        #                    {
        #                        localFieldList = localFieldList + ', ' + fieldId2name(_common.TableId, sysDictField.id());
        #                    }
        #                }
        #            }
        #        }
        #    }
        #
        #    if (localFieldList == '')
        #    {
        #        return error("@SYS126562", _helpUrl, _sysInfoAction);
        #    }
        #    else
        #    {
        #        return error(strFmt("@SYS121974", tableId2name(_common.TableId), localFieldList), _helpUrl, _sysInfoAction);
        #    }
        #}
      ENDSOURCE
      SOURCE #showHelp
        #static void showHelp(URL _url)
        #{
        #    SysHelp::showURL(_url);
        #}
      ENDSOURCE
      SOURCE #sign
        #static real sign(real num)
        #{
        #    return num >= 0 ? 1 : -1;
        #}
      ENDSOURCE
      SOURCE #smartHeapMemorySizeUp
        #static void smartHeapMemorySizeUp(boolean _silent = true)
        #{
        #    HeapCheck   hc;
        #    int         i, pageSize, newPageSize, physMem, minPageSize;
        #    container   memStatus;
        #
        #    memStatus = WinAPI::getMemoryStatus();
        #    physMem = conPeek(memStatus,3)/1024/1024;
        #    minPageSize = min(32768,physMem * 32);
        #    setPrefix(funcName());
        #    if (!_silent)
        #    {
        #        info(strFmt('Physical Memory = %1 MB', physMem));
        #        info(strFmt('Minimum page size = %1 Bytes', minPageSize));
        #    }
        #
        #    hc = new HeapCheck();
        #    i = hc.poolCount();
        #    while (i>0)
        #    {
        #        setPrefix(strFmt('Pool no = %1', i));
        #        if (!_silent)
        #        {
        #            info(strFmt('FixedBlockSize = %1', hc.fixedBlockSize(i)));
        #            info(strFmt('SmallBlockSize = %1', hc.smallBlockSize(i)));
        #        }
        #
        #        pageSize = hc.pageSize(i);
        #        newPageSize = pageSize;
        #        while (newPageSize < minPageSize)
        #        {
        #            newPageSize = 2 * newPageSize;
        #        }
        #        if (!_silent)
        #        {
        #            info(strFmt('Old PageSize = %1', pageSize));
        #            info(strFmt('New PageSize = %1', newPageSize));
        #        }
        #
        #        hc.pageSize( i, newPageSize );
        #        i--;
        #    }
        #}
      ENDSOURCE
      SOURCE #sqrt
        #static real sqrt(real a)
        #{
        #    return power(a, 0.5);
        #}
      ENDSOURCE
      SOURCE #startLengthyOperation
        #static void startLengthyOperation()
        #{
        #    if(!isRunningOnServer())
        #    {
        #        if (infolog)
        #        {
        #            infolog.startLengthyOperation();
        #        }
        #    }
        #}
      ENDSOURCE
      SOURCE #str2Capital
        #static str str2Capital(str _str)
        #{
        #    return strUpr(subStr(_str, 1, 1)) + strLwr(subStr(_str, 2, 999999));
        #}
      ENDSOURCE
      SOURCE #str2CapitalWord
        #static str str2CapitalWord(str _str)
        #{
        #    int n;
        #
        #    _str = str2Capital(_str);
        #    n    = strScan(_str, ' ', 1, strLen(_str));
        #    while (n)
        #    {
        #        n++;
        #        _str = strPoke(_str, strUpr(subStr(_str, n, 1)), n);
        #        n    = strScan(_str, ' ', n, strLen(_str));
        #    }
        #    return _str;
        #}
      ENDSOURCE
      SOURCE #str2con
        #/// <summary>
        #/// Splits the given String by the specified separator and returns the contents in a container.
        #/// </summary>
        #/// <param name="_value">
        #/// The String value to be split.
        #/// </param>
        #/// <param name="_sep">
        #/// The separator.
        #/// </param>
        #/// <param name="_convertNumericToInt64">
        #/// A Boolean value that indicates whether to convert the value to an <c>int64</c> value; optional.
        #/// </param>
        #/// <returns>
        #/// A container, which has the String split by the specified separator.
        #/// </returns>
        #/// <remarks>
        #/// In the <paramref name="_convertNumericToInt64" /> parameter, a value of true indicates the returned
        #/// contents will be converted to an <c>int64</c> value if they only have numeric characters.A value of
        #/// false indicates that the returned values will not be converted to an <c>int64</c> value and String
        #/// values will always be returned. The default value of the <paramref name="_convertNumericToInt64" />
        #/// parameter is true.
        #/// </remarks>
        #static container str2con(str _value, str 10 _sep = ',', boolean _convertNumericToInt64 = true)
        #{
        #    int         length = strLen(_value);
        #    int         separatorLength = strLen(_sep);
        #    int         i = 1;
        #    int         j = strScan(_value, _sep, 1, length);
        #    container   ret;
        #    void add2Ret(str _current)
        #    {
        #        if (_convertNumericToInt64 && (match('<:d+>', _current)))
        #        {
        #            ret += str2int64(_current);
        #        }
        #        else
        #        {
        #            ret += _current;
        #        }
        #    }
        #
        #    while (j)
        #    {
        #        add2Ret(subStr(_value, i, j-i));
        #        i = j + separatorLength;
        #        j = strScan(_value, _sep, i, length);
        #    }
        #    add2Ret(subStr(_value, i, length-i+1));
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #str2con_RU
        ##define.Comma(",")
        #static container str2con_RU(str _string, str _separator = #Comma, boolean _ignoreNearSeparator = false)
        #{
        #    container con = conNull();
        #    int       pos, oldPos = 1;
        #    str       tmpStr;
        #
        #    do
        #    {
        #        pos    =  strScan(_string, _separator, pos ? pos + strLen(_separator) : 1, strLen(_string));
        #        tmpStr =  subStr(_string, oldPos, pos ? pos - oldPos : strLen(_string) + 1 - oldPos);
        #        if (tmpStr || ! _ignoreNearSeparator)
        #        {
        #            con += tmpStr;
        #        }
        #        oldPos =  pos + strLen(_separator);
        #    }
        #    while (pos);
        #
        #    return con;
        #}
      ENDSOURCE
      SOURCE #str2cryptoblob
        #static CryptoBlob str2cryptoblob(str _data)
        #{
        #    Binary b = new Binary((strLen(_data) + 1)*2);
        #
        #    if (_data)
        #    {
        #        b.wString(0,_data);
        #
        #        return binary2cryptoblob(b,(strLen(_data) +1)*2);
        #    }
        #    else
        #        return conNull();
        #
        #}
      ENDSOURCE
      SOURCE #str2DateDMY
        #static date  str2DateDMY(str 10 _str)
        #{
        #    return str2Date(_str, 123);
        #}
      ENDSOURCE
      SOURCE #str2HashKey
        #static int str2HashKey(str _str)
        #{
        #    int i, hash;
        #    int len = strLen(_str);
        #
        #    for (i=1; i<=len; i++)
        #    {
        #        hash = (hash << 5) + hash + char2num(_str, i);
        #    }
        #    return hash;
        #}
      ENDSOURCE
      SOURCE #str2IntOk
        #static boolean str2IntOk(str 100 _str)
        #{
        #    boolean retval;
        #    InteropPermission permission;
        #    System.Text.RegularExpressions.Regex re;
        #
        #    permission = new InteropPermission(InteropKind::ClrInterop);
        #    permission.assert();
        #
        #    // BP deviation documented
        #    re = new System.Text.RegularExpressions.Regex('^\\s*[+\\-]?\\s*[0-9]+\\s*$');
        #
        #    //return ClrInterop::getAnyTypeForObject(re.IsMatch(_str));
        #
        #    // BP deviation documented
        #    retval = CLRInterop::getAnyTypeForObject(re.IsMatch(_str));
        #
        #    return retval;
        #}
        #
      ENDSOURCE
      SOURCE #str2num_RU
        #static real str2num_RU(TempStr _text)
        #{
        #    return str2num(str2numPrep(_text));
        #}
      ENDSOURCE
      SOURCE #str2numOK
        #static boolean str2numOK(TempStr _tempStr)
        #{
        #    boolean retval;
        #    InteropPermission permission;
        #    System.Text.RegularExpressions.Regex re;
        #
        #    permission = new InteropPermission(InteropKind::ClrInterop);
        #    permission.assert();
        #
        #    // BP deviation documented
        #    re = new System.Text.RegularExpressions.Regex(
        #            '^\\s*[+\\-]?\\s*[0-9]+(\\.[0-9]+)?([+\\-]?[Ee][+\\-]?[1-9][0-9]*)?\\s*$');
        #
        #    //return ClrInterop::getAnyTypeForObject(re.IsMatch(_tempStr));
        #    // BP deviation documented
        #    retval = CLRInterop::getAnyTypeForObject(re.IsMatch(_tempStr));
        #    return retval;
        #}
        #
      ENDSOURCE
      SOURCE #str2numOK_RU
        #static boolean str2numOK_RU(TempStr _tempStr)
        #{
        #    return str2numOK(str2numPrep(_tempStr));
        #}
      ENDSOURCE
      SOURCE #str2numPrep
        #/// <summary>
        #/// Performs string pre-processing to soften requirements for the input string to be convertable to numeral.
        #/// </summary>
        #/// <param name="_text">
        #/// Text representation of a number.
        #/// </param>
        #/// <returns>
        #/// String that has first occurence of comma (if any) replaced with dot.
        #/// </returns>
        #/// <remarks>
        #/// Assumption is that valuable result should be produced if <paramref name="_text"/> represents a number with comma or dot as a decimal separator.
        #/// </remarks>
        #private static TempStr str2numPrep(TempStr _text)
        #{
        #    #define.comma(',')
        #    #define.dot  ('.')
        #
        #    TempStr ret = _text;
        #    int     commaPos = strFind(ret, #comma, 1, maxInt());
        #
        #    if (commaPos)
        #    {
        #        ret = strPoke(ret, #dot, commaPos);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #str2recId
        #static RecId str2recId(str _recIdStr)
        #{
        #    return str2int64(_recIdStr);
        #}
      ENDSOURCE
      SOURCE #str2set_W
        ##define.Comma(",")
        #static public Set str2set_W(str _string, str _separator = #Comma)
        #{
        #    Set ret = new Set(Types::String);
        #    int pos, oldPos = 1;
        #
        #    do
        #    {
        #        pos    =  strScan(_string,
        #                          _separator,
        #                          pos ? pos + strLen(_separator) : 1,
        #                          strLen(_string));
        #
        #        ret.add(subStr(_string,
        #                       oldPos,
        #                       pos ? pos - oldPos : strLen(_string) + 1 - oldPos));
        #
        #        oldPos =  pos + strLen(_separator);
        #    }
        #    while (pos);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #straightLineDepreciation
        #/// <summary>
        #/// Retrieves the constant depreciation amount for the specified asset for each depreciation period.
        #/// </summary>
        #/// <param name="price">
        #/// The purchase price of the asset.
        #/// </param>
        #/// <param name="scrap">
        #/// The scrap value of the asset.
        #/// </param>
        #/// <param name="life">
        #/// The number of periods in the expected life of the asset.
        #/// </param>
        #/// <returns>
        #/// The depreciation amount.
        #/// </returns>
        #/// <remarks>
        #/// This method is a rename of the <c>sln</c> method.
        #/// </remarks>
        #static real straightLineDepreciation(real price, real scrap, real life)
        #{
        #    return sln(price, scrap, life);
        #}
      ENDSOURCE
      SOURCE #strContains
        #static public boolean strContains(str _text, str _potentialContains)
        #{
        #    if (strScan(_text, _potentialContains, 1, maxInt()))
        #        return true;
        #    return false;
        #}
      ENDSOURCE
      SOURCE #strEndsWith
        #static boolean strEndsWith(str _string, str _potentialEnd)
        #{
        #    if (subStr(_string, strLen(_string)+1-strLen(_potentialEnd), strLen(_potentialEnd)) == _potentialEnd)
        #        return true;
        #    return false;
        #}
      ENDSOURCE
      SOURCE #strFmtByLanguage
        #/// <summary>
        #/// Formats the string using the specified language ID.
        #/// </summary>
        #/// <param name="_languageId">
        #/// The languege ID to be used as a culture for formatting the string.
        #/// </param>
        #/// <param name="_format">
        #/// The format string. Contains the placeholders for the values to be used in the formatted string. The placeholders are in .NET format.
        #/// </param>
        #/// <param name="_value0">
        #/// The value for the first placeholder in the format string.
        #/// </param>
        #/// <param name="_value1">
        #/// The value for the second placeholder in the format string.
        #/// </param>
        #/// <param name="_value2">
        #/// The value for the third placeholder in the format string.
        #/// </param>
        #/// <returns>
        #/// The formatted string.
        #/// </returns>
        #/// <remarks>
        #/// The format string should follow the .NET syntax.
        #/// </remarks>
        #public static str strFmtByLanguage(LanguageId _languageId, str _format, anytype _value0, anytype _value1 = 0, anytype _value2 = 0)
        #{
        #    System.Globalization.CultureInfo culture;
        #    System.Object [] obj;
        #    str res;
        #    int valuesCount = 1;
        #    System.Exception e;
        #
        #    if (!prmisDefault(_value1))
        #    {
        #        valuesCount++;
        #    }
        #
        #    if (!prmisDefault(_value2))
        #    {
        #        valuesCount++;
        #    }
        #
        #    obj = new System.Object[valuesCount]();
        #
        #    obj.SetValue(_value0, 0);
        #
        #    if (!prmisDefault(_value1))
        #    {
        #        obj.SetValue(_value1, 1);
        #    }
        #
        #    if (!prmisDefault(_value2))
        #    {
        #        obj.SetValue(_value2, 2);
        #    }
        #
        #    try
        #    {
        #        culture = new System.Globalization.CultureInfo(_languageId);
        #    }
        #    catch
        #    {
        #        culture = new System.Globalization.CultureInfo('en-US');
        #    }
        #
        #    try
        #    {
        #        res = System.String::Format(culture, _format, obj);
        #    }
        #    catch(Exception::CLRError)
        #    {
        #        e = CLRInterop::getLastException();
        #        while( e )
        #        {
        #            error( e.get_Message() );
        #            e = e.get_InnerException();
        #        }
        #        throw Exception::Error;
        #    }
        #
        #    return res;
        #}
      ENDSOURCE
      SOURCE #strFmtLB
        #/// <summary>
        #/// Replaces each occurrence of the characters ‘<c>\n</c>’ with one newline hexadecimal character 0x0A.
        #/// </summary>
        #/// <param name="_str">
        #/// The original String that might contain occurrences of ‘<c>\n</c>’.
        #/// </param>
        #/// <returns>
        #/// A String that contains newline hexadecimal characters instead of the ‘<c>\n</c>’ character pairs.
        #/// </returns>
        #/// <remarks>
        #/// This method can be used to improve the display in message boxes of Strings that contain ‘<c>\n</c>’
        #/// substrings.
        #/// </remarks>
        #static str strFmtLB(str _str)
        #{
        #    int i = strScan(_str, '\\n', 1, strLen(_str));
        #
        #    while (i)
        #    {
        #        _str = strDel(_str, i, 2);
        #        _str = strIns(_str, '\n', i);
        #        i    = strScan(_str, '\\n', i, strLen(_str));
        #    }
        #    return _str;
        #}
      ENDSOURCE
      SOURCE #stringFromGuid
        #//BP Deviation Documented
        #static str stringFromGuid(guid _value)
        #{
        #    return guid2str(_value);
        #}
      ENDSOURCE
      SOURCE #strLFix
        #static str strLFix(str _str, int _length, char _char = ' ')
        #{
        #    return subStr(_str, 1, _length) + strRep(_char, _length - strLen(_str));
        #}
      ENDSOURCE
      SOURCE #strList2str
        #/// <summary>
        #/// Concatenates a string list elements into a string.
        #/// </summary>
        #/// <param name="_list">
        #/// A list of string.
        #/// </param>
        #/// <param name="_delimiter">
        #/// A delimiter.
        #/// </param>
        #/// <returns>
        #/// A string created from a list.
        #/// </returns>
        #public static str strList2str(List _list, str _delimiter = ', ')
        #{
        #    ListIterator    listIterator = new ListIterator(_list);
        #    str             result;
        #
        #    while (listIterator.more())
        #    {
        #        result += listIterator.value();
        #
        #        listIterator.next();
        #
        #        if (listIterator.more())
        #        {
        #            result += _delimiter;
        #        }
        #    }
        #
        #    return result;
        #}
      ENDSOURCE
      SOURCE #strLRTrim
        #static str strLRTrim(str _str)
        #{
        #    return strLTrim(strRTrim(_str));
        #}
      ENDSOURCE
      SOURCE #strMax
        #static str 1000 strMax(ExtendedDataTypeName _name = '')
        #{
        #    DictType    dt;
        #    int         len;
        #
        #    if (! prmisDefault(_name))
        #    {
        #        dt  = new DictType(extendedTypeName2Id(_name));
        #        if (dt == null)
        #            len = 1000;
        #        else
        #            len = dt.stringLen();
        #    }
        #    else
        #    {
        #        len = 1000;
        #    }
        #
        #    return strRep(charMax(), len);
        #}
      ENDSOURCE
      SOURCE #strMin
        #static TempStr strMin()
        #{
        #    return '';
        #}
      ENDSOURCE
      SOURCE #strRemoveCr
        #static str strRemoveCr(str s)
        #{
        #    return strReplace(s, '\n', ' ');
        #}
      ENDSOURCE
      SOURCE #strReplace
        #static str strReplace(str _str, str _fromStr, str _toStr)
        #{
        #    int charNum;
        #    int fromLength  = strLen(_fromStr);
        #    int toLength    = strLen(_toStr);
        #
        #    if (_fromStr != _toStr)
        #    {
        #        charNum = strScan(_str, _fromStr, 1, strLen(_str));
        #
        #        if (fromLength != toLength)
        #        {
        #
        #            while (charNum)
        #            {
        #                _str = strDel(_str, charNum, fromLength);
        #                _str = strIns(_str, _toStr, charNum);
        #                charNum = strScan(_str, _fromStr, charNum + toLength, strLen(_str));
        #            }
        #        }
        #        else
        #        {
        #            while (charNum)
        #            {
        #                _str = strPoke(_str, _toStr, charNum);
        #                charNum = strScan(_str, _fromStr, charNum + toLength, strLen(_str));
        #            }
        #        }
        #    }
        #    return _str;
        #}
      ENDSOURCE
      SOURCE #strReplaceChars
        #static str strReplaceChars(str _str, char _char, int _cnt = 1)
        #{
        #    return strReplace(_str, _char, strRep(_char, _cnt));
        #}
      ENDSOURCE
      SOURCE #strReverse
        #/*
        #    Returns the input string reversed, so the first character becomes the last etc.
        #    Examples:
        #        A                               A
        #        Axapta                          atpaxA
        #        strReverse                      esreveRrts
        #        palindrom                       mordnilap
        #        RusserDressur                   russerDressuR
        #*/
        #static str strReverse(str _str)
        #{
        #    str ret;
        #    int i;
        #
        #    for (i = strLen(_str); i > 0; i--)
        #    {
        #        ret += subStr(_str, i, 1);
        #    }
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #strRFix
        #static str strRFix(str _str, int _length, char _char = ' ')
        #{
        #    return strRep(_char, _length - strLen(_str)) + subStr(_str, 1, _length);
        #}
      ENDSOURCE
      SOURCE #strSplit
        #/// <summary>
        #///    Splits a string into a list of substrings delimited by elements in the specified delimiter string.
        #/// </summary>
        #/// <param name="_stringToSplit">
        #///    The string to split into a list.
        #/// </param>
        #/// <param name="_delimiters">
        #///    A string of delimiter characters.
        #/// </param>
        #/// <returns>
        #///    A list of substrings from the <paramref name="_stringToSplit" /> parameter.
        #/// </returns>
        #/// <remarks>
        #///    Each character in the <paramref name="_delimiter" /> string is used to split the <paramref
        #///    name="_stringToSplit" /> parameter.
        #/// </remarks>
        #static List strSplit(str _stringToSplit, str _delimiters)
        #{
        #    List list = new List(Types::String);
        #    int oldPos = 1;
        #    int pos;
        #    int strLength = strLen(_stringToSplit);
        #
        #    do
        #    {
        #        pos = strFind(_stringToSplit, _delimiters, oldPos, strLength);
        #        if (!pos)
        #            pos = strLength+1;
        #
        #        list.addEnd(subStr(_stringToSplit, oldPos, pos-oldPos));
        #        oldPos = pos+1;
        #    } while (pos <= strLength);
        #
        #    return list;
        #}
        #
      ENDSOURCE
      SOURCE #strStartsWith
        #static public boolean strStartsWith(str _string, str _potentialStart)
        #{
        #    if (subStr(_string, 1, strLen(_potentialStart)) == _potentialStart)
        #        return true;
        #    return false;
        #}
      ENDSOURCE
      SOURCE #sumDigits
        #static int sumDigits(int number)
        #{
        #    int             charNum;
        #    int             charMax;
        #    int             sumDigits;
        #    str 20          chars;
        #
        #    chars       = int2str(number);
        #    charMax     = strLen(chars);
        #
        #    charNum = 0;
        #    while (charNum < charMax)
        #    {
        #        charNum   += 1;
        #        sumDigits += str2num(subStr(chars,charNum,1));
        #    }
        #
        #    return sumDigits;
        #}
      ENDSOURCE
      SOURCE #symbol2Enum
        #static int symbol2Enum(EnumId _id, str _symbol)
        #{
        #    DictEnum de = new DictEnum(_id);
        #
        #    return de.symbol2Value(_symbol);
        #}
      ENDSOURCE
      SOURCE #tableHasInstanceMethod
        #client server static boolean tableHasInstanceMethod(DictTable      dt,
        #                                                    IdentifierName methodName
        #                                                   )
        #{
        #    DictMethod dictMethod;
        #
        #    //validate arguments before using them
        #    if (dt == null)
        #        return false;
        #    dictMethod = new DictMethod(UtilElementType::TableInstanceMethod,dt.id(),methodName);
        #    return dictMethod && dictMethod.compiledOk();
        #}
      ENDSOURCE
      SOURCE #tableHasMethod
        #client server static boolean tableHasMethod(
        #    DictTable      dt,
        #    IdentifierName methodName
        #    )
        #{
        #    return SysDictTable::hasMethod(dt,methodName);
        #}
      ENDSOURCE
      SOURCE #tableHasStaticMethod
        #client server static boolean tableHasStaticMethod(DictTable      dt,
        #                                                  IdentifierName methodName
        #                                                 )
        #{
        #    DictMethod dictMethod;
        #
        #    //validate argumenrs before using them
        #    if (dt == null)
        #        return false;
        #    dictMethod = new DictMethod(UtilElementType::TableStaticMethod,dt.id(),methodName);
        #
        #    return dictMethod && dictMethod.compiledOk();
        #}
        #
      ENDSOURCE
      SOURCE #tableId2Name
        #static TableName tableId2Name(TableId _tableId)
        #{
        #    DictTable dictTable = new DictTable(_tableId);
        #    if (dictTable)
        #        return dictTable.name();
        #    return '';
        #}
      ENDSOURCE
      SOURCE #tableName2Id
        #static int tableName2Id(str _tableName)
        #{
        #    return new Dictionary().tableName2Id(_tableName);
        #}
      ENDSOURCE
      SOURCE #templateFolder_W
        #public static str templateFolder_W()
        #{
        #    #File
        #    str templateFolder = CompanyInfo::find().TemplateFolder_W;
        #
        #    if (templateFolder && !strFind(templateFolder, '/\\', strLen(templateFolder), -1))
        #    {
        #        templateFolder += #FilePathDelimiter;
        #    }
        #
        #    if (!templateFolder || !WinAPI::pathExists(templateFolder))
        #    {
        #        throw error(strFmt("@SYS110338", templateFolder),
        #                    '',
        #                    SysInfoAction_Formrun::newFormnameControlnameDesc(formStr(OMLegalEntity),
        #                                                                      identifierStr(TemplateFolder_W_TemplateFolder_W),
        #                                                                      "@SYS4157"));
        #    }
        #
        #    return templateFolder;
        #}
      ENDSOURCE
      SOURCE #time2StrHM
        #static TempStr time2StrHM(int timE)
        #{
        #    return num2str( timE div 3600       ,2,0,0,0)+':'+
        #           num2Str0(timE mod 3600 div 60,2,0,0,0);
        #}
      ENDSOURCE
      SOURCE #time2StrHMLeadingZero
        #static TempStr time2StrHMLeadingZero(int timE)
        #{
        #    str hourStr;
        #
        #    hourStr = num2str( timE div 3600       ,2,0,0,0);
        #    hourStr = strReplace(hourStr,' ','0');
        #    return hourStr+':'+
        #           num2Str0(timE mod 3600 div 60,2,0,0,0);
        #}
      ENDSOURCE
      SOURCE #time2StrHMS
        #static TempStr time2StrHMS(int time)
        #{
        #    return num2str( time div 3600       ,2,0,0,0)+':'+
        #           num2Str0(time mod 3600 div 60,2,0,0,0)+':'+
        #           num2Str0(time mod 3600 mod 60,2,0,0,0);
        #}
      ENDSOURCE
      SOURCE #timeConsumed
        #/// <summary>
        #/// Returns a time consumed string in the formation X hours X minutes X seconds. If X is 0 will not include the value + text.
        #/// Handles up to a 24 hour time difference not dependent on start/end time. If time consumed > 24 hours will only report time over 24 hour intervals.
        #/// </summary>
        #/// <param name="_startTime">Time process started</param>
        #/// <param name="_endTime">Time process ended</param>
        #/// <returns> (string) x hour/s x minute/s x seconds</returns>
        #public static str timeConsumed(int _startTime, int _endTime)
        #{
        #    int seconds, minutes, hours, totalTime;
        #    str timeStr = "";
        #
        #    if (_startTime > _endTime)
        #    {
        #        totalTime = _endTime + (str2time('23:59:59') - _startTime);
        #    }
        #    else
        #    {
        #        totalTime = _endTime - _startTime;
        #    }
        #
        #    seconds = totalTime mod 60;
        #    minutes = totalTime mod 3600 div 60;
        #    hours = totalTime div 3600;
        #
        #    if (hours > 0)
        #        if (hours == 1)
        #            timestr = timeStr + strFmt("@SYS90502", hours);
        #        else
        #            timestr = timeStr + strFmt("@SYS54202", hours);
        #
        #    if (minutes > 0)
        #        if (minutes == 1)
        #            timestr = timeStr + ' ' + strFmt("@SYS90503", minutes);
        #        else
        #            timeStr = timeStr + ' ' + strFmt("@SYS54205", minutes);
        #
        #    if (seconds > 0)
        #        timestr = timeStr + ' ' + strFmt("@SYS54206", seconds);
        #
        #    return strLRTrim(timeStr);
        #}
      ENDSOURCE
      SOURCE #timeMax
        #static client server int timeMax()
        #{
        #    return DateTimeUtil::time(DateTimeUtil::maxValue());
        #}
      ENDSOURCE
      SOURCE #typeId2ExtendedTypeId
        #/*
        #    Returns a valid Extended Data Type Id, given the argument in the form the system function typeId returns
        #*/
        #static ExtendedTypeId typeId2ExtendedTypeId(int _extendedType)
        #{
        #    if ((_extendedType & 0xffff) != Types::UserType)
        #        throw error(strFmt("@SYS26445",funcName()));
        #
        #    return _extendedType >> 16 & 0xffff;
        #}
      ENDSOURCE
      SOURCE #typeId2Type
        #/*
        #    Returns the base type of a type, given the argument in the form the system function typeId returns
        #*/
        #static Types typeId2Type(int _id)
        #{
        #    return extendedTypeId2Type(typeId2ExtendedTypeId(_id));
        #}
      ENDSOURCE
      SOURCE #typeName2Type
        #/// <summary>
        #///    Retrieves the base type of a type.
        #/// </summary>
        #/// <param name="_typeName">
        #///    The name of an X++ type.
        #/// </param>
        #/// <returns>
        #///    The base type of a type.
        #/// </returns>
        #/// <exception cref="M:Exception::Error">
        #///    The type name that was passed into the method is not a recognized X++ type.
        #/// </exception>
        #static Types typeName2Type(IdentifierName _typeName)
        #{
        #    int id = extendedTypeName2Id(_typeName);
        #
        #    if (id)
        #        return extendedTypeId2Type(id);
        #
        #    if (enumName2Id(_typeName))
        #        return Types::Enum;
        #
        #    if (className2Id(_typeName))
        #        return Types::Class;
        #
        #    if (tableName2id(_typeName))
        #        return Types::Record;
        #
        #    throw error(Error::wrongUseOfFunction(funcName()));
        #}
      ENDSOURCE
      SOURCE #units2mm
        #public static real units2mm(real  _measurement,
        #                            Units _units)
        #{
        #    real    convertedMeasurement;
        #
        #    if (_measurement)
        #    {
        #        switch (_units)
        #        {
        #            case Units::mm :
        #                convertedMeasurement = _measurement;
        #                break;
        #
        #            case Units::cm :
        #                convertedMeasurement = _measurement * 10.0;
        #                break;
        #
        #            case Units::pt :
        #                convertedMeasurement = _measurement * 25.3995 / 72;
        #                break;
        #
        #            case Units::char :
        #                convertedMeasurement = _measurement * 4.2;
        #                break;
        #
        #            case Units::Inch :
        #                convertedMeasurement = _measurement * 25.3995;
        #                break;
        #        }
        #    }
        #    else
        #    {
        #        convertedMeasurement = _measurement;
        #    }
        #    return convertedMeasurement;
        #}
        #
      ENDSOURCE
      SOURCE #unsignedInt2Real
        #static real unsignedInt2Real(int i)
        #{
        #    real rmaxInt = maxInt();
        #    real rminInt = minInt();
        #    real r = i;
        #
        #    if (i<0)
        #        return 1+rmaxInt+r-rminInt;
        #    return i;
        #}
      ENDSOURCE
      SOURCE #utcDateTime2SystemDateTime
        #/// <summary>
        #/// Converts an X++ <c>utcdatetime</c> value to a .NET <c>System.DateTime</c> object.
        #/// </summary>
        #/// <param name="_utcDateTime">
        #/// The X++ <c>utcdatetime</c> to convert.
        #/// </param>
        #/// <returns>
        #/// A .NET <c>System.DateTime</c> object.
        #/// </returns>
        #static client server anytype utcDateTime2SystemDateTime(utcdatetime _utcDateTime)
        #{
        #    // BP Deviation documented
        #    return CLRInterop::getObjectForAnyType(_utcDateTime);
        #}
      ENDSOURCE
      SOURCE #utcDateTimeNull
        #static utcdatetime utcDateTimeNull()
        #{
        #    return 1900-01-01T00:00:00;
        #}
      ENDSOURCE
      SOURCE #valueFromXMLNode
        #static Struct valueFromXMLNode (Types t, XmlNode n)
        #{
        #    #define.value('value')
        #    Struct retval;
        #    boolean enum; // Any enumeration type will do...
        #
        #    //validate arguments befor using them
        #    if (n == null)
        #        return null;
        #
        #    retval = new Struct(t, #value);
        #    switch(t)
        #    {
        #        case Types::Int64 :
        #            retval.value(#value, str2int64(getXmlNodeValue(n)));
        #            break;
        #
        #        case Types::Integer :
        #            retval.value(#value, str2int(getXmlNodeValue(n)));
        #            break;
        #
        #        case Types::Class :
        #            retval.value(#value, Global::objectFromXMLNode(n));
        #            break;
        #
        #        case Types::Container :
        #            retval.value(#value, Global::containerFromXMLNode(n));
        #            break;
        #
        #        case Types::Guid :
        #            retval.value(#value, str2guid(Global::getXmlNodeValue(n)));
        #            break;
        #
        #        case Types::Date :
        #            retval.value(#value, str2Date(getXmlNodeValue(n), 321));
        #            break;
        #
        #        case Types::UtcDateTime:
        #            retval.value(#value, str2datetime(getXmlNodeValue(n),DateFlags::None));
        #            break;
        #
        #        case Types::Enum :
        #            enum = str2int(getXmlNodeValue(n));
        #            retval.value(#value, enum);
        #            break;
        #
        #        case Types::Real :
        #            retval.value(#value, str2num(getXmlNodeValue(n)));
        #            break;
        #
        #        case Types::Record :
        #            retval.value(#value, Global::recordFromXMLNode(n));
        #            break;
        #
        #        case Types::BLOB :
        #            // <element type="blob"> 0123192648172.... </element>
        #            retval.value(#value, BinData::stringToData(getXmlNodeValue(n)));
        #            break;
        #
        #        case Types::String :
        #        case Types::RString :
        #        case Types::VarString :
        #            retval.value(#value, getXmlNodeValue(n));
        #            break;
        #    }
        #    return retval;
        #}
      ENDSOURCE
      SOURCE #warning
        #client server static Exception warning(SysInfoLogStr txt, URL helpUrl = '', SysInfoAction _sysInfoAction = null)
        #{
        #    return infolog.add(Exception::Warning, getPrefix()+txt, helpUrl, _sysInfoAction, false);
        #}
      ENDSOURCE
      SOURCE #webReportHasMethod
        #client static boolean webReportHasMethod(
        #    ReportRun        rr,
        #    IdentifierName methodName
        #    )
        #{
        #    //validate arguments before using them
        #    if (rr == null)
        #        return false;
        #
        #    return TreeNode::findNode('\\Web\\Web Reports\\'+rr.name()+'\\methods\\'+methodName) ? true : false;
        #}
      ENDSOURCE
      SOURCE #webSession
        #// In this global method, we are storing the newly created WebSession object
        #// in Session block.  Earlier it was being stored
        #// in GlobalCache, which was not giving the performance as expected.
        #// Hence we are storing it in Session block now. (thru newly introduced
        #// property in infolog).
        #//
        #server client static WebSession webSession(Name appName = '',boolean initnew = false, CompanyId company = '')
        #{
        #    WebSession      webSession;
        #
        #    // if there's no client, return null immediately
        #    if ( !xGlobal::hasClient() )
        #        return null;
        #
        #    if (company && company != curext())
        #    {
        #        appl.setDefaultCompany(company);
        #    }
        #    webSession = webSessionClient(appName, initnew);
        #
        #    return webSession;
        #}
      ENDSOURCE
      SOURCE #webSessionClient
        #private client static WebSession webSessionClient(Name appName = '',boolean initnew = false)
        #{
        #    AxaptaCOMConnectorMonitor mon;
        #    WebSession      webSession;
        #
        #    if (! initnew)
        #    {
        #        webSession = infolog.webSession();
        #        if( webSession )
        #        {
        #            return webSession;
        #        }
        #    }
        #    else
        #        webSession = null;
        #
        #    if (clientKind() == ClientType::COMObject)
        #    {
        #        mon = new AxaptaCOMConnectorMonitor();
        #        if (mon.isAxaptaInternetConnector())
        #        {
        #            webSession = new WebSession(appName);
        #            infolog.webSession(webSession);
        #        }
        #    }
        #    return webSession;
        #}
      ENDSOURCE
      SOURCE #webSessionClientAdd
        #/// <summary>
        #/// Caches an instance of the <c>WebSession</c> class.
        #/// </summary>
        #/// <param name="webSession">
        #/// The <c>WebSession</c> object to cache.
        #/// </param>
        #/// <remarks>
        #/// The Web session reference is being stored in Session Block for fast retrieval.
        #/// </remarks>
        #public static void webSessionClientAdd(WebSession webSession)
        #{
        #    infolog.webSession(webSession);
        #}
      ENDSOURCE
      SOURCE #webSessionClientRemove
        #//
        #// While creating the WebSession in Global::webSession()
        #// web session reference is being stored in Session Block
        #// for fast retrieval.  Hence, here
        #// we must set the reference to null in Session block.
        #//
        #static void webSessionClientRemove()
        #{
        #    infolog.webSession(null);
        #}
      ENDSOURCE
      SOURCE #weekOfYear
        #/// <summary>
        #/// Retrieves a sequence number based on the latest occurrence of the first day of the week in the
        #/// year, where that day is before or on the input date, all according to local settings.
        #/// </summary>
        #/// <param name="_curDate">
        #/// The date for which the week-of-year information is desired.
        #/// </param>
        #/// <returns>
        #/// A value between 1 and 53.
        #/// </returns>
        #/// <remarks>
        #/// The value returned by this method is affected by the local settings of the computer. For more
        #/// information, you can search the Windows registry and the Web for the strings <c>iFirstDayOfWeek</c>
        #/// and <c>iFirstWeekOfYear</c>.This method generally returns the sequence number of the latest Sunday
        #/// of the year before or on the input date value unless there are no more Sundays that year. The
        #/// return values for dates near the start or end of the year are determined by various details.Assume
        #/// that the local settings have Sunday as the first day of the week, which means
        #/// <c>iFirstDayOfWeek=0</c>. Also assume that January 1 is always considered to be part of the first
        #/// week of the year, which means <c>iFirstWeekOfYear=0</c>. In this context, consider the year 2003.
        #/// The first day of 2003 is a Wednesday. This means an input date in January of Saturday 4\1\2003
        #/// returns 1, and the next day Sunday 5\1\2003 returns 2.The last day of 2003 is also a Wednesday. An
        #/// input of Saturday 27\12\2003 returns 52, and Sunday 28\12\2003 returns 1 because there are no more
        #/// Sundays that year.Unlike the <c>weekOfYear</c> method, the <c>wkOfYr</c> function calculates a
        #/// return value according to the ISO 8601 specification.
        #/// </remarks>
        #static int weekOfYear(date _curDate)
        #{
        #    int firstDayOfWeek;
        #    int firstWeekOfYear;
        #    int dowJan1st;
        #    int dowCurDate;
        #    int week;
        #    date normDate;
        #    date testDate;
        #    #TimeConstants
        #
        #    normDate = dateStartYr(_curDate);
        #
        #    // Get locale settings.
        #    firstDayOfWeek = firstDayOfWeek();
        #    firstWeekOfYear = firstWeekOfYear();
        #
        #    // The dayofwk(...) function returns
        #    // a value between 1 and 7.
        #    // The logic below is expecting 0 - 6 so
        #    // the 1 is subtracted from the result.
        #    dowJan1st = dayOfWk(normDate) - 1;
        #    dowCurDate = dayOfWk(_curDate) - 1;
        #
        #    // The dayofwk function used above returns
        #    // the ISO-8601 day of week, where Monday is 1
        #    // and recall that the 1 was subtracted from the result
        #    // to get a value between (0 - 6).
        #    //
        #    // If the locale settings (firstDayOfWeek) is
        #    // not Monay (i.e. > 0) then the caclulated
        #    // day of week results need to be adjusted
        #    // so they align with the locale setting.
        #    if (firstDayOfWeek > 0)
        #    {
        #        dowJan1st = (dowJan1st + (#DaysPerWeek - firstDayOfWeek)) mod #DaysPerWeek;
        #        dowCurDate = (dowCurDate + (#DaysPerWeek - firstDayOfWeek)) mod #DaysPerWeek;
        #    }
        #
        #    // The normDate represents a day in the first week of the year.
        #    // The following will adjust the normDate so the day of week
        #    // will align with the target date.
        #    //
        #    // For example: if normDate is Sunday and target date is Tuesday
        #    //              the normDate will be adjusted to Tuesday
        #    //              of the 1st week of the year.
        #    normDate = normDate + (dowCurDate - dowJan1st);
        #
        #    switch(firstWeekOfYear)
        #    {
        #        case 0: // Week starts on Jan 1
        #            week = ((_curDate - normDate) / #DaysPerWeek) + 1; // calculate week number.
        #
        #            if (week > 52)
        #            {
        #                // Look at the last day of the week and compare it
        #                // to the target date.  If the year is different
        #                // then the target date is part of week 1 for next year.
        #                testDate = _curDate + ((#DaysPerWeek - 1) - dowCurDate);
        #                if (year(testDate) != year(_curDate))
        #                {
        #                    week = 1;
        #                }
        #            }
        #            break;
        #
        #        case 1: // First full week.
        #            if (dowJan1st != 0)
        #            {
        #                // If day of week for Jan 1st is not on the
        #                // the 1st day of the week (0), then
        #                // adjust the normDate to next week (the 1st full week).
        #                normDate = normDate + #DaysPerWeek;
        #            }
        #
        #            if (_curDate < normDate)
        #            {
        #                // The target date is prior to the 1st week, so
        #                // it considered to be part of last year.
        #                // Get the week for 12/31 of last year.
        #                week = weekOfYear(dateStartYr(_curDate) - 1);
        #            }
        #            else
        #            {
        #                week = ((_curDate - normDate) / #DaysPerWeek) + 1; // calculate the week number.
        #            }
        #            break;
        #
        #        case 2: // First 4-day week
        #        {
        #            if (firstDayOfWeek == 0)
        #            {
        #                // Use ISO-8601 when first day of week is Monday.
        #                week = wkOfYr(_curdate);
        #            }
        #            else
        #            {
        #                if (dowJan1st > 3)
        #                {
        #                    // If 1/1 starts on the 5th day
        #                    // Then adust normDate to next week (first 4-day week).
        #                    normDate = normDate + #DaysPerWeek;
        #                }
        #
        #                if (_curDate < normDate)
        #                {
        #                    // The target date is prior to the 1st week, so
        #                    // it considered to be part of last year.
        #                    // Get the week for 12/31 of last year.
        #                    week = weekOfYear(dateStartYr(_curDate) - 1);
        #                }
        #                else
        #                {
        #                    week = ((_curDate - normDate) / #DaysPerWeek) + 1; // Calculate the week number.
        #                    if (week > 52 && dowCurDate < 3)
        #                    {
        #                        // Check the 5th day of the target week.
        #                        // If the year is different then the target date
        #                        // is part of week 1 for next year.
        #                        testDate = _curDate + (3 - dowCurDate);
        #                        if (year(testDate) != year(_curDate))
        #                        {
        #                            week = 1;
        #                        }
        #                    }
        #                }
        #            }
        #        }
        #    }
        #
        #    return week;
        #}
      ENDSOURCE
      SOURCE #xmlGetTypeFromSpelling
        #static Types xmlGetTypeFromSpelling(str typeName)
        #{
        #    switch (typeName)
        #    {
        #        case 'int'      : return Types::Integer;
        #        case 'real'     : return Types::Real;
        #        case 'date'     : return Types::Date;
        #        case 'str'      : return Types::String;
        #        case 'enum'     : return Types::Enum;
        #        case 'class'    : return Types::Class;
        #        case 'container': return Types::Container;
        #        case 'record'   : return Types::Record;
        #        case 'int64'    : return Types::Int64;
        #        case 'guid'     : return Types::Guid;
        #        case 'utcdatetime' : return Types::UtcDateTime;
        #    }
        #    return Types::void;
        #}
      ENDSOURCE
      SOURCE #xmlString
        #// Returns a XML string describing the given value of the given type.
        #static str xmlString(anytype value, Types theType, int indent=0)
        #{
        #    str r;
        #    Object o;
        #    Common record;
        #
        #    // Determine whether the string contains <>&
        #    str legalXMLString(str s)
        #    {
        #        int i, len = strLen(s);
        #        boolean noProblem = strFind(s, '<&>', 1, len) == 0;
        #        str res;
        #
        #        if (noProblem)
        #        {
        #            res = s;
        #        }
        #        else
        #        {
        #            // Check if the string contains the string "]]>", that is used to delimit
        #            // a CDATA section. If so, the > must be escaped, yielding "]]&gt;"
        #            i = 1;
        #            do
        #            {
        #                i = strScan(s, ']]>', i, len);
        #                if (i == 0)
        #                {
        #                    break;
        #                }
        #                else
        #                {
        #                    s = strDel(s, i, 3);
        #                    s = strIns(s, ']]&gt;', i);
        #                    len += 3;   // Length has increased because ]]> changed to ]]&gt;
        #                }
        #            } while (true);
        #
        #            res = strFmt('<![CDATA[%1]]>', s);
        #        }
        #        return res;
        #    }
        #
        #    str typeToString(Types t)
        #    {
        #        switch (t)
        #        {
        #            case Types::Container   : return 'container';
        #            case Types::Date        : return 'date';
        #            case Types::Time        : return 'time';
        #            case Types::UtcDateTime    : return 'datetime';
        #            case Types::Enum        : return 'enum';
        #            case Types::Integer     : return 'int';
        #            case Types::Real        : return 'real';
        #            case Types::Record      : return 'record';
        #            case Types::VarString   :
        #            case Types::String      : return 'str';
        #            case Types::BLOB        : return 'blob';
        #            case Types::Int64       : return 'int64';
        #            case Types::Guid        : return 'guid';
        #        }
        #        return 'unknown';
        #    }
        #
        #    str containerXML(container c, int _indent)
        #    {
        #        str result;
        #        int i;
        #        Types t;
        #        container contents;
        #
        #        result  = strRep(' ', _indent) + '<container>\n';
        #
        #        for (i = 1; i <= conLen(c); i++)
        #        {
        #            t = typeOf(conPeek(c, i));
        #
        #            if (t == Types::Container)
        #            {
        #                contents = conPeek(c, i);
        #                if (conLen(contents) == 1 && typeOf(conPeek(contents, 1)) == Types::BLOB)
        #                {
        #                    result += strRep(' ', _indent+4) + '<element type=\"' + typeToString(Types::BLOB) + '\">';
        #                    result += BinData::dataToString(contents);
        #                    result += '</element>\n';
        #                }
        #                else
        #                {
        #                    result += strRep(' ', _indent+4) + '<element type=\"' + typeToString(t) + '\">\n';
        #                    result += Global::xmlString(conPeek(c, i), t, indent+4+4);
        #                    result += strRep(' ', _indent+4);
        #                    result += '</element>\n';
        #                }
        #            }
        #            else if (t == Types::BLOB)
        #            {
        #                result += strRep(' ', _indent+4) + '<element type=\"' + typeToString(Types::BLOB) + '\">';
        #                result += BinData::dataToString(c);
        #                result += '</element>\n';
        #            }
        #            else
        #            {
        #                result += strRep(' ', _indent+4) + '<element type=\"' + typeToString(t) + '\">';
        #                result += Global::xmlString(conPeek(c, i), t, 0);
        #                result += '</element>\n';
        #            }
        #        }
        #
        #        result += strRep(' ', _indent) + '</container>\n';
        #        return result;
        #    }
        #
        #    str blobXML(container c, int _indent)
        #    {
        #        str result;
        #
        #        if (conLen(c) == 1 && typeOf(conPeek(c, 1)) == Types::BLOB)
        #        {
        #            result += strRep(' ', _indent) + '<element type=\"' + typeToString(Types::BLOB) + '\">';
        #            result += BinData::dataToString(c);
        #            result += '</element>\n';
        #            return result;
        #        }
        #        else
        #        {
        #            return containerXML(c, _indent);
        #        }
        #    }
        #
        #    r = strRep(' ', indent);
        #
        #    switch (theType)
        #    {
        #    case Types::RString:
        #    case Types::VarString:
        #    case Types::String:     r += legalXMLString(value);
        #                            break;
        #
        #    case Types::Integer:    r += int2str(value); break;
        #    case Types::Real:       r += num2str(value,
        #                                        /* min chars */ 1,
        #                                        /* decimals */  2,
        #                                        /* decimals = point */ 1,
        #                                        /* no thousand sep */ 0); break;
        #
        #    case Types::Date:       // Use ISO-8601, that is XML standard for data w.o. time
        #                            r += date2str(value, 321,  2, 3, 2, 3, 4, DateFlags::None);
        #                            break;
        #
        #    case Types::Time:       r += time2StrHM(value); break;
        #    case Types::Enum:       // Return the ordinal value
        #                            r += int2str(value); break;
        #
        #    case Types::UtcDateTime:   r += datetime2str(value, DateFlags::None); break;
        #    case Types::Container:  r = containerXML(value, indent); break;
        #
        #    case Types::Record:     record = value;
        #                            r = record.xml(indent);
        #                            break;
        #    case Types::Class:      o = value;
        #                            r = o.xml(indent);
        #                            break;
        #    case Types::UserType:   /* Only base types arrive here */ r = 'User type???'; break;
        #    case Types::AnyType:    r += strFmt('%1', value); break;
        #    case Types::BLOB:       r = blobXML(value, indent); break;
        #    case Types::void:       /* void values may not be embedded in records */ break;
        #    case Types::Int64:      r += int642str(value); break;
        #    case Types::Guid:       r += guid2str(value); break;
        #    default :               r += '??? ' + enum2str(theType) + ' ???';
        #    }
        #    return r;
        #}
      ENDSOURCE
      SOURCE #yearDiff
        #static int yearDiff(date d1, date d2)
        #{
        #    date boundary;
        #    int offset;
        #
        #    if ( d1 < d2)
        #    {
        #      boundary = mkDate(dayOfMth(d1), mthOfYr(d1), year(d2));
        #      offset = (d2 - boundary) < 0 ? -1 : 0;
        #    }
        #    else
        #    {
        #      boundary = mkDate(dayOfMth(d2), mthOfYr(d2), year(d1));
        #      offset = (d1 - boundary) < 0 ? 1 : 0;
        #    }
        #
        #    return year(d1) - year (d2) - offset ;
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: END
